{
"version": 3,
"sourceRoot": "Source",
"sources": ["WebSharper.UI.Next/Abbrev.fs", "WebSharper.UI.Next/AppendList.fs", "WebSharper.UI.Next/DomUtility.fs", "WebSharper.UI.Next/Trie.fs", "WebSharper.UI.Next/Snap.fs", "WebSharper.UI.Next/Reactive.fs", "WebSharper.UI.Next/Models.fs", "WebSharper.UI.Next/Animation.fs", "WebSharper.UI.Next/Attr.Client.fs", "WebSharper.UI.Next/Doc.Client.fs", "WebSharper.UI.Next/Flow.fs", "WebSharper.UI.Next/Routing.fs", "WebSharper.UI.Next/Input.fs"],
"sourcesContent": ["// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2014 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\nnamespace WebSharper.UI.Next\n\nopen System\nopen System.Collections\nopen WebSharper\nopen WebSharper.JavaScript\n\nmodule Array =\n\n    /// Returns defaultValue if array is empty.\n    /// Otherwise makes a binary tree of the array elements and uses reduction to combine\n    /// all items into a single value.\n    [<JavaScript>]\n    let TreeReduce (defaultValue: 'A) (reduction: 'A -> 'A -> 'A) (array: 'A[]) : 'A =\n        let l = array.Length\n        let rec loop off len =\n            match len with\n            | n when n <= 0 -> defaultValue\n            | 1 when off >= 0 && off < l ->\n                array.[off]\n            | n ->\n                let l2 = len / 2\n                let a = loop off l2\n                let b = loop (off + l2) (len - l2)\n                reduction a b\n        loop 0 l\n\n    /// Returns defaultValue if array is empty.\n    /// Otherwise makes a binary tree of the array elements and uses reduction to combine \n    /// all items into a single value using the mapping function first on each item.\n    [<JavaScript>]\n    let MapTreeReduce (mapping: 'A -> 'B) (defaultValue: 'B) (reduction: 'B -> 'B -> 'B) (array: 'A[]) : 'B =\n        let l = array.Length\n        let rec loop off len =\n            match len with\n            | n when n <= 0 -> defaultValue\n            | 1 when off >= 0 && off < l ->\n                mapping array.[off]\n            | n ->\n                let l2 = len / 2\n                let a = loop off l2\n                let b = loop (off + l2) (len - l2)\n                reduction a b\n        loop 0 l\n\n    [<JavaScript>]\n    /// Same as Array.ofSeq, but if argument is an array, it does not copy it.\n    let ofSeqNonCopying (xs: seq<'T>) : 'T [] =\n        if xs :? System.Array then\n            xs :?> 'T[]\n        elif xs :? _ list then\n            Array.ofList (xs :?> 'T list)\n        elif Object.ReferenceEquals(xs, null) then\n            [||]\n        else\n            let q : 'T [] = [||]\n            use o = xs.GetEnumerator()\n            while o.MoveNext() do\n                q.JS.Push(o.Current) |> ignore\n            q\n\n    [<JavaScript>]\n    /// Unsafe operation, modifies each element of an array by a mapping function.\n    let mapInPlace (f: 'T1 -> 'T2) (arr: 'T1 []) =\n        if IsClient then\n            for i = 0 to Array.length arr - 1 do\n                arr.JS.[i] <- As (f arr.JS.[i])\n            As<'T2[]> arr\n        else Array.map f arr\n\nmodule internal String =\n\n    [<JavaScript>]\n    let isBlank s =\n        String.forall Char.IsWhiteSpace s\n\n/// Abbreviations and small utilities for this assembly.\n[<AutoOpen>]\nmodule internal Abbrev =\n\n    type Dictionary<'K,'V> = Generic.Dictionary<'K,'V>\n    type Document = Dom.Document\n    type Element = Dom.Element\n    type HashSet<'T> = Generic.HashSet<'T>\n    type IComparable = System.IComparable\n    type IEnumerable = Collections.IEnumerable\n    type IEnumerable<'T> = Generic.IEnumerable<'T>\n    type IEqualityComparer<'T> = Generic.IEqualityComparer<'T>\n    type MethodImplAttribute = System.Runtime.CompilerServices.MethodImplAttribute\n    type MethodImplOptions = System.Runtime.CompilerServices.MethodImplOptions\n    type Node = Dom.Node\n    type Object = System.Object\n    type TextNode = Dom.Text\n    type DomEvent = Dom.Event\n\n    [<JavaScript; Inline>]\n    let U<'T> = As<'T> JS.Undefined\n\n    [<Inline \"$f()\">]\n    let lock root f = lock root f\n\n    [<Inline; JavaScript>]\n    let ( ? ) (x: obj) (y: string) = ( ? ) x y\n\n    [<Inline; JavaScript>]\n    let ( ?<- ) (x: obj) (y: string) (z: obj) = ( ?<- ) x y z\n\n    [<JavaScript>]\n    module Fresh =\n\n        let mutable private counter = 0\n\n        let Int () =\n            counter <- counter + 1\n            counter\n\n        let Id () =\n            counter <- counter + 1\n            \"uid\" + string counter\n\n    [<JavaScript>]\n    module HashSet =\n\n        let ToArray (set: HashSet<'T>) =\n            let arr = Array.create set.Count JS.Undefined\n            set.CopyTo(arr)\n            arr\n\n        let Except (excluded: HashSet<'T>) (included: HashSet<'T>) =\n            let set = HashSet<'T>(ToArray included)\n            set.ExceptWith(ToArray excluded)\n            set\n\n        let Intersect (a: HashSet<'T>) (b: HashSet<'T>) =\n            let set = HashSet<'T>(ToArray a)\n            set.IntersectWith(ToArray b)\n            set\n\n        let Filter (ok: 'T -> bool) (set: HashSet<'T>) =\n            HashSet<'T>(ToArray set |> Array.filter ok)\n\n    [<JavaScript>]\n    module Dict =\n\n        let ToKeyArray (d: Dictionary<_,_>) =\n            let arr = Array.create d.Count JS.Undefined\n            d |> Seq.iteri (fun i kv -> arr.[i] <- kv.Key)\n            arr\n\n        let ToValueArray (d: Dictionary<_,_>) =\n            let arr = Array.create d.Count JS.Undefined\n            d |> Seq.iteri (fun i kv -> arr.[i] <- kv.Value)\n            arr\n\n    module Queue =\n\n        [<Inline \"$q\">]\n        let ToArray (q: Generic.Queue<_>) = q.ToArray()\n\n    [<JavaScript>]\n    [<Sealed>]\n    type Slot<'T,'K when 'K : equality>(key: 'T -> 'K, value: 'T) =\n        member s.Value = value\n\n        override s.Equals(o: obj) =\n            key value = key (o :?> Slot<'T,'K>).Value\n\n        override s.GetHashCode() = hash (key value)\n\n    [<JavaScript>]\n    type Slot =\n        static member Create key value = Slot(key, value)\n\n    [<JavaScript>]\n    module Async =\n\n        [<Direct \"console.log('WebSharper UI.Next: Uncaught asynchronous exception', $e)\">]\n        let OnError (e: exn) = ()\n\n        let StartTo comp k =\n            Async.StartWithContinuations (comp, k, OnError, ignore)\n\n        [<Inline \"WebSharper.Concurrency.scheduler().Fork($f)\">]\n        let Schedule f =\n            async { return f () }\n            |> Async.Start\n\n    [<JavaScript>]\n    module Mailbox =\n\n        type MailboxState =\n            | Idle = 0\n            | Working = 1\n            | WorkingMore = 2\n\n        /// Simplified MailboxProcessor implementation.\n        let StartProcessor procAsync =\n            let st = ref MailboxState.Idle\n            let rec work() =\n                async {\n                    do! procAsync\n                    match !st with\n                    | MailboxState.Working -> \n                        st := MailboxState.Idle\n                    | MailboxState.WorkingMore ->\n                        st := MailboxState.Working\n                        return! work() \n                    | _ -> ()\n                }\n            let post() =\n                match !st with\n                | MailboxState.Idle ->\n                    st := MailboxState.Working\n                    Async.Start (work()) \n                | MailboxState.Working -> \n                    st := MailboxState.WorkingMore\n                | _ -> ()\n            post\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2014 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\nnamespace WebSharper.UI.Next\nopen WebSharper\n\nopen System.Collections.Generic\n\ntype AppendList<'T> =\n    | AL0\n    | AL1 of 'T\n    | AL2 of AppendList<'T> * AppendList<'T>\n    | AL3 of 'T []\n\n[<JavaScript>]\nmodule AppendList =\n\n    type T<'T> = AppendList<'T>\n\n    let Empty<'T> : T<'T> = AL0\n\n    let Append x y =\n        match x, y with\n        | AL0, x | x, AL0 -> x\n        | _ -> AL2 (x, y)\n\n    let Concat xs =\n        Array.ofSeqNonCopying xs\n        |> Array.TreeReduce Empty Append\n\n    let Single x =\n        AL1 x\n\n    let ToArray xs =\n        let out = Queue()\n        let rec loop xs =\n            match xs with\n            | AL0 -> ()\n            | AL1 x -> out.Enqueue x\n            | AL2 (x, y) -> loop x; loop y\n            | AL3 xs -> Array.iter (fun v -> out.Enqueue v) xs\n        loop xs\n        out.ToArray()\n\n    let FromArray xs =\n        match Array.length xs with\n        | 0 -> AL0\n        | 1 -> AL1 xs.[0]\n        | _ -> AL3 (Array.copy xs)\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2014 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\nnamespace WebSharper.UI.Next\n\nopen WebSharper\nopen WebSharper.JavaScript\nopen WebSharper.JQuery\n\n/// Utility functions for manipulating DOM.\n[<JavaScript>]\nmodule internal DomUtility =\n\n    /// The current DOM Document.\n    let Doc = JS.Document\n\n    /// Appends a child node to the given DOM element.\n    [<MethodImpl(MethodImplOptions.NoInlining)>]\n    let AppendTo (ctx: Element) node =\n        ctx.AppendChild(node) |> ignore\n\n    /// Removes all attributes from the given DOM element.\n    let ClearAttrs (ctx: Element) =\n        while ctx.HasAttributes() do\n            ctx.RemoveAttributeNode(ctx.Attributes.[0] :?> _) |> ignore\n\n    /// Removes all child nodes from the given DOM element.\n    let Clear (ctx: Element) =\n        while ctx.HasChildNodes() do\n            ctx.RemoveChild(ctx.FirstChild) |> ignore\n\n    /// Creates a new DOM element.\n    [<MethodImpl(MethodImplOptions.NoInlining)>]\n    let CreateElement (name: string) =\n        Doc.CreateElement name\n\n    /// Creates an element in the SVG namespace.\n    [<MethodImpl(MethodImplOptions.NoInlining)>]\n    let CreateSvgElement (name: string) =\n        Doc.CreateElementNS(\"http://www.w3.org/2000/svg\", name)\n\n    /// Creates a new DOM text node with the given value.\n    [<MethodImpl(MethodImplOptions.NoInlining)>]\n    let CreateText s =\n        Doc.CreateTextNode(s)\n\n    /// Creates a new DOM attribute.\n    let CreateAttr name value =\n        let a = Doc.CreateAttribute(name)\n        a.Value <- value\n        a\n\n    /// Removes a DOM attribute.\n    let RemoveAttr (el: Element) (attrName: string) =\n        el.RemoveAttribute attrName\n\n    /// Sets the value of the attribute given by\n    /// `name` to `value` in element `el`.\n    let SetAttr (el: Element) name value =\n        el.SetAttribute(name, value)\n\n    [<Direct \"$target.setProperty($name, $value)\">]\n    let private SetProperty (target: obj) (name: string) (value: string) = ()\n\n    /// Sets a style property.\n    let SetStyle (el: Element) name value =\n        SetProperty el?style name value\n\n    /// Safe remove of a node\n    let RemoveNode (parent: Element) (el: Node) =\n        // make sure not to remove already removed nodes\n        if Object.ReferenceEquals(el.ParentNode, parent) then\n            parent.RemoveChild(el) |> ignore\n\n    /// Position in a `children` list of a DOM Element\n    /// where a node can be inserted.\n    [<AllowNullLiteral>]\n    type InsertPos [<Inline \"$x\">] private (x: Node) =\n        [<Inline>]\n        static member AtEnd = null : InsertPos\n        [<Inline>]\n        static member BeforeNode n = InsertPos n\n    [<Inline>]\n    let AtEnd = InsertPos.AtEnd\n    [<Inline>]\n    let BeforeNode n = InsertPos.BeforeNode n\n\n    /// Inserts a new child node into the tree under\n    /// a given `parent` at given `pos`.\n    let InsertAt (parent: Element) (pos: InsertPos) (node: Node) =\n        let currentPos (node: Node) =\n            match node.NextSibling with\n            | null -> AtEnd\n            | s -> BeforeNode s\n        let canSkip =\n            node.ParentNode ===. parent\n            && pos ===. currentPos node\n        if not canSkip then\n            parent.InsertBefore(node, As pos) |> ignore\n\n    /// Adds a class.\n    let AddClass (element: Element) (cl: string) =\n        JQuery.Of(element).AddClass(cl) |> ignore\n\n    /// Removes a class.\n    let RemoveClass (element: Element) (cl: string) =\n        JQuery.Of(element).RemoveClass(cl) |> ignore\n\n    /// Retrieve the children of an element as an array.\n    let ChildrenArray (element: Element) : Dom.Node[] =\n        let a = [||]\n        for i = 0 to element.ChildNodes.Length - 1 do\n            a.JS.Push(element.ChildNodes.[i]) |> ignore\n        a\n\n    /// Iterate through a NodeList assuming it's all Elements.\n    let IterSelector (el: Element) (selector: string) (f: Element -> unit) =\n        let l = el.QuerySelectorAll(selector)\n        for i = 0 to l.Length - 1 do f (l.[i] :?> Element)\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2014 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\nnamespace WebSharper.UI.Next\nopen WebSharper\n\nopen System.Collections.Generic\nmodule M = Map\n\n/// Trie lookup structure.\ntype Trie<'K,'V when 'K : comparison> =\n    | TrieBranch of Map<'K,Trie<'K,'V>> // invariant: not empty\n    | TrieEmpty\n    | TrieLeaf of 'V\n\n/// Trie combinators.\n[<JavaScript>]\nmodule Trie =\n\n    /// Branch trie, maintaining invariant.\n    let TrieBranch xs =\n        if M.isEmpty xs then TrieEmpty else TrieBranch xs\n\n    /// Singleton trie.\n    let Leaf v =\n        TrieLeaf v\n\n    /// Prefix a trie - becomes a branch.\n    let Prefix key trie =\n        TrieBranch (Map [key, trie])\n\n    /// Finds a value in a multi-map.\n    [<MethodImpl(MethodImplOptions.NoInlining)>]\n    let MultiFind key map =\n        defaultArg (M.tryFind key map) []\n\n    /// Adds a value to a multi-map.\n    let MultiAdd key value map =\n        Map.add key (value :: MultiFind key map) map\n\n    /// Makes sure all results are Some.\n    let AllSome (xs: seq<option<'T>>) =\n        let e = xs.GetEnumerator()\n        let r = ResizeArray()\n        let mutable ok = true\n        while ok && e.MoveNext() do\n            match e.Current with\n            | None -> ok <- false\n            | Some x -> r.Add(x)\n        if ok then Some (r.ToArray() :> seq<_>) else None\n\n    /// Merges multiple maps into one given a merge function on values.\n    let MergeMaps merge maps =\n        Seq.collect M.toSeq maps\n        |> Seq.fold (fun s (k, v) -> MultiAdd k v s) M.empty\n        |> M.toSeq\n        |> Seq.map (fun (k, vs) -> merge vs |> Option.map (fun v -> (k, v)))\n        |> AllSome\n        |> Option.map Map.ofSeq\n\n    /// Checks for leaves.\n    [<MethodImpl(MethodImplOptions.NoInlining)>]\n    let IsLeaf t =\n        match t with\n        | TrieLeaf _ -> true\n        | _ -> false\n\n    /// Merges tries.\n    let rec Merge (ts: seq<_>) =\n        let ts = Array.ofSeqNonCopying ts\n        match ts.Length with\n        | 0 -> Some TrieEmpty\n        | 1 -> Some ts.[0]\n        | _ ->\n            // leaves do not merge\n            if Array.exists IsLeaf ts then None else\n                ts\n                |> Seq.choose (function\n                    | TrieBranch map -> Some map\n                    | _ -> None)\n                |> MergeMaps Merge\n                |> Option.map TrieBranch\n\n    /// Inner loop for Map function.\n    let rec MapLoop loc f trie =\n        match trie with\n        | TrieBranch mp ->\n            mp\n            |> M.map (fun k v -> MapLoop (loc @ [k]) f v)\n            |> TrieBranch\n        | TrieEmpty -> TrieEmpty\n        | TrieLeaf x -> TrieLeaf (f loc x)\n\n    /// Maps a function.\n    let Map f trie =\n        MapLoop [] f trie\n\n    /// Map with a counter.\n    let Mapi f trie =\n        let counter = ref 0\n        let next () =\n            let c = !counter\n            counter := c + 1\n            c\n        Map (fun x -> f (next ()) x) trie\n\n    /// Collects all values.\n    let ToArray trie =\n        // TODO: more efficient than this.\n        let all = Queue()\n        Map (fun _ v -> all.Enqueue v) trie\n        |> ignore\n        all.ToArray()\n\n    /// Result of lookup function.\n    type LookupResult<'K,'V> =\n        | Found of value: 'V * remainder: list<'K>\n        | NotFound\n\n    /// Lookup main loop.\n    let rec Look key trie =\n        match trie, key with\n        | TrieLeaf v, _ -> Found (v, key)\n        | TrieBranch map, k :: ks ->\n            match M.tryFind k map with\n            | Some trie -> Look ks trie\n            | None -> NotFound\n        | _ -> NotFound\n\n    /// Looks up a value in the trie.\n    let Lookup trie key =\n        Look (Seq.toList key) trie\n\n    /// Empty trie.\n    let Empty<'K,'V when 'K : comparison> : Trie<'K,'V> =\n        TrieEmpty\n\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2014 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\nnamespace WebSharper.UI.Next\n\nopen System.Collections.Generic\nopen WebSharper\nopen WebSharper.JavaScript\n\n(*\n\nSnap implements a snapshot of a time-varying value.\n\nFinal states:\n\n    Forever     -- will never be obsolete\n    Obsolete    -- is obsolete\n\nDistinguishing Forever state is important as it avoids a class of\nmemory leaks connected with waiting on a Snap to become obsolete\nwhen it will never do so.\n\nState transitions:\n\n    Waiting         -> Forever      // MarkForever\n    Waiting         -> Obsolete     // MarkObsolete\n    Waiting         -> Ready        // MarkReady\n    Ready           -> Obsolete     // MarkObsolete\n\n*)\n\n[<JavaScript false>]\ntype ISnap =\n    abstract Obsolete : unit -> unit\n    abstract IsNotObsolete : unit -> bool\n\ntype OnObsoleted = Union<ISnap, unit -> unit>\n\n[<JavaScript>]\ntype SnapState<'T> =\n    | Forever of 'T\n    | [<Constant null>] Obsolete\n    | Ready of 'T * Queue<OnObsoleted>\n    | Waiting of Queue<'T -> unit> * Queue<OnObsoleted>\n\n[<JavaScript; AutoOpen>]\nmodule SnapInternals =\n\n    [<Inline \"typeof $o == 'object' ? $doObs($o) : $o()\">]\n    let obs (o: OnObsoleted) doObs =  \n        match o with\n        | Union1Of2 sn -> doObs sn\n        | Union2Of2 f -> f()\n\n    [<Inline \"typeof $o == 'object' ? $doObs($o) : $doFunc($o)\">]\n    let clean (o: OnObsoleted) doObs doFunc =  \n        match o with\n        | Union1Of2 sn -> doObs sn\n        | Union2Of2 f -> doFunc f\n\ntype Snap<'T> =\n    {\n        [<Name \"s\">] mutable State : SnapState<'T>\n    }\n\n    [<JavaScript>]\n    static member Obsolete(sn: Snap<'T>) =\n        match sn.State with\n        | Forever _ | Obsolete -> ()\n        | Ready (_, q) | Waiting (_, q) ->\n            sn.State <- Obsolete\n            let qa = Queue.ToArray q\n            for i = 0 to qa.Length - 1 do \n                obs qa.[i] (fun sn -> sn.Obsolete())\n\n    interface ISnap with\n        member this.Obsolete() =\n            Snap.Obsolete(this)\n\n        member this.IsNotObsolete() =\n            match this.State with\n            | Obsolete -> false\n            | _ -> true\n\n[<Proxy(typeof<ISnap>)>]\ntype internal ISnapProxy =\n    [<Inline>]\n    member this.Obsolete() =\n        Snap.Obsolete(As<Snap<obj>> this)\n\n    [<Inline \"$this.s\">]\n    member this.IsNotObsolete() = X<bool>\n\n[<JavaScript>]\nmodule Snap =\n\n  // constructors\n\n    [<Inline>]\n    let Make st = { State = st }\n\n    [<Inline>]\n    let Create () = Make (Waiting (Queue(), Queue()))\n\n    [<Inline>]\n    let CreateForever v = Make (Forever v)\n\n    [<Inline>]\n    let CreateWithValue v = Make (Ready (v, Queue()))\n\n  // misc\n\n    [<Inline>]\n    let IsForever snap =\n        match snap.State with\n        | Forever _ -> true\n        | _ -> false\n\n    [<Inline>]\n    let IsObsolete snap =\n        match snap.State with\n        | Obsolete -> true\n        | _ -> false\n\n    [<Inline>]\n    let IsDone snap =\n        match snap.State with\n        | Forever _ | Ready _ -> true\n        | _ -> false\n\n  // transitions\n\n    let MarkForever sn v =\n        match sn.State with\n        | Waiting (q, _) ->\n            sn.State <- Forever v\n            let qa = Queue.ToArray q\n            for i = 0 to qa.Length - 1 do \n                qa.[i] v\n        | _ -> ()\n\n    [<Inline>]\n    let MarkObsolete (sn: Snap<_>) =\n        (sn :> ISnap).Obsolete()\n\n    let MarkReady sn v =\n        match sn.State with\n        | Waiting (q1, q2) ->\n            sn.State <- Ready (v, q2)\n            let qa = Queue.ToArray q1\n            for i = 0 to qa.Length - 1 do \n                qa.[i] v\n        | _ -> ()\n\n    let MarkDone res sn v =\n        if IsForever sn then\n            MarkForever res v\n        else\n            MarkReady res v\n\n    let EnqueueSafe (q: Queue<_>) x =\n        q.Enqueue x\n        if q.Count % 20 = 0 then\n            let qcopy = q.ToArray()\n            q.Clear()\n            for i = 0 to qcopy.Length - 1 do\n                clean qcopy.[i]\n                    (fun sn -> if sn.IsNotObsolete() then q.Enqueue (Union1Of2 sn))\n                    (fun f -> q.Enqueue (Union2Of2 f)) \n\n  // eliminators\n\n    let When snap avail (obs: ISnap) =\n        match snap.State with\n        | Forever v -> avail v\n        | Obsolete -> obs.Obsolete()\n        | Ready (v, q1) -> EnqueueSafe q1 (Union1Of2 obs); avail v\n        | Waiting (q1, q2) -> q1.Enqueue avail; EnqueueSafe q2 (Union1Of2 obs)\n\n    let WhenRun snap avail obs =\n        match snap.State with\n        | Forever v -> avail v\n        | Obsolete -> obs()\n        | Ready (v, q1) -> q1.Enqueue (Union2Of2 obs); avail v\n        | Waiting (q1, q2) -> q1.Enqueue avail; q2.Enqueue (Union2Of2 obs)\n\n    let WhenReady snap avail =\n        match snap.State with\n        | Forever v\n        | Ready (v, _) -> avail v\n        | Obsolete -> ()\n        | Waiting (q1, _) -> q1.Enqueue avail\n\n    let WhenObsolete snap (obs: ISnap) =\n        match snap.State with\n        | Forever v -> ()\n        | Obsolete -> obs.Obsolete()\n        | Ready (v, q) -> EnqueueSafe q (Union1Of2 obs)\n        | Waiting (q1, q2) -> EnqueueSafe q2 (Union1Of2 obs)\n\n    let WhenObsoleteRun snap obs =\n        match snap.State with\n        | Forever v -> ()\n        | Obsolete -> obs()\n        | Ready (v, q) -> q.Enqueue (Union2Of2 obs)\n        | Waiting (q1, q2) -> q2.Enqueue (Union2Of2 obs)\n\n    let ValueAndForever snap =\n        match snap.State with\n        | Forever v -> Some (v, true)\n        | Ready (v, _) -> Some (v, false)\n        | _ -> None\n\n  // combinators\n\n    let Join snap =\n        let res = Create ()\n        let onReady x =\n            let y = x ()\n            When y (fun v ->\n                if IsForever y && IsForever snap then\n                    MarkForever res v\n                else\n                    MarkReady res v) res\n        When snap onReady res\n        res\n\n    let JoinInner snap =\n        let res = Create ()\n        let onReady x =\n            let y = x ()\n            When y (fun v ->\n                if IsForever y && IsForever snap then\n                    MarkForever res v\n                else\n                    MarkReady res v) res\n            WhenObsolete snap y\n        When snap onReady res\n        res\n\n    let CreateForeverAsync a =\n        let o = Make (Waiting (Queue(), Queue()))\n        Async.StartTo a (MarkForever o)\n        o\n\n    let Sequence (snaps : seq<Snap<'T>>) =\n        let snaps = Array.ofSeq snaps\n        if Array.isEmpty snaps then CreateForever Seq.empty\n        else\n            let res = Create () : Snap<seq<'T>>\n            let w = ref (snaps.Length - 1)\n            let cont _ =\n                if !w = 0 then\n                    // all source snaps should have a value\n                    let vs = \n                        snaps |> Array.map (fun s -> \n                            match s.State with\n                            | Forever v | Ready (v, _) -> v\n                            | _ -> failwith \"value not found by View.Sequence\")\n                    if Array.forall IsForever snaps then\n                        MarkForever res (vs :> seq<_>)\n                    else\n                        MarkReady res (vs :> seq<_>)\n                else\n                    decr w\n            snaps\n            |> Array.iter (fun s -> When s cont res)\n            res\n\n    let Map fn sn =\n        match sn.State with\n        | Forever x -> CreateForever (fn x) // optimization\n        | _ ->\n            let res = Create ()\n            When sn (fun a -> MarkDone res sn (fn a)) res\n            res\n\n    let Copy sn =\n        match sn.State with\n        | Forever _ \n        | Obsolete -> sn // optimization\n        | Ready (v, _) ->\n            let res = CreateWithValue v\n            WhenObsolete sn res\n            res\n        | Waiting _ ->\n            let res = Create ()\n            When sn (MarkDone res sn) res\n            res\n\n    let MapCachedBy eq prev fn sn =\n        let fn x =\n            match !prev with\n            | Some (x', y) when eq x x' -> y\n            | _ ->\n                let y = fn x\n                prev := Some (x, y)\n                y\n        Map fn sn\n\n    let Map2Opt1 fn x sn2 = Map (fun y -> fn x y) sn2\n    let Map2Opt2 fn y sn1 = Map (fun x -> fn x y) sn1\n    let Map2 fn sn1 sn2 =\n        match sn1.State, sn2.State with\n        | Forever x, Forever y -> CreateForever (fn x y) // optimization\n        | Forever x, _ -> Map2Opt1 fn x sn2 // optimize for known sn1\n        | _, Forever y -> Map2Opt2 fn y sn1 // optimize for known s2\n        | _ ->\n            let res = Create ()\n            let cont _ =\n                if not (IsDone res) then \n                    match ValueAndForever sn1, ValueAndForever sn2 with\n                    | Some (x, f1), Some (y, f2) ->\n                        if f1 && f2 then\n                            MarkForever res (fn x y)\n                        else\n                            MarkReady res (fn x y) \n                    | _ -> ()\n            When sn1 cont res\n            When sn2 cont res\n            res\n\n    let Map2Unit sn1 sn2 =\n        match sn1.State, sn2.State with\n        | Forever (), Forever () -> CreateForever () // optimization\n        | Forever (), _ -> sn2 // optimize for known sn1\n        | _, Forever () -> sn1 // optimize for known s2\n        | _ ->\n            let res = Create ()\n            let cont () =\n                if not (IsDone res) then \n                    match ValueAndForever sn1, ValueAndForever sn2 with\n                    | Some (_, f1), Some (_, f2) ->\n                        if f1 && f2 then\n                            MarkForever res ()\n                        else\n                            MarkReady res () \n                    | _ -> ()\n            When sn1 cont res\n            When sn2 cont res\n            res\n\n    let Map3Opt1 fn x y sn3   = Map (fun z -> fn x y z) sn3\n    let Map3Opt2 fn x z sn2   = Map (fun y -> fn x y z) sn2\n    let Map3Opt3 fn x sn2 sn3 = Map2 (fun y z -> fn x y z) sn2 sn3\n    let Map3Opt4 fn y z sn1   = Map (fun x -> fn x y z) sn1\n    let Map3Opt5 fn y sn1 sn3 = Map2 (fun x z -> fn x y z) sn1 sn3\n    let Map3Opt6 fn z sn1 sn2 = Map2 (fun x y -> fn x y z) sn1 sn2\n    let Map3 fn sn1 sn2 sn3 =\n        match sn1.State, sn2.State, sn3.State with\n        | Forever x, Forever y, Forever z -> CreateForever (fn x y z)\n        | Forever x, Forever y, _         -> Map3Opt1 fn x y sn3  \n        | Forever x, _,         Forever z -> Map3Opt2 fn x z sn2  \n        | Forever x, _,         _         -> Map3Opt3 fn x sn2 sn3\n        | _,         Forever y, Forever z -> Map3Opt4 fn y z sn1  \n        | _,         Forever y, _         -> Map3Opt5 fn y sn1 sn3\n        | _,         _,         Forever z -> Map3Opt6 fn z sn1 sn2    \n        | _,         _,         _         ->\n            let res = Create ()\n            let cont _ =\n                if not (IsDone res) then \n                    match ValueAndForever sn1, ValueAndForever sn2, ValueAndForever sn3 with\n                    | Some (x, f1), Some (y, f2), Some (z, f3) ->\n                        if f1 && f2 && f3 then\n                            MarkForever res (fn x y z)\n                        else\n                            MarkReady res (fn x y z) \n                    | _ -> ()\n            When sn1 cont res\n            When sn2 cont res\n            When sn3 cont res\n            res\n\n    let SnapshotOn sn1 sn2 =\n        let res = Create ()\n        let cont _ =\n            if not (IsDone res) then \n                match ValueAndForever sn1, ValueAndForever sn2 with\n                | Some (_, f1), Some (y, f2) ->\n                    if f1 || f2 then\n                        MarkForever res y \n                    else\n                        MarkReady res y\n                | _ -> ()\n        When sn1 cont res\n        WhenReady sn2 cont\n        res\n\n    let MapAsync fn snap =\n        let res = Create ()\n        When snap\n            (fun v -> Async.StartTo (fn v) (MarkDone res snap))\n            res\n        res\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2014 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\nnamespace WebSharper.UI.Next\n\n#nowarn \"40\" // AsyncAwait let rec\n\nopen WebSharper\n\n[<JavaScript>]\ntype IRef<'T> =\n    [<Name \"RGet\">]\n    abstract Get : unit -> 'T\n    [<Name \"RSet\">]\n    abstract Set : 'T -> unit\n    [<Name \"RVal\">]\n    abstract Value : 'T with get, set\n    [<Name \"RUpd\">]\n    abstract Update : ('T -> 'T) -> unit\n    [<Name \"RUpdM\">]\n    abstract UpdateMaybe : ('T -> 'T option) -> unit\n    [<Name \"RView\">]\n    abstract View : View<'T>\n    [<Name \"RId\">]\n    abstract Id : string\n\nand [<JavaScript>] View<'T> =\n    | V of (unit -> Snap<'T>)\n\n[<AutoOpen>]\nmodule ViewOptimization =\n    open WebSharper.JavaScript\n    [<Inline \"$x\">]\n    let V (x: unit -> Snap<'T>) = V x\n    [<Inline \"$x\">]\n    let (|V|) (x: View<'T>) = let (V v) = x in v\n    [<Inline \"$x\">]\n    let getSnapV (x: Snap<View<'T>>) = Snap.Map (|V|) x\n    [<Inline \"$x\">]\n    let getSnapF (x: 'A -> View<'T>) = x >> (|V|)\n    [<Inline \"null\">]\n    let jsNull<'T>() = Unchecked.defaultof<'T>\n    [<Inline \"Error().stack\">]\n    let jsStack<'T>() = \"\"\n    \n/// Var either holds a Snap or is in Const state.\n[<JavaScript>]\ntype Var<'T> =\n    {\n        [<Name \"o\">] mutable Const : bool\n        [<Name \"c\">] mutable Current : 'T\n        [<Name \"s\">] mutable Snap : Snap<'T>\n        [<Name \"i\">] Id : int\n        [<Name \"v\">] VarView : View<'T>\n    }\n\n    [<Inline>]\n    member this.View = this.VarView\n\n    interface IRef<'T> with\n        member this.Get() = Var.Get this\n        member this.Set v = Var.Set this v\n        member this.Value\n            with get() = Var.Get this\n            and set v = Var.Set this v\n        member this.Update f = Var.Update this f\n        member this.UpdateMaybe f =\n            match f (Var.Get this) with\n            | None -> ()\n            | Some v -> Var.Set this v\n        member this.View = this.View\n        member this.Id = \"uinref\" + string (Var.GetId this)\n\nand [<JavaScript; Sealed>] Var =\n\n    [<MethodImpl(MethodImplOptions.NoInlining)>]\n    static member Create v =\n        let mutable var = jsNull()\n        var <-\n            {\n                Const = false\n                Current = v\n                Snap = Snap.CreateWithValue v\n                Id = Fresh.Int ()\n                VarView = V (fun () -> var.Snap)\n            }\n        var\n\n    static member CreateLogged (name: string) v =\n        if not (WebSharper.JavaScript.JS.Global?UINVars) then\n            WebSharper.JavaScript.JS.Global?UINVars <- [||]\n        let res = Var.Create v\n        WebSharper.JavaScript.JS.Global?UINVars?push([| name; WebSharper.JavaScript.Pervasives.As res |])\n        res\n\n    static member Create() =\n        let mutable var = jsNull()\n        var <-\n            {\n                Const = false\n                Current = ()\n                Snap = Snap.CreateWithValue ()\n                Id = Fresh.Int ()\n                VarView = V (fun () -> var.Snap)\n            }\n        var\n\n    [<Inline>]\n    static member Get var =\n        var.Current\n\n    static member Set var value =\n        if var.Const then\n            printfn \"WebSharper UI.Next: invalid attempt to change value of a Var after calling SetFinal\"\n        else\n            Snap.MarkObsolete var.Snap\n            var.Current <- value\n            var.Snap <- Snap.CreateWithValue value\n\n    static member SetFinal var value =\n        if var.Const then\n            printfn \"WebSharper UI.Next: invalid attempt to change value of a Var after calling SetFinal\"\n        else\n            Snap.MarkObsolete var.Snap\n            var.Const <- true\n            var.Current <- value\n            var.Snap <- Snap.CreateForever value\n\n    static member Update var fn =\n        Var.Set var (fn (Var.Get var))\n\n    [<Inline>]\n    static member GetId var =\n        var.Id\n\n    [<Inline>]\n    static member Observe var =\n        var.Snap\n\ntype [<JavaScript>] Updates = \n    {\n        [<Name \"c\">] mutable Current : View<unit>\n        [<Name \"s\">] mutable Snap : Snap<unit>\n        [<Name \"v\">] VarView : View<unit>\n    }\n\n    [<Inline>]\n    member this.View = this.VarView\n\n    static member Create v =\n        let mutable var = jsNull()\n        var <-\n            {\n                Current = v\n                Snap = jsNull()\n                VarView = \n                    let obs () =\n                        let mutable c = var.Snap\n                        if obj.ReferenceEquals(c, null) then\n                            let (V observe) = var.Current\n                            c <- observe() |> Snap.Copy\n                            var.Snap <- c\n                            Snap.WhenObsoleteRun c (fun () -> \n                                var.Snap <- jsNull())\n                            c\n                        else c\n                    \n                    V obs\n            }\n        var\n\n    member this.Value\n        with [<Inline>] get() = this.Current\n        and set v =\n            let sn = this.Snap\n            if not (obj.ReferenceEquals(sn, null)) then\n                Snap.MarkObsolete sn\n            this.Current <- v\n\ntype ViewNode<'A,'B> =\n    {\n        [<Name \"e\">] NValue : 'B\n        [<Name \"r\">] NVar : Var<'A>\n        [<Name \"w\">] NView : View<'A>\n    }\n\ntype LazyView<'T> =\n    {\n        [<Name \"c\">] mutable Current : Snap<'T>\n        [<Name \"o\">] mutable Observe : unit -> Snap<'T>  \n    } \n\n[<JavaScript>]\n[<Sealed>]\ntype View =\n\n    [<Inline>]\n    static member FromVar (var: Var<'T>) =\n        var.View\n\n    static member CreateLazy observe =\n        let lv =\n            {\n                Current = jsNull()\n                Observe = observe \n            }\n        let obs () =\n            let mutable c = lv.Current\n            if obj.ReferenceEquals(c, null) then\n                c <- lv.Observe()\n                lv.Current <- c\n                if Snap.IsForever c then \n                    lv.Observe <- jsNull()\n                else\n                    Snap.WhenObsoleteRun c (fun () -> \n                        lv.Current <- jsNull()) \n                c\n            else c\n        V obs\n\n    static member Map fn (V observe) =\n        View.CreateLazy (fun () ->\n            observe () |> Snap.Map fn)\n\n    static member MapCachedBy eq fn (V observe) =\n        let vref = ref None\n        View.CreateLazy (fun () ->\n            observe () |> Snap.MapCachedBy eq vref fn)\n\n    static member MapCached fn v =\n        View.MapCachedBy (=) fn v\n\n    static member Map2 fn (V o1) (V o2) =\n        View.CreateLazy (fun () ->\n            let s1 = o1 ()\n            let s2 = o2 ()\n            Snap.Map2 fn s1 s2)\n\n    static member Map2Unit (V o1) (V o2) =\n        View.CreateLazy (fun () ->\n            let s1 = o1 ()\n            let s2 = o2 ()\n            Snap.Map2Unit s1 s2)\n\n    static member Map3 fn (V o1) (V o2) (V o3) =\n        View.CreateLazy (fun () ->\n            let s1 = o1 ()\n            let s2 = o2 ()\n            let s3 = o3 ()\n            Snap.Map3 fn s1 s2 s3)\n\n    static member MapAsync fn (V observe) =\n        View.CreateLazy (fun () -> observe () |> Snap.MapAsync fn)\n\n    static member MapAsync2 fn v1 v2 =\n        View.Map2 fn v1 v2 |> View.MapAsync id\n\n    static member Get (f: 'T -> unit) (V observe) =\n        let ok = ref false\n        let rec obs () =\n            Snap.WhenRun (observe ())\n                (fun v ->\n                    if not !ok then\n                        ok := true\n                        f v)\n                (fun () -> if not !ok then obs ())\n        obs ()\n\n    static member GetAsync v =\n        Async.FromContinuations (fun (ok, _, _) -> View.Get ok v)\n\n    static member SnapshotOn def (V o1) (V o2) =\n        let sInit = Snap.CreateWithValue def\n\n        let obs () =\n            let s1 = o1 ()\n            if Snap.IsObsolete sInit then\n                let s2 = o2 ()\n                Snap.SnapshotOn s1 s2\n            else\n                Snap.WhenObsolete s1 sInit\n                sInit\n\n        View.CreateLazy obs\n\n     // Collections --------------------------------------------------------------\n\n    static member MapSeqCachedBy<'A,'B,'K,'SeqA when 'K : equality and 'SeqA :> seq<'A>>\n            (key: 'A -> 'K) (conv: 'A -> 'B) (view: View<'SeqA>) =\n        // Save history only for t - 1, discard older history.\n        let state = ref (Dictionary())\n        view\n        |> View.Map (fun xs ->\n            let prevState = !state\n            let newState = Dictionary()\n            let result =\n                Seq.toArray xs\n                |> Array.mapInPlace (fun x ->\n                    let k = key x\n                    let res =\n                        if prevState.ContainsKey k\n                            then prevState.[k]\n                            else conv x\n                    newState.[k] <- res\n                    res)\n                :> seq<_>\n            state := newState\n            result)\n\n    static member MapSeqCached conv view =\n        View.MapSeqCachedBy (fun x -> x) conv view\n\n    static member ConvertSeqNode conv value =\n        let var = Var.Create value\n        let view = View.FromVar var\n        {\n            NValue = conv view\n            NVar = var\n            NView = view\n        }\n\n    static member MapSeqCachedViewBy<'A,'B,'K,'SeqA when 'K : equality and 'SeqA :> seq<'A>>\n            (key: 'A -> 'K) (conv: 'K -> View<'A> -> 'B) (view: View<'SeqA>) =\n        // Save history only for t - 1, discard older history.\n        let state = ref (Dictionary())\n        view\n        |> View.Map (fun xs ->\n            let prevState = !state\n            let newState = Dictionary()\n            let result =\n                Seq.toArray xs\n                |> Array.mapInPlace (fun x ->\n                    let k = key x\n                    let node =\n                        if prevState.ContainsKey k then\n                            let n = prevState.[k]\n                            Var.Set n.NVar x\n                            n\n                        else\n                            View.ConvertSeqNode (fun v -> conv k v) x\n                    newState.[k] <- node\n                    node.NValue)\n                :> seq<_>\n            state := newState\n            result)\n\n    static member MapSeqCachedView conv view =\n        View.MapSeqCachedViewBy (fun x -> x) (fun _ v -> conv v) view\n\n    [<Inline>]\n    static member Convert<'A, 'B when 'A : equality> (f: 'A -> 'B) v =\n        View.MapSeqCached f v\n\n    [<Inline>]\n    static member ConvertBy<'A, 'B, 'K when 'K : equality> (k: 'A -> 'K) (f: 'A -> 'B) v =\n        View.MapSeqCachedBy k f v\n\n    [<Inline>]\n    static member ConvertSeq<'A, 'B when 'A : equality> (f: View<'A> -> 'B) v =\n        View.MapSeqCachedView f v\n\n    [<Inline>]\n    static member ConvertSeqBy<'A, 'B, 'K when 'K : equality> (k: 'A -> 'K) (f: 'K -> View<'A> -> 'B) v =\n        View.MapSeqCachedViewBy k f v\n\n  // More cominators ------------------------------------------------------------\n\n    static member Join (V observe : View<View<'T>>) : View<'T> =\n        View.CreateLazy (fun () ->\n            Snap.Join (getSnapV (observe ())))\n\n    static member Bind (fn: 'A -> View<'B>) view =\n        View.Join (View.Map fn view)\n\n    static member JoinInner (V observe : View<View<'T>>) : View<'T> =\n        View.CreateLazy (fun () ->\n            Snap.JoinInner (getSnapV (observe ())))\n\n    static member BindInner fn view =\n        View.JoinInner (View.Map fn view)\n\n    static member UpdateWhile def v1 v2 =\n        let value = ref def\n        View.BindInner (fun pred ->\n            if pred then\n                View.Map (fun v ->\n                    value := v\n                    v\n                ) v2   \n            else View.Const (!value) \n        ) v1\n\n    static member Sequence views =\n        View.CreateLazy(fun () ->\n            views\n            |> Seq.map (fun (V observe) -> observe ())\n            |> Snap.Sequence)\n\n    static member Const x =\n        let o = Snap.CreateForever x\n        V (fun () -> o)\n\n    static member ConstAsync a =\n        let o = Snap.CreateForeverAsync a\n        V (fun () -> o)\n\n    static member TryWith (f: exn -> View<'T>) (V observe: View<'T>) : View<'T> =\n        View.CreateLazy (fun () ->\n            try\n                observe ()\n            with exn ->\n                let (V obs) = f exn\n                obs ()\n        )\n\n    static member TryFinally (f: unit -> unit) (V observe: View<'T>) : View<'T> =\n        View.CreateLazy (fun () ->\n            try\n                observe ()\n            finally\n                f ()\n        )\n\n    static member Sink act (V observe) =\n        let rec loop () =\n            let sn = observe ()\n            Snap.WhenRun sn act (fun () ->\n                Async.Schedule loop)\n        Async.Schedule loop\n\n    static member RemovableSink act (V observe) =\n        let cont = ref true\n        let rec loop () =\n            let sn = observe ()\n            Snap.WhenRun sn\n                (fun x -> if !cont then act x)\n                (fun () -> if !cont then Async.Schedule loop)\n        Async.Schedule loop\n        fun () -> cont := false\n\n    static member AsyncAwait filter view =\n        Async.FromContinuations <| fun (ok, _, _) ->\n            let rec remove =\n                View.RemovableSink (fun value ->\n                    if filter value then\n                        remove ()\n                        ok value\n                ) view\n            ()\n\n    static member Apply fn view =\n        View.Map2 (fun f x -> f x) fn view\n\ntype Var with\n\n    [<JavaScript>]\n    static member Lens (iref: IRef<_>) get update =\n        let id = Fresh.Id()\n        let view = iref.View |> View.Map get\n\n        { new IRef<'V> with\n\n            member this.Get() =\n                get (iref.Get())\n\n            member this.Set(v) =\n                iref.Update(fun t -> update t v)\n\n            member this.Value\n                with get () = get (iref.Get())\n                and set v = iref.Update(fun t -> update t v)\n\n            member this.Update(f) =\n                iref.Update(fun t -> update t (f (get t)))\n\n            member this.UpdateMaybe(f) =\n                iref.UpdateMaybe(fun t -> Option.map (fun x -> update t x) (f (get t)))\n\n            member this.View =\n                view\n\n            member this.Id =\n                id\n        }\n\ntype Var<'T> with\n\n    [<JavaScript>]\n    member v.Value\n        with [<Inline; Name \"get_VarValue\">] get () = Var.Get v\n        and [<Inline; Name \"set_VarValue\">] set value = Var.Set v value\n\n// These methods apply to any View<'A>, so we can use `type View with`\n// and they'll be compiled as normal instance methods on View<'A>.\ntype View<'A> with\n\n    [<JavaScript; Inline>]\n    member v.Map f = View.Map f v\n\n    //[<JavaScript; Inline>]\n    //member v.Map (f: System.Func<_, 'B>) =\n    //    View.Map (FSharpConvert.Fun f) v\n\n    [<JavaScript; Inline>]\n    member v.MapAsync f = View.MapAsync f v\n\n    //member v.MapAsync (f: System.Func<_, System.Threading.Tasks.Task<'B>>) =\n    //    v |> View.MapAsync (fun a ->\n    //        async {\n    //            let! res = f.Invoke(a) |> Async.AwaitTask\n    //            return res\n    //        })\n\n    [<JavaScript; Inline>]\n    member v.Bind f = View.Bind f v\n\n    [<JavaScript; Inline>]\n    member v.BindInner f = View.BindInner f v\n\n    //[<JavaScript; Inline>]\n    //member v.Bind (f: System.Func<_, View<'B>>) =\n    //    View.Bind (FSharpConvert.Fun f) v\n\n    [<JavaScript; Inline>]\n    member v.SnapshotOn init v' = View.SnapshotOn init v' v\n\n    [<JavaScript; Inline>]\n    member v.UpdateWhile init vPred = View.UpdateWhile init vPred v\n\n[<AutoOpen>]\nmodule IRefExtension =\n\n    type IRef<'T> with\n\n        [<JavaScript; Inline>]\n        member iref.Lens get update =\n            Var.Lens iref get update\n\ntype ViewBuilder =\n    | B\n\n    [<JavaScript; Inline>]\n    member b.Bind(x, f) = View.Bind f x\n\n    [<JavaScript; Inline>]\n    member b.Return x = View.Const x\n\n    [<JavaScript; Inline>]\n    member b.ReturnFrom(v: View<'T>) = v\n\n    [<JavaScript; Inline>]\n    member b.TryWith(v, f) = View.TryWith f v\n\n    [<JavaScript; Inline>]\n    member b.TryFinally(v, f) = View.TryFinally f v\n\ntype View with\n    [<JavaScript>]\n    static member Do = B\n\n[<Sealed; JavaScript>]\ntype Submitter<'T> (input: View<'T>, init: 'T) =\n    let var = Var.Create ()\n    let view = View.SnapshotOn init var.View input\n\n    [<Inline>]\n    member this.View = view\n\n    member this.Trigger() = var.Value <- ()\n\n    [<Inline>]\n    member this.Input = input\n\n[<Sealed; JavaScript>]\ntype Submitter =\n\n    [<Inline>]\n    static member CreateDefault input =\n        Submitter<_>(input, Unchecked.defaultof<_>)\n\n    [<Inline>]\n    static member Create input init =\n        Submitter<_>(input, init)\n\n    static member CreateOption input =\n        Submitter<_>(View.Map Some input, None)\n\n    [<Inline>]\n    static member View (s: Submitter<_>) =\n        s.View\n\n    [<Inline>]\n    static member Trigger (s: Submitter<_>) =\n        s.Trigger()\n\n    [<Inline>]\n    static member Input (s: Submitter<_>) =\n        s.Input\n\n[<assembly:System.Runtime.CompilerServices.Extension>]\ndo ()\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2014 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\nnamespace WebSharper.UI.Next\nopen WebSharper\n\nopen System\n\n[<JavaScript>]\ntype Key =\n    | Key of int\n\n    static member Fresh () = Key (Fresh.Int ())\n\n[<JavaScript>]\ntype Model<'I,'M>(var: Var<'M>, view: View<'I>) =\n\n    new (proj: Func<'M, 'I>, init: 'M) =\n        let var = Var.Create init\n        let view = View.Map proj.Invoke var.View\n        Model(var, view)\n\n    [<Inline>]\n    member this.Var = var\n    [<Inline>]\n    member this.View = view\n\n[<JavaScript>]\n[<Sealed>]\ntype Model =\n\n    static member Create proj init =\n        Model(Func<_,_>(proj), init)\n\n    static member Update update (m: Model<'I, 'M>) =\n        Var.Update m.Var (fun x -> update x; x)\n\n    [<Inline>]\n    static member View (m: Model<'I, 'M>) =\n        m.View\n\ntype Storage<'T> =\n    [<Name \"SAppend\">]\n    abstract member Append : appending: 'T -> ``to``: 'T[] -> 'T[]\n    [<Name \"SAppendMany\">]\n    abstract member AppendMany : appending: seq<'T> -> ``to``: 'T[] -> 'T[]\n    [<Name \"SPrepend\">]\n    abstract member Prepend : appending: 'T -> ``to``: 'T[] -> 'T[]\n    [<Name \"SPrependMany\">]\n    abstract member PrependMany : appending: seq<'T> -> ``to``: 'T[] -> 'T[]\n    [<Name \"SInit\">]\n    abstract member Init : unit -> 'T[]\n    [<Name \"SRemoveIf\">]\n    abstract member RemoveIf : ('T -> bool) -> 'T [] -> 'T[]\n    [<Name \"SSetAt\">]\n    abstract member SetAt : int -> 'T -> 'T[] -> 'T[]\n    [<Name \"SSet\">]\n    abstract member Set : 'T seq -> 'T[]\n\ntype Serializer<'T> =\n    {\n        Encode : 'T -> obj\n        Decode : obj -> 'T\n    }\n\n[<JavaScript>]\nmodule Serializer =\n    open WebSharper\n    open WebSharper.JavaScript\n\n    let Default =\n        {\n            Encode = box\n            Decode = unbox\n        }\n\n    [<Inline>]\n    let Typed =\n        {\n            Encode = WebSharper.Json.Encode<'T>\n            Decode = WebSharper.Json.Decode<'T>\n        }\n\n[<JavaScript>]\nmodule Storage =\n    open WebSharper\n    open WebSharper.JavaScript\n    \n    type private ArrayStorage<'T>(init) =\n\n        interface Storage<'T> with\n            member x.Append i arr = arr.JS.Push i |> ignore; arr\n            member x.AppendMany is arr = arr.JS.Push (Array.ofSeqNonCopying is) |> ignore; arr\n            member x.Prepend i arr = arr.JS.Unshift i |> ignore; arr\n            member x.PrependMany is arr = arr.JS.Unshift (Array.ofSeqNonCopying is) |> ignore; arr\n            member x.Init () = init\n            member x.RemoveIf pred arr = Array.filter (fun i -> not (pred i)) arr\n            member x.SetAt idx elem arr = arr.[idx] <- elem; arr\n            member x.Set coll = Seq.toArray coll\n\n    type private LocalStorageBackend<'T>(id : string, serializer : Serializer<'T>) =\n        let storage = JS.Window.LocalStorage\n        let set (arr : 'T[]) = \n            storage.SetItem(id, arr |> Array.map serializer.Encode |> Json.Stringify)\n            arr\n        let clear () = storage.RemoveItem(id)\n\n        interface Storage<'T> with\n            member x.Append i arr = arr.JS.Push i |> ignore; set arr\n            member x.AppendMany is arr = arr.JS.Push (Array.ofSeqNonCopying is) |> ignore; set arr\n            member x.Prepend i arr = arr.JS.Unshift i |> ignore; set arr\n            member x.PrependMany is arr = arr.JS.Unshift (Array.ofSeqNonCopying is) |> ignore; set arr\n\n            member x.Init () =\n                let item = storage.GetItem(id)\n                if item = null then [||]\n                else \n                    try\n                        let arr = As<obj []> <| Json.Parse(item)\n                        arr |> Array.map serializer.Decode\n                    with _ -> [||]\n\n            member x.RemoveIf pred arr = set <| Array.filter (fun i -> not (pred i)) arr\n            member x.SetAt idx elem arr = arr.[idx] <- elem; set arr\n            member x.Set coll = set <| Seq.toArray coll\n\n    let InMemory init =\n        new ArrayStorage<_>(init) :> Storage<_>\n\n    let LocalStorage id serializer =\n        new LocalStorageBackend<_>(id, serializer) :> Storage<_>\n\ntype ListModelState<'T> =\n    [<Inline>]\n    member this.Length =\n        JavaScript.Pervasives.As<'T[]>(this).Length\n    [<Inline>]\n    member this.Item\n        with get i = JavaScript.Pervasives.As<'T[]>(this).[i]\n    [<Inline>]\n    member this.ToArray() =                             \n        Array.copy (JavaScript.Pervasives.As<'T[]>(this))\n    [<Inline>]\n    member this.ToArray(pred: Predicate<'T>) =\n        Array.filter pred.Invoke (JavaScript.Pervasives.As<'T[]>(this))\n    interface seq<'T> with\n        member this.GetEnumerator() = (JavaScript.Pervasives.As<'T[]>(this)).GetEnumerator()\n        member this.GetEnumerator() = (JavaScript.Pervasives.As<'T seq>(this)).GetEnumerator()\n\n[<JavaScript>]\ntype ListModel<'Key, 'T when 'Key : equality>\n    (\n        key : System.Func<'T, 'Key>,\n        var: IRef<'T[]>,\n        storage : Storage<'T>\n    ) =\n\n    let v = var.View.Map(fun x -> Array.copy x :> _ seq)\n           \n    let it = Dictionary<'Key, Snap<option<'T>>>()\n\n    new (key: System.Func<'T, 'Key>, init: seq<'T>) =\n        let init = Seq.toArray init\n        ListModel<'Key, 'T>(key, Var.Create init, Storage.InMemory init)\n\n    new (key: System.Func<'T, 'Key>) =\n        ListModel<'Key, 'T>(key, [||])\n\n    new (key: System.Func<'T, 'Key>, storage: Storage<'T>) =\n        let var =\n            Seq.distinctBy key.Invoke (storage.Init ())\n            |> Seq.toArray\n            |> Var.Create\n        ListModel<'Key, 'T>(key, var, storage)\n\n    [<Inline>]\n    member this.key x = key.Invoke x\n    [<Inline>]\n    member this.Var = var\n    [<Inline>]\n    member this.Storage = storage\n    [<Inline>]\n    member this.View = v\n    [<Inline>]\n    member this.ViewState = JavaScript.Pervasives.As<View<ListModelState<'T>>> var.View\n    [<Inline>]\n    member this.itemSnaps = it\n\n    interface seq<'T> with\n        member this.GetEnumerator() =\n            (Seq.ofArray var.Value).GetEnumerator()\n\n        member this.GetEnumerator() =\n            var.Value.GetEnumerator()\n\n[<JavaScript>]\nmodule ListModels =\n               \n    let Contains keyFn item xs =\n        let t = keyFn item\n        Array.exists (fun it -> keyFn it = t) xs\n\ntype ListModel<'Key,'T> with\n\n    [<Inline>]\n    member m.Key x = m.key x\n\n    [<Inline>]\n    member m.Add item =\n        m.Append item\n\n    member m.ObsoleteKey key =\n        match m.itemSnaps.TryGetValue(key) with\n        | true, sn ->\n            Snap.MarkObsolete sn \n            m.itemSnaps.Remove key |> ignore\n        | _ -> ()\n\n    member m.ObsoleteAll() =\n        m.itemSnaps |> Seq.iter (fun ksn -> Snap.MarkObsolete ksn.Value)\n        m.itemSnaps.Clear()\n\n    member m.Append item =\n        let v = m.Var.Value\n        let t = m.Key item\n        match Array.tryFindIndex (fun it -> m.Key it = t) v with\n        | None -> m.Var.Value <- m.Storage.Append item v\n        | Some index -> \n            m.Var.Value <- m.Storage.SetAt index item v\n        m.ObsoleteKey t\n\n    member m.AppendMany items =\n        let toAppend = ResizeArray()\n        let v =\n            (m.Var.Value, items)\n            ||> Seq.fold (fun v item ->\n                let t = m.Key item\n                m.ObsoleteKey t\n                match Array.tryFindIndex (fun it -> m.Key it = t) v with\n                | Some index ->\n                    m.Storage.SetAt index item v\n                | None -> toAppend.Add item; v)\n        m.Var.Value <- m.Storage.AppendMany toAppend v\n\n    member m.Prepend item =\n        let v = m.Var.Value\n        let t = m.Key item\n        match Array.tryFindIndex (fun it -> m.Key it = t) v with\n        | None -> m.Var.Value <- m.Storage.Prepend item v\n        | Some index -> \n            m.Var.Value <- m.Storage.SetAt index item v\n        m.ObsoleteKey t\n\n    member m.PrependMany items =\n        let toPrepend = ResizeArray()\n        let v =\n            (m.Var.Value, items)\n            ||> Seq.fold (fun v item ->\n                let t = m.Key item\n                m.ObsoleteKey t\n                match Array.tryFindIndex (fun it -> m.Key it = t) v with\n                | Some index -> \n                    m.Storage.SetAt index item v\n                | None -> toPrepend.Add item; v)\n        m.Var.Value <- m.Storage.PrependMany toPrepend v\n\n    member m.Remove item =\n        let v = m.Var.Value\n        if ListModels.Contains m.key item v then\n            let keyFn = m.key\n            let k = keyFn item\n            m.Var.Value <- m.Storage.RemoveIf (fun i -> keyFn i = k) v\n            m.ObsoleteKey k\n\n    member m.RemoveBy (f: 'T -> bool) =\n        for v in m.Var.Value do\n            if f v then\n                m.ObsoleteKey (m.key v)\n        m.Var.Value <- m.Storage.RemoveIf f m.Var.Value\n\n    member m.RemoveByKey key =\n        m.Var.Value <- m.Storage.RemoveIf (fun i -> m.Key i = key) m.Var.Value\n        m.ObsoleteKey key\n\n    member m.Iter fn =\n        Array.iter fn m.Var.Value\n\n    member m.Set lst =\n        m.Var.Value <- m.Storage.Set lst\n        m.ObsoleteAll()\n\n    member m.ContainsKey key =\n        Array.exists (fun it -> m.key it = key) m.Var.Value\n\n    member m.ContainsKeyAsView key =\n        m.Var.View |> View.Map (Array.exists (fun it -> m.key it = key))\n\n    member m.Find pred =\n        Array.find pred m.Var.Value\n\n    member m.TryFind pred =\n        Array.tryFind pred m.Var.Value\n\n    member m.FindAsView pred =\n        m.Var.View |> View.Map (Array.find pred)\n\n    member m.TryFindAsView pred =\n        m.Var.View |> View.Map (Array.tryFind pred)\n\n    member m.FindByKey key =\n        Array.find (fun it -> m.key it = key) m.Var.Value\n\n    member m.TryFindByKey key =\n        Array.tryFind (fun it -> m.key it = key) m.Var.Value\n\n    member m.TryFindByKeyAsView key =\n        ViewOptimization.V (fun () -> \n            match m.itemSnaps.TryGetValue(key) with\n            | true, snap -> snap                \n            | _ ->\n                let it = m.TryFindByKey(key)\n                let sn = Snap.CreateWithValue it\n                m.itemSnaps.Add(key, sn)\n                sn\n        )\n\n    member m.FindByKeyAsView key =\n        m.TryFindByKeyAsView key |> View.Map Option.get\n\n    member m.UpdateAll fn =\n        m.Var.Update <| fun a ->\n            a |> Array.iteri (fun i x ->\n                fn x |> Option.iter (fun y -> a.[i] <- y))\n            m.Storage.Set a\n        m.ObsoleteAll()\n\n    member m.UpdateBy fn key =\n        let v = m.Var.Value\n        match Array.tryFindIndex (fun it -> m.key it = key) v with\n        | None -> ()\n        | Some index ->\n            match fn v.[index] with\n            | None -> ()\n            | Some value ->\n                m.Var.Value <- m.Storage.SetAt index value v\n                m.ObsoleteKey key\n\n    [<Inline>]\n    member m.UpdateByU(fn, key) =\n        m.UpdateBy fn key\n\n    member m.Clear () =\n        m.Var.Value <- m.Storage.Set Seq.empty\n        m.ObsoleteAll()\n\n    member m.Length =\n        m.Var.Value.Length\n\n    member m.LengthAsView =\n        m.Var.View |> View.Map (fun arr -> arr.Length)\n\n    member m.LensInto (get: 'T -> 'V) (update: 'T -> 'V -> 'T) (key : 'Key) : IRef<'V> =\n        let id = Fresh.Id()\n\n        let view = m.FindByKeyAsView(key) |> View.Map get\n    \n        { new IRef<'V> with\n\n            member r.Get() =\n                m.FindByKey key |> get\n\n            member r.Set(v) =\n                m.UpdateBy (fun i -> Some (update i v)) key\n\n            member r.Value\n                with get() = r.Get()\n                and set v = r.Set v\n\n            member r.Update(f) =\n                m.UpdateBy (fun i -> Some (update i (f (get i)))) key\n\n            member r.UpdateMaybe(f) =\n                m.UpdateBy (fun i -> Option.map (fun v -> update i v) (f (get i))) key\n\n            member r.View =\n                view\n\n            member r.Id =\n                id\n        }\n\n    [<Inline>]\n    member m.LensIntoU (get: 'T -> 'V, update: 'T -> 'V -> 'T, key : 'Key) : IRef<'V> =\n        m.LensInto get update key\n\n    member m.Lens (key: 'Key) =\n        m.LensInto id (fun _ -> id) key\n\n    member m.Value\n        with [<Inline>] get () = m.Var.Value :> seq<_>\n        and [<Inline>] set v = m.Set(v)\n\n[<JavaScript>]\ntype ListModel =\n\n    static member CreateWithStorage<'Key,'T when 'Key : equality>\n            (key: 'T -> 'Key) (storage : Storage<'T>) =\n        ListModel<'Key, 'T>(key, storage)\n\n    static member Create<'Key, 'T when 'Key : equality> (key: 'T -> 'Key) init =\n        ListModel.CreateWithStorage key (Storage.InMemory <| Seq.toArray init)\n\n    static member FromSeq init =\n        ListModel.Create id init\n\n    static member Wrap<'Key, 'T, 'U when 'Key : equality>\n            (underlying: ListModel<'Key, 'U>)\n            (extract: 'T -> 'U)\n            (createItem: 'U -> 'T)\n            (updateItem: 'T -> 'U -> 'T) =\n        let state = ref (Dictionary<'Key, 'T>())\n        let init =\n            underlying.Var.Value |> Array.map (fun u ->\n                let t = createItem u\n                (!state).[underlying.Key u] <- t\n                t)\n        let var : IRef<'T[]> =\n            underlying.Var.Lens\n                <| fun us ->\n                    let newState = Dictionary<'Key, 'T>()\n                    let ts =\n                        us |> Array.map (fun u ->\n                            let k = underlying.Key u\n                            let t =\n                                if (!state).ContainsKey(k) then\n                                    updateItem (!state).[k] u\n                                else\n                                    createItem u\n                            newState.[k] <- t\n                            t\n                        )\n                    state := newState\n                    ts\n                <| fun us ts ->\n                    let newState = Dictionary<'Key, 'T>()\n                    let us =\n                        ts |> Array.map (fun t ->\n                            let u = extract t\n                            newState.[underlying.Key u] <- t\n                            u)\n                    state := newState\n                    us\n        ListModel<'Key, 'T>(Func<_,_>(extract >> underlying.Key), var, Storage.InMemory init)\n\n    [<Inline>]\n    static member View (m: ListModel<_,_>) =\n        m.View\n\n    [<Inline>]\n    static member ViewState (m: ListModel<_,_>) =\n        m.ViewState\n\n    [<Inline>]\n    static member Key (m: ListModel<_,_>) =\n        m.key\n\ntype ListModel<'Key,'T> with\n\n    member this.Wrap extract wrap update =\n        ListModel.Wrap this extract wrap update\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2014 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\nnamespace WebSharper.UI.Next\n\nopen System\nopen WebSharper\nopen WebSharper.JavaScript\nopen System.Runtime.InteropServices\n\ntype Time = double\ntype NormalizedTime = double\n\n// Interpolation --------------------------------------------------------------\n\ntype Interpolation<'T> =\n    [<Name \"Interpolate\">]\n    abstract Interpolate : NormalizedTime -> 'T -> 'T -> 'T\n\n[<JavaScript>]\ntype DoubleInterpolation =\n    | DoubleInterpolation\n\n    interface Interpolation<double> with\n        member d.Interpolate t x y =\n            x + t * (y - x)\n\n[<JavaScript>]\n[<Sealed>]\ntype Interpolation =\n    static member Double = DoubleInterpolation :> Interpolation<_>\n\n// Easing ---------------------------------------------------------------------\n\n[<JavaScript>]\ntype Easing (transformTime : Converter<NormalizedTime, NormalizedTime>) =\n\n    member this.TransformTime t = transformTime.Invoke t\n    static member Custom f = Easing (fun t -> f t)\n\n[<JavaScript>]\nmodule Easings =\n\n    let CubicInOut =\n        let f t =\n            let t2 = t * t\n            let t3 = t2 * t\n            3. * t2 - 2. * t3\n        Easing.Custom f\n\ntype Easing with\n    static member CubicInOut = Easings.CubicInOut\n\n// Animation ------------------------------------------------------------------\n\ntype Anim<'T> =\n    private {\n        Compute : Time -> 'T\n        Duration : Time\n    }\n\ntype Animation =\n    | Finally of (unit -> unit)\n    | Work of Anim<unit>\n\n[<JavaScript>]\n[<Name \"An\">]\ntype Anim =\n    | Anim of AppendList<Animation>\n\n[<JavaScript>]\nmodule Anims =\n\n    [<MethodImpl(MethodImplOptions.NoInlining)>]\n    let List (Anim xs) =\n        xs\n\n    let Finalize (Anim all) =\n        AppendList.ToArray all\n        |> Array.iter (function\n            | Finally f -> f ()\n            | _ -> ())\n\n    [<MethodImpl(MethodImplOptions.NoInlining)>]\n    let Def d f =\n        { Compute = f; Duration = d}\n\n    let Const v =\n        Def 0. (fun t -> v)\n\n    // \"Prolongs\" an animation to the given time by adding in several\n    // no-ops after the animation finishes.\n    let Prolong nextDuration anim =\n        let comp = anim.Compute\n        let dur = anim.Duration\n        let last = lazy anim.Compute anim.Duration\n        let compute t = if t >= dur then last.Value else comp t\n\n        {\n            Compute = compute\n            Duration = nextDuration\n        }\n\n    let ConcatActions xs =\n        let xs = Array.ofSeqNonCopying xs\n        match xs.Length with\n        | 0 -> Const ()\n        | 1 -> xs.[0]\n        | _ ->\n            let dur = xs |> Seq.map (fun anim -> anim.Duration) |> Seq.max\n            let xs = Array.map (Prolong dur) xs\n            Def dur (fun t -> Array.iter (fun anim -> anim.Compute t) xs)\n\n    let Actions (Anim all) =\n        AppendList.ToArray all\n        |> Array.choose (function\n            | Work w -> Some w\n            | _ -> None)\n        |> ConcatActions\n\n    let mutable UseAnimations = true\n\ntype Anim with\n\n    static member UseAnimations \n        with get() = Anims.UseAnimations\n        and set v = Anims.UseAnimations <- v \n\n    static member Append (Anim a) (Anim b) =\n        Anim (AppendList.Append a b)\n\n    static member Concat xs =\n        xs\n        |> Seq.map Anims.List\n        |> AppendList.Concat\n        |> Anim\n\n    static member Const v =\n        Anims.Const v\n\n    static member Simple (inter: Interpolation<'T>) (easing: Easing) dur x y=\n        {\n            Duration = dur\n            Compute = fun t ->\n                let t = easing.TransformTime (t / dur)\n                inter.Interpolate t x y\n        }\n\n    static member Delayed (inter: Interpolation<'T>) (easing: Easing) dur delay x y =\n        {\n            Duration = dur + delay\n            Compute = fun t ->\n              //  JavaScript.Log <| \"T: \" + (string t) + \", delay: \" + (string delay)\n                if t <= delay then\n                    x\n                else\n                    let normalisedTime = easing.TransformTime ((t - delay) / dur)\n                    inter.Interpolate normalisedTime x y\n        }\n\n    static member Map f anim =\n        Anims.Def anim.Duration (anim.Compute >> f)\n\n    static member Pack anim =\n        Anim (AppendList.Single (Work anim))\n\n    static member Play anim =\n        async {\n            do! Anims.Actions anim\n                |> Anim.Run ignore\n            return Anims.Finalize anim\n        }\n\n    static member Run k anim =\n        let dur = anim.Duration\n        if dur = 0. then async.Zero() else\n        Async.FromContinuations <| fun (ok, _, _) ->\n            let rec loop start now =\n                let t = now - start\n                k (anim.Compute t)\n                if t <= dur then\n                    JS.RequestAnimationFrame (fun t -> loop start t) |> ignore\n                else ok ()\n            JS.RequestAnimationFrame (fun t -> loop t t) |> ignore\n\n    static member WhenDone f main =\n        main\n        |> Anim.Append (Anim (AppendList.Single (Finally f)))\n\n    static member Empty =\n        Anim AppendList.Empty\n\n// Transitions ----------------------------------------------------------------\n\ntype TFlags =\n    | TTrivial = 0\n    | TChange = 1\n    | TEnter = 2\n    | TExit = 4\n\n[<JavaScript>]\ntype Trans<'T>\n    (\n        change: Func<'T, 'T, Anim<'T>>,\n        enter: Func<'T, Anim<'T>>,\n        exit: Func<'T, Anim<'T>>,\n        flags: TFlags\n    ) =\n\n    new () =\n        Trans(\n            (fun x y -> Anim.Const y),\n            (fun t -> Anim.Const t),\n            (fun t -> Anim.Const t),\n            TFlags.TTrivial\n        )\n\n    new (ch: Func<'T, 'T, Anim<'T>>) =\n        Trans(\n            ch,\n            (fun t -> Anim.Const t),\n            (fun t -> Anim.Const t),\n            TFlags.TChange\n        )\n\n    new (ch: Func<'T, 'T, Anim<'T>>, enter, exit) =\n        Trans(\n            ch,\n            (if enter = null then Func<_,_>(fun t -> Anim.Const t) else enter),\n            (if exit = null then Func<_,_>(fun t -> Anim.Const t) else exit),\n            TFlags.TChange ||| \n                (if enter = null then TFlags.TTrivial else TFlags.TEnter) |||\n                (if exit = null then TFlags.TTrivial else TFlags.TExit)\n        )\n\n    member this.TChange x y = change.Invoke(x, y)\n    member this.TEnter = enter.Invoke\n    member this.TExit = exit.Invoke\n    member this.TFlags = flags\n\n    member this.Copy(?change, ?enter, ?exit, ?flags) =\n        let ch = defaultArg change this.TChange\n        let en = defaultArg enter this.TEnter\n        let ex = defaultArg exit this.TExit\n        let fl = defaultArg flags this.TFlags\n        Trans(Func<_,_,_>(ch), Func<_,_>(en),\n            Func<_,_>(ex), fl)\n\n[<JavaScript>]\n[<Sealed>]\ntype Trans =\n\n  // Using a Trans ---------------\n\n    static member AnimateChange (tr: Trans<'T>) x y = tr.TChange x y\n    static member AnimateEnter (tr: Trans<'T>) x = tr.TEnter x\n    static member AnimateExit (tr: Trans<'T>) x = tr.TExit x\n    static member CanAnimateChange (tr: Trans<'T>) = tr.TFlags.HasFlag(TFlags.TChange)\n    static member CanAnimateEnter (tr: Trans<'T>) = tr.TFlags.HasFlag(TFlags.TEnter)\n    static member CanAnimateExit (tr: Trans<'T>) = tr.TFlags.HasFlag(TFlags.TExit)\n\n  // Creating a Trans ------------\n\n    static member Trivial () =\n        Trans()\n\n    static member Create (ch: 'T -> 'T -> Anim<'T>) =\n        Trans(Func<_,_,_>(ch))\n\n    static member Change ch (tr: Trans<'T>) =\n        tr.Copy(change = ch, flags = (tr.TFlags ||| TFlags.TChange))\n\n    static member Enter f (tr: Trans<'T>) =\n        tr.Copy(enter = f, flags = (tr.TFlags ||| TFlags.TEnter))\n\n    static member Exit f (tr: Trans<'T>) =\n        tr.Copy(exit = f, flags = (tr.TFlags ||| TFlags.TExit))\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2014 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\nnamespace WebSharper.UI.Next.Client\n\nopen System.Collections.Generic\nopen Microsoft.FSharp.Quotations\nopen WebSharper\nopen WebSharper.JavaScript\nopen WebSharper.UI.Next\nmodule DU = DomUtility\n\ntype IAttrNode =\n    [<Name \"NChanged\">]\n    abstract Changed : View<unit>\n    [<Name \"NGetChangeAnim\">]\n    abstract GetChangeAnim : Element -> Anim\n    [<Name \"NGetEnterAnim\">]\n    abstract GetEnterAnim : Element -> Anim\n    [<Name \"NGetExitAnim\">]\n    abstract GetExitAnim : Element -> Anim\n    [<Name \"NSync\">]\n    abstract Sync : Element -> unit\n\n[<JavaScript; Sealed; Name \"WebSharper.UI.Next.AnimatedAttrNode\">]\ntype AnimatedAttrNode<'T>(tr: Trans<'T>, view: View<'T>, push: Element -> 'T -> unit) =\n    let mutable logical : option<'T> = None // current logical value\n    let mutable visible : option<'T> = None // current value pushed to the parent element\n    let mutable dirty = true // logical <> visible\n\n    let updates =\n        view\n        |> View.Map (fun x ->\n            logical <- Some x\n            dirty <- true)\n\n    let pushVisible el v =\n        visible <- Some v\n        dirty <- true\n        push el v\n\n    let sync p =\n        if dirty then\n            Option.iter (fun v -> push p v) logical\n            visible <- logical\n            dirty <- false\n\n    interface IAttrNode with\n\n        member a.GetChangeAnim parent =\n            match visible, logical with\n            | Some v, Some l when dirty ->\n                Trans.AnimateChange tr v l\n                |> Anim.Map (pushVisible parent)\n                |> Anim.Pack\n            | _ -> Anim.Empty\n            |> Anim.WhenDone (fun () -> sync parent)\n\n        member a.GetEnterAnim parent =\n            match visible, logical with\n            | Some vi, Some lo when dirty ->\n                Trans.AnimateChange tr vi lo\n                |> Anim.Map (pushVisible parent)\n                |> Anim.Pack\n            | None, Some lo ->\n                Trans.AnimateEnter tr lo\n                |> Anim.Map (pushVisible parent)\n                |> Anim.Pack\n            | _ -> Anim.Empty\n            |> Anim.WhenDone (fun () -> sync parent)\n\n        member a.GetExitAnim parent =\n            match visible with\n            | Some cur ->\n                Trans.AnimateExit tr cur\n                |> Anim.Map (pushVisible parent)\n                |> Anim.Pack\n            | _ -> Anim.Empty\n            |> Anim.WhenDone (fun () -> dirty <- true; visible <- None)\n\n        /// NOTE: enter or change animation will do the sync.\n        member a.Sync parent = ()\n\n        member a.Changed = updates\n\n[<JavaScript; Sealed; Name \"WebSharper.UI.Next.DynamicAttrNode\">]\ntype DynamicAttrNode<'T>(view: View<'T>, push: Element -> 'T -> unit) =\n    let mutable value = U\n    let mutable dirty = false\n    let updates = view |> View.Map (fun x -> value <- x; dirty <- true)\n    interface IAttrNode with\n        member a.GetChangeAnim parent = Anim.Empty\n        member a.GetEnterAnim parent = Anim.Empty\n        member a.GetExitAnim parent = Anim.Empty\n        member a.Sync parent = if dirty then push parent value; dirty <- false\n        member a.Changed = updates\n\ntype AttrFlags =\n    | Defaults = 0\n    | HasEnterAnim = 1\n    | HasExitAnim = 2\n    | HasChangeAnim = 4\n\n[<JavaScript; Proxy(typeof<Attr>); Name \"WebSharper.UI.Next.AttrProxy\"; Prototype>]\ntype internal AttrProxy =\n    | [<Constant(null)>] A0\n    | A1 of IAttrNode\n    | A2 of AttrProxy * AttrProxy\n    | A3 of init: (Element -> unit)\n    | A4 of onAfterRender: (Element -> unit)\n\n[<JavaScript; Name \"WebSharper.UI.Next.Attrs\">]\nmodule Attrs =\n\n    type Dyn =\n        {\n            DynElem : Element\n            DynFlags : AttrFlags\n            DynNodes : IAttrNode []\n            [<OptionalField>]\n            OnAfterRender : option<Element -> unit>\n        }\n\n    let HasChangeAnim attr =\n        attr.DynFlags.HasFlag AttrFlags.HasChangeAnim\n\n    let HasEnterAnim attr =\n        attr.DynFlags.HasFlag AttrFlags.HasEnterAnim\n\n    let HasExitAnim attr =\n        attr.DynFlags.HasFlag AttrFlags.HasExitAnim\n\n    let Flags a =\n        if a !==. null && JS.HasOwnProperty a \"flags\"\n        then a?flags\n        else AttrFlags.Defaults\n\n    let SetFlags (a: AttrProxy) (f: AttrFlags) =\n        a?flags <- f\n\n    /// Synchronizes dynamic attributes.\n    let Sync elem dyn =\n        dyn.DynNodes\n        |> Array.iter (fun d ->\n            d.Sync elem)\n\n    /// Inserts static attributes and computes dynamic attributes.\n    let Insert elem (tree: Attr) =\n        let nodes = Queue()\n        let oar = Queue()\n        let rec loop node =\n            if not (Object.ReferenceEquals(node, null)) then // work around WS issue with UseNullAsTrueValue\n            match node with\n            | A0 -> ()\n            | A1 n -> nodes.Enqueue n\n            | A2 (a, b) -> loop a; loop b\n            | A3 mk -> mk elem\n            | A4 cb -> oar.Enqueue cb\n        loop (As<AttrProxy> tree)\n        let arr = nodes.ToArray()\n        {\n            DynElem = elem\n            DynFlags = Flags tree\n            DynNodes = arr\n            OnAfterRender =\n                if oar.Count = 0 then None else\n                Some (fun el -> Seq.iter (fun f -> f el) oar)\n        }\n\n    let Empty e =\n        {\n            DynElem = e\n            DynFlags = AttrFlags.Defaults\n            DynNodes = [||]\n            OnAfterRender = None\n        }\n\n    let Updates dyn =\n        dyn.DynNodes\n        |> Array.MapTreeReduce (fun x -> x.Changed) (View.Const ()) View.Map2Unit\n\n    let GetAnim dyn f =\n        dyn.DynNodes\n        |> Array.map (fun n -> f n dyn.DynElem)\n        |> Anim.Concat\n\n    let GetEnterAnim dyn =\n        GetAnim dyn (fun n -> n.GetEnterAnim)\n\n    let GetExitAnim dyn =\n        GetAnim dyn (fun n -> n.GetExitAnim)\n\n    let GetChangeAnim dyn =\n        GetAnim dyn (fun n -> n.GetChangeAnim)\n\n    [<Inline>]\n    let GetOnAfterRender dyn =\n        dyn.OnAfterRender\n\n    let AppendTree a b =\n        // work around WS issue with UseNullAsTrueValue\n        if Object.ReferenceEquals(a, null) then b\n        elif Object.ReferenceEquals(b, null) then a\n        else\n        let x = A2 (a, b)\n        SetFlags x (Flags a ||| Flags b)\n        x\n//        match a, b with\n//        | A0, x | x, A0 -> x\n//        | _ -> A2 (a, b)\n\n    let internal EmptyAttr = A0\n\n    let internal Animated tr view set =\n        let node = AnimatedAttrNode (tr, view, set)\n        let mutable flags = AttrFlags.HasChangeAnim\n        if Trans.CanAnimateEnter tr then\n            flags <- flags ||| AttrFlags.HasEnterAnim\n        if Trans.CanAnimateExit tr then\n            flags <- flags ||| AttrFlags.HasExitAnim\n        let n = A1 node\n        SetFlags n flags\n        n\n\n    [<MethodImpl(MethodImplOptions.NoInlining)>]\n    let internal Dynamic view set =\n        A1 (DynamicAttrNode (view, set))\n\n    [<MethodImpl(MethodImplOptions.NoInlining)>]\n    let internal Static attr =\n        A3 attr\n\n\n[<JavaScript>]\ntype AttrProxy with\n\n    static member Create name value =\n        As<Attr> (Attrs.Static (fun el -> DU.SetAttr el name value))\n\n    static member Append (a: Attr) (b: Attr) =\n        As<Attr> (Attrs.AppendTree (As a) (As b))\n\n    [<Inline>]\n    static member Empty =\n        As<Attr> Attrs.EmptyAttr\n\n    static member Concat (xs: seq<Attr>) =\n        Array.ofSeqNonCopying xs\n        |> Array.TreeReduce Attr.Empty Attr.Append\n\n    static member Handler (event: string) (q: Expr<Element -> #DomEvent-> unit>) =\n        As<Attr> (Attrs.Static (fun el -> el.AddEventListener(event, (As<Element -> DomEvent -> unit> q) el, false)))\n\n[<JavaScript; Name \"WebSharper.UI.Next.CheckedInput\">]\ntype CheckedInput<'T> =\n    | Valid of value: 'T * inputText: string\n    | Invalid of inputText: string\n    | Blank of inputText: string\n\n    static member Make(x: 'T) =\n        Valid (x, x.ToString())\n\n    member this.Input =\n        match this with\n        | Valid (_, x)\n        | Invalid x\n        | Blank x -> x\n\n[<JavaScript; Name \"WebSharper.UI.Next.AttrModule\">]\nmodule Attr =\n\n    let Style name value =\n        As<Attr> (Attrs.Static (fun el -> DU.SetStyle el name value))\n\n    let Class name =\n        As<Attr> (Attrs.Static (fun el -> DU.AddClass el name))\n\n    let Animated name tr view attr =\n        As<Attr> (Attrs.Animated tr view (fun el v -> DU.SetAttr el name (attr v)))\n\n    let AnimatedStyle name tr view attr =\n        As<Attr> (Attrs.Animated tr view (fun el v -> DU.SetStyle el name (attr v)))\n\n    let Dynamic name view =\n        As<Attr> (Attrs.Dynamic view (fun el v -> DU.SetAttr el name v))\n\n    let DynamicCustom set view =\n        As<Attr> (Attrs.Dynamic view set)\n\n    let DynamicStyle name view =\n        As<Attr> (Attrs.Dynamic view (fun el v -> DU.SetStyle el name v))\n\n    let Handler name (callback: Element -> #DomEvent -> unit) =\n        As<Attr> (Attrs.Static (fun el -> el.AddEventListener(name, As<DomEvent -> unit> (callback el), false)))\n\n    let HandlerView name (view: View<'T>) (callback: Element -> #DomEvent -> 'T -> unit) =\n        let init (el: Element) =\n            let callback = callback el\n            el.AddEventListener(name, (fun (ev: DomEvent) -> View.Get (callback (As ev)) view), false)\n        As<Attr> (Attrs.Static init)\n\n    let OnAfterRender (callback: Element -> unit) =\n        As<Attr> (A4 callback)\n\n    let OnAfterRenderView (v: View<'T>) (callback: Element -> 'T -> unit) =\n        let id = Fresh.Id()\n        Attr.Append\n            (OnAfterRender (fun el -> callback el el?(id)))\n            (DynamicCustom (fun el x -> el?(id) <- x) v)\n\n    let DynamicClass name view ok =\n        As<Attr> (Attrs.Dynamic view (fun el v ->\n            if ok v then DU.AddClass el name else DU.RemoveClass el name))\n\n    let DynamicPred name predView valView =\n        let viewFn el (p, v) =\n            if p then\n                DU.SetAttr el name v\n            else\n                DU.RemoveAttr el name\n        let tupleView = View.Map2 (fun pred value -> (pred, value)) predView valView\n        As<Attr> (Attrs.Dynamic tupleView viewFn)\n\n    let DynamicProp name view =\n        As<Attr> (Attrs.Dynamic view (fun el v ->\n            el?(name) <- v))\n\n    let CustomVar (var: IRef<'a>) (set: Element -> 'a -> unit) (get: Element -> 'a option) =\n        let onChange (el: Element) (e: DomEvent) =\n            var.UpdateMaybe(fun v ->\n                match get el with\n                | Some x as o when x <> v -> o\n                | _ -> None)\n        let set e v =\n            match get e with\n            | Some x when x = v -> ()\n            | _ -> set e v\n        Attr.Concat [\n            Handler \"change\" onChange\n            Handler \"input\" onChange\n            Handler \"keypress\" onChange\n            DynamicCustom set var.View\n        ]\n\n    let CustomValue (var: IRef<'a>) (toString : 'a -> string) (fromString : string -> 'a option) =\n        CustomVar var (fun e v -> e?value <- toString v) (fun e -> fromString e?value)\n\n    let ContentEditableText (var: IRef<string>) =\n        CustomVar var (fun e v -> e.TextContent <- v) (fun e -> Some e.TextContent)\n        |> Attr.Append (Attr.Create \"contenteditable\" \"true\")\n\n    let ContentEditableHtml (var: IRef<string>) =\n        CustomVar var (fun e v -> e?innerHTML <- v) (fun e -> Some e?innerHTML)\n        |> Attr.Append (Attr.Create \"contenteditable\" \"true\")\n\n    let Value (var: IRef<string>) =\n        CustomValue var id (id >> Some)\n\n    [<JavaScript; Inline \"$e.checkValidity?$e.checkValidity():true\">]\n    let CheckValidity (e: Dom.Element) = X<bool>\n\n    let IntValueUnchecked (var: IRef<int>) =\n        let parseInt (s: string) =\n            if String.isBlank s then Some 0 else\n            let pd : int = JS.Plus s\n            if pd !==. (pd >>. 0) then None else Some pd\n        CustomValue var string parseInt\n\n    let IntValue (var: IRef<CheckedInput<int>>) =\n        let parseCheckedInt (el: Dom.Element) : option<CheckedInput<int>> =\n            let s = el?value\n            if String.isBlank s then\n                if CheckValidity el then Blank s else Invalid s\n            else\n                match System.Int32.TryParse(s) with\n                | true, i -> Valid (i, s)\n                | false, _ -> Invalid s\n            |> Some\n        CustomVar var\n            (fun el i ->\n                let i = i.Input\n                if el?value <> i then el?value <- i)\n            parseCheckedInt\n\n    let FloatValueUnchecked (var: IRef<float>) =\n        let parseFloat (s: string) =\n            if String.isBlank s then Some 0. else\n            let pd : float = JS.Plus s\n            if JS.IsNaN pd then None else Some pd\n        CustomValue var string parseFloat\n\n    let FloatValue (var: IRef<CheckedInput<float>>) =\n        let parseCheckedFloat (el: Dom.Element) : option<CheckedInput<float>> =\n            let s = el?value\n            if String.isBlank s then\n                if CheckValidity el then Blank s else Invalid s\n            else\n                let i = JS.Plus s\n                if JS.IsNaN i then Invalid s else Valid (i, s)\n            |> Some\n        CustomVar var\n            (fun el i ->\n                let i = i.Input\n                if el?value <> i then el?value <- i)\n            parseCheckedFloat\n\n    let Checked (var: IRef<bool>) =\n        let onSet (el: Dom.Element) (ev: Dom.Event) =\n            if var.Value <> el?``checked`` then\n                var.Value <- el?``checked``\n        Attr.Concat [\n            DynamicProp \"checked\" var.View\n            Handler \"change\" onSet\n            Handler \"click\" onSet\n        ]\n\n    let ValidateForm () =\n        OnAfterRender Resources.H5F.Setup\n\n[<assembly:System.Reflection.AssemblyVersionAttribute(\"4.0.0.0\")>]\ndo()\n", "namespace WebSharper.UI.Next.Client\n\nopen System\nopen System.Collections.Generic\nopen System.Runtime.CompilerServices\nopen WebSharper\nopen WebSharper.JavaScript\nopen WebSharper.UI.Next\n\nmodule DU = DomUtility\n\n[<JavaScript>]\ntype DocNode =\n    | AppendDoc of DocNode * DocNode\n    | ElemDoc of DocElemNode\n    | EmbedDoc of DocEmbedNode\n    | [<Constant(null)>] EmptyDoc\n    | TextDoc of DocTextNode\n    | TextNodeDoc of TextNode\n    | TreeDoc of DocTreeNode\n\nand [<CustomEquality>]\n    [<JavaScript>]\n    [<NoComparison>]\n    [<Name \"WebSharper.UI.Next.DocElemNode\">]\n    DocElemNode =\n    {\n        Attr : Attrs.Dyn\n        mutable Children : DocNode\n        [<OptionalField>]\n        Delimiters : (Node * Node) option\n        El : Element\n        ElKey : int\n        [<OptionalField>]\n        mutable Render : option<Dom.Element -> unit>\n    }\n\n    override this.Equals(o: obj) =\n        this.ElKey = (o :?> DocElemNode).ElKey\n\n    override this.GetHashCode() =\n        this.ElKey\n\nand DocEmbedNode =\n    {\n        mutable Current : DocNode\n        mutable Dirty : bool\n    }\n\nand DocTextNode =\n    {\n        Text : TextNode\n        mutable Dirty : bool\n        mutable Value : string\n    }\n\nand DocTreeNode =\n    {\n        mutable Els : Union<Node, DocNode>[]\n        mutable Dirty : bool\n        mutable Holes : DocElemNode[]\n        Attrs : (Element * Attrs.Dyn)[]\n        [<OptionalField>]\n        mutable Render : option<Dom.Element -> unit>\n    }\n\ntype EltUpdater =\n    inherit Elt\n\n    member this.AddUpdated(doc: Elt) = ()\n    member this.RemoveUpdated(doc: Elt) = ()\n    member this.RemoveAllUpdated() = ()\n\n[<JavaScript; Name \"WebSharper.UI.Next.Docs\">]\nmodule Docs =\n\n    /// Sets of DOM nodes.\n    type DomNodes =\n        | DomNodes of Node[]\n\n        /// Actual chidlren of an element.\n        static member Children (elem: Element) (delims: option<Node * Node>) =\n            match delims with\n            | None ->\n                DomNodes (Array.init elem.ChildNodes.Length elem.ChildNodes.Item)\n            | Some (ldelim, rdelim) ->\n                let a = Array<_>()\n                let mutable n = ldelim.NextSibling\n                while n !==. rdelim do\n                    a.Push(n) |> ignore\n                    n <- n.NextSibling\n                DomNodes (As a)\n\n        /// Shallow children of an element node.\n        static member DocChildren node =\n            let q = Queue()\n            let rec loop doc =\n                match doc with\n                | AppendDoc (a, b) -> loop a; loop b\n                | EmbedDoc d -> loop d.Current\n                | ElemDoc e -> q.Enqueue (e.El :> Node)\n                | EmptyDoc -> ()\n                | TextNodeDoc tn -> q.Enqueue (tn :> Node)\n                | TextDoc t -> q.Enqueue (t.Text :> Node)\n                | TreeDoc t ->\n                    t.Els |> Array.iter (function\n                        | Union1Of2 e -> q.Enqueue e\n                        | Union2Of2 n -> loop n\n                    )\n            loop node.Children\n            DomNodes (Array.ofSeqNonCopying q)\n\n        /// Set difference - currently only using equality O(N^2).\n        /// Can do better? Can store <hash> data on every node?\n        static member Except (DomNodes excluded) (DomNodes included) =\n            included\n            |> Array.filter (fun n ->\n                excluded\n                |> Array.forall (fun k -> not (n ===. k)))\n            |> DomNodes\n\n        /// Iteration.\n        static member Iter f (DomNodes ns) =\n            Array.iter f ns\n\n        /// Iteration.\n        static member FoldBack f (DomNodes ns) z =\n            Array.foldBack f ns z\n\n    /// Inserts a node at position.\n    [<MethodImpl(MethodImplOptions.NoInlining)>]\n    let InsertNode parent node pos =\n        DU.InsertAt parent pos node\n        DU.BeforeNode node\n\n    /// Inserts a doc at position.\n    let rec InsertDoc parent doc pos =\n        match doc with\n        | AppendDoc (a, b) -> InsertDoc parent a (InsertDoc parent b pos)\n        | ElemDoc e -> InsertNode parent e.El pos\n        | EmbedDoc d -> d.Dirty <- false; InsertDoc parent d.Current pos\n        | EmptyDoc -> pos\n        | TextDoc t -> InsertNode parent t.Text pos\n        | TextNodeDoc t -> InsertNode parent t pos\n        | TreeDoc t ->\n            Array.foldBack (fun el pos ->\n                match el with\n                | Union1Of2 e -> InsertNode parent e pos\n                | Union2Of2 n -> InsertDoc parent n pos\n            ) t.Els pos\n\n    /// Synchronizes an element with its children (shallow).\n    let DoSyncElement (el : DocElemNode) =\n        let parent = el.El\n        let rec ins doc pos =\n            match doc with\n            | AppendDoc (a, b) -> ins a (ins b pos)\n            | ElemDoc e -> DU.BeforeNode e.El\n            | EmbedDoc d ->\n                if d.Dirty then\n                    d.Dirty <- false\n                    InsertDoc parent d.Current pos\n                else\n                    ins d.Current pos\n            | EmptyDoc -> pos\n            | TextDoc t -> DU.BeforeNode t.Text\n            | TextNodeDoc t -> DU.BeforeNode t\n            | TreeDoc t ->\n                if t.Dirty then t.Dirty <- false\n                Array.foldBack (fun el pos ->\n                    match el with\n                    | Union1Of2 e -> DU.BeforeNode e\n                    | Union2Of2 n -> ins n pos\n                ) t.Els pos\n        let ch = DomNodes.DocChildren el\n        // remove children that are not in the current set\n        DomNodes.Children el.El el.Delimiters\n        |> DomNodes.Except ch\n        |> DomNodes.Iter (DU.RemoveNode el.El)\n        // insert current children\n        let pos =\n            match el.Delimiters with\n            | None -> DU.AtEnd\n            | Some (_, rdelim) -> DU.BeforeNode rdelim\n        ins el.Children pos |> ignore\n\n    /// Optimized version of DoSyncElement.\n    let SyncElement (el: DocElemNode) =\n        /// Test if any children have changed.\n        let rec hasDirtyChildren el =\n            let rec dirty doc =\n                match doc with\n                | AppendDoc (a, b) -> dirty a || dirty b\n                | EmbedDoc d -> d.Dirty || dirty d.Current\n                | TreeDoc t -> t.Dirty || Array.exists hasDirtyChildren t.Holes\n                | _ -> false\n            dirty el.Children\n        Attrs.Sync el.El el.Attr\n        if hasDirtyChildren el then\n            DoSyncElement el\n\n    /// Links an element to children by inserting them.\n    [<MethodImpl(MethodImplOptions.NoInlining)>]\n    let LinkElement el children =\n        InsertDoc el children DU.AtEnd |> ignore\n\n    /// Links an element to previous siblings by inserting them.\n    [<MethodImpl(MethodImplOptions.NoInlining)>]\n    let LinkPrevElement (el: Node) children =\n        InsertDoc (el.ParentNode :?> _) children (DU.BeforeNode el) |> ignore\n\n    let InsertBeforeDelim (afterDelim: Dom.Node) (doc: DocNode) =\n        let p = afterDelim.ParentNode\n        let before = JS.Document.CreateTextNode(\"\") :> Dom.Node\n        p.InsertBefore(before, afterDelim) |> ignore\n        LinkPrevElement afterDelim doc\n        before\n\n    /// Invokes and clears an element's afterRender callback(s).\n    let AfterRender (el: DocElemNode) =\n        match el.Render with\n        | None -> ()\n        | Some f -> f el.El; el.Render <- None\n\n    /// Synchronizes the document (deep).\n    let rec Sync doc =\n        match doc with\n        | AppendDoc (a, b) -> Sync a; Sync b\n        | ElemDoc el -> SyncElemNode el\n        | EmbedDoc n -> Sync n.Current\n        | EmptyDoc\n        | TextNodeDoc _ -> ()\n        | TextDoc d ->\n            if d.Dirty then\n                d.Text.NodeValue <- d.Value\n                d.Dirty <- false\n        | TreeDoc t ->\n            Array.iter SyncElemNode t.Holes\n            Array.iter (fun (e, a) -> Attrs.Sync e a) t.Attrs\n            AfterRender (As t)\n\n    /// Synchronizes an element node (deep).\n    and [<MethodImpl(MethodImplOptions.NoInlining)>] SyncElemNode el =\n        SyncElement el\n        Sync el.Children\n        AfterRender el\n\n    /// A set of node element nodes.\n    type NodeSet =\n        | NodeSet of HashSet<DocElemNode>\n\n        /// Filters out only nodes that have on-remove animations.\n        static member Filter f (NodeSet set) =\n            NodeSet (HashSet.Filter f set)\n\n        /// Finds all node elements in a tree.\n        static member FindAll doc =\n            let q = Queue()\n            let rec loop node =\n                match node with\n                | AppendDoc (a, b) -> loop a; loop b\n                | ElemDoc el -> loopEN el\n                | EmbedDoc em -> loop em.Current\n                | TreeDoc t -> t.Holes |> Array.iter loopEN\n                | _ -> ()\n            and loopEN el =\n                q.Enqueue el\n                loop el.Children\n            loop doc\n            NodeSet (HashSet q)\n\n        /// Set difference.\n        static member Except (NodeSet excluded) (NodeSet included) =\n            NodeSet (included |> HashSet.Except excluded)\n\n        /// Set intersection.\n        static member Intersect (NodeSet a) (NodeSet b) =\n            NodeSet (HashSet.Intersect a b)\n\n        /// Checks if empty.\n        static member IsEmpty (NodeSet ns) =\n            ns.Count = 0\n\n        /// The empty set.\n        static member Empty =\n            NodeSet (HashSet ())\n\n        /// Converts to array.\n        static member ToArray (NodeSet ns) =\n            HashSet.ToArray ns\n\n    /// State of the Doc.Run (updator) proces.\n    type RunState =\n        {\n            mutable PreviousNodes : NodeSet\n            Top : DocElemNode\n        }\n\n    /// Creates an element node.\n    let CreateElemNode el attr children =\n        LinkElement el children\n        let attr = Attrs.Insert el attr\n        {\n            Attr = attr\n            Children = children\n            Delimiters = None\n            El = el\n            ElKey = Fresh.Int ()\n            Render = Attrs.GetOnAfterRender attr\n        }\n\n    /// Creates an element node that handles a delimited subset of its children.\n    let CreateDelimitedElemNode (ldelim: Node) (rdelim: Node) attr children =\n        let el = ldelim.ParentNode :?> Dom.Element\n        LinkPrevElement rdelim children\n        let attr = Attrs.Insert el attr\n        {\n            Attr = attr\n            Children = children\n            Delimiters = Some (ldelim, rdelim)\n            El = el\n            ElKey = Fresh.Int ()\n            Render = Attrs.GetOnAfterRender attr\n        }\n\n    /// Creates a new RunState.\n    let CreateRunState parent doc =\n        {\n            PreviousNodes = NodeSet.Empty\n            Top = CreateElemNode parent Attr.Empty doc\n        }\n\n    /// Creates a new RunState for a delimited subset of the children of a node.\n    let CreateDelimitedRunState ldelim rdelim doc =\n        {\n            PreviousNodes = NodeSet.Empty\n            Top = CreateDelimitedElemNode ldelim rdelim Attr.Empty doc\n        }\n\n    /// Computes the animation of nodes that animate removal.\n    let ComputeExitAnim st cur =\n        st.PreviousNodes\n        |> NodeSet.Filter (fun n -> Attrs.HasExitAnim n.Attr)\n        |> NodeSet.Except cur\n        |> NodeSet.ToArray\n        |> Array.map (fun n -> Attrs.GetExitAnim n.Attr)\n        |> Anim.Concat\n\n    /// Computes the animation for changed nodes.\n    let ComputeChangeAnim st cur =\n        let relevant = NodeSet.Filter (fun n -> Attrs.HasChangeAnim n.Attr)\n        NodeSet.Intersect (relevant st.PreviousNodes) (relevant cur)\n        |> NodeSet.ToArray\n        |> Array.map (fun n -> Attrs.GetChangeAnim n.Attr)\n        |> Anim.Concat\n\n    /// Computes the animation for entering nodes.\n    let ComputeEnterAnim st cur =\n        cur\n        |> NodeSet.Filter (fun n -> Attrs.HasEnterAnim n.Attr)\n        |> NodeSet.Except st.PreviousNodes\n        |> NodeSet.ToArray\n        |> Array.map (fun n -> Attrs.GetEnterAnim n.Attr)\n        |> Anim.Concat\n\n    let SyncElemNodesNextFrame st = \n        Async.FromContinuations <| fun (ok, _, _) ->\n            JS.RequestAnimationFrame (fun _ ->\n                SyncElemNode st.Top\n                ok()\n            ) |> ignore\n\n    /// The main function: how to perform an animated top-level document update.\n    let PerformAnimatedUpdate st doc =\n        if Anim.UseAnimations then\n            async {\n                let cur = NodeSet.FindAll doc\n                let change = ComputeChangeAnim st cur\n                let enter = ComputeEnterAnim st cur\n                let exit = ComputeExitAnim st cur\n                do! Anim.Play (Anim.Append change exit)\n                do! SyncElemNodesNextFrame st\n                do! Anim.Play enter\n                return st.PreviousNodes <- cur\n            }\n        else\n            SyncElemNodesNextFrame st\n\n    /// EmbedNode constructor.\n    [<MethodImpl(MethodImplOptions.NoInlining)>]\n    let CreateEmbedNode () =\n        {\n            Current = EmptyDoc\n            Dirty = false\n        }\n\n    /// EmbedNode update (marks dirty).\n    [<MethodImpl(MethodImplOptions.NoInlining)>]\n    let UpdateEmbedNode node upd =\n        node.Current <- upd\n        node.Dirty <- true\n\n    /// Text node constructor.\n    [<MethodImpl(MethodImplOptions.NoInlining)>]\n    let CreateTextNode () =\n        {\n            Dirty = false\n            Text = DU.CreateText \"\"\n            Value = \"\"\n        }\n\n    /// Text node update (marks dirty).\n    [<MethodImpl(MethodImplOptions.NoInlining)>]\n    let UpdateTextNode n t =\n        n.Value <- t\n        n.Dirty <- true\n\n    let LoadedTemplates = Dictionary<string, Dom.Element>()\n\n    let TextHoleRE = \"\"\"\\${([^}]+)}\"\"\"\n\n// We implement the Doc interface, the Doc module proxy and the Client.Doc module proxy\n// all in this so that it all neatly looks like Doc.* in javascript.\n[<Name \"WebSharper.UI.Next.Doc\"; Proxy(typeof<Doc>)>]\n[<CompilationRepresentation(CompilationRepresentationFlags.ModuleSuffix)>]\ntype private Doc' [<JavaScript>] (docNode, updates) =\n\n    [<JavaScript; Inline>]\n    member this.DocNode = docNode\n    [<JavaScript; Inline>]\n    member this.Updates = updates\n\n    interface IControlBody with\n\n        [<JavaScript>]\n        member this.ReplaceInDom(elt) =\n            // Insert empty text nodes that will serve as delimiters for the Doc.\n            let rdelim = JS.Document.CreateTextNode \"\"\n            elt.ParentNode.ReplaceChild(rdelim, elt) |> ignore\n            Doc'.RunBefore rdelim this\n\n    [<JavaScript; MethodImpl(MethodImplOptions.NoInlining)>]\n    static member Mk node updates =\n        Doc'(node, updates)\n\n    [<JavaScript; Name \"Append\">]\n    static member Append' (a: Doc') (b: Doc') =\n        (a.Updates, b.Updates)\n        ||> View.Map2Unit\n        |> Doc'.Mk (AppendDoc (a.DocNode, b.DocNode))\n\n    [<JavaScript; Name \"Concat\">]\n    static member Concat' xs =\n        Array.ofSeqNonCopying xs\n        |> Array.TreeReduce Doc'.Empty' Doc'.Append'\n\n    [<JavaScript; Name \"Empty\">]\n    static member Empty'\n        with [<MethodImpl(MethodImplOptions.NoInlining)>] get () =\n            Doc'.Mk EmptyDoc (View.Const ())\n\n    [<JavaScript; Inline>]\n    static member Elem el attr (children: Doc') =\n        As<Elt> (Elt'.New(el, attr, children))\n\n    [<JavaScript; Name \"TextNode\">]\n    static member TextNode' v =\n        Doc'.Mk (TextNodeDoc (DU.CreateText v)) (View.Const ())\n\n    [<JavaScript>]\n    static member Static el : Elt =\n        Doc'.Elem el Attr.Empty Doc'.Empty'\n\n    [<JavaScript; Name \"Verbatim\">]\n    static member Verbatim' html =\n        let a =\n            match JQuery.JQuery.ParseHTML html with\n            | null -> [||]\n            | a -> a\n        let elem (n: Dom.Node) =\n            if n.NodeType = Dom.NodeType.Text then\n                TextNodeDoc (n :?> Dom.Text)\n            else\n                ElemDoc (Docs.CreateElemNode (n :?> Element) Attr.Empty EmptyDoc)\n        let append x y = AppendDoc (x, y)\n        let es = Array.MapTreeReduce elem EmptyDoc append a\n        Doc'.Mk es (View.Const ())\n\n    [<JavaScript>]\n    static member EmbedView (view: View<Doc'>) =\n        let node = Docs.CreateEmbedNode ()\n        view\n        |> View.Bind (fun doc ->\n            Docs.UpdateEmbedNode node doc.DocNode\n            doc.Updates)\n        |> View.Map ignore\n        |> Doc'.Mk (EmbedDoc node)\n\n    [<JavaScript>]\n    static member BindView (f: 'T -> Doc') (view: View<'T>) =\n        Doc'.EmbedView (View.Map f view)\n\n    [<JavaScript>]\n    static member Async (a: Async<Doc'>) : Doc' =\n        View.Const a\n        |> View.MapAsync id\n        |> Doc'.EmbedView\n\n    [<JavaScript>]\n    static member RunBetween ldelim rdelim (doc: Doc') =\n        Docs.LinkPrevElement rdelim doc.DocNode\n        let st = Docs.CreateDelimitedRunState ldelim rdelim doc.DocNode\n        let p = Mailbox.StartProcessor (Docs.PerformAnimatedUpdate st doc.DocNode)\n        View.Sink p doc.Updates\n\n    [<JavaScript>]\n    static member RunBefore (rdelim: Dom.Node) (doc: Doc') =\n        let ldelim = JS.Document.CreateTextNode(\"\")\n        rdelim.ParentNode.InsertBefore(ldelim, rdelim) |> ignore\n        Doc'.RunBetween ldelim rdelim doc\n\n    [<JavaScript>]\n    static member RunBeforeById id doc =\n        match DU.Doc.GetElementById(id) with\n        | null -> failwith (\"invalid id: \" + id)\n        | el -> Doc'.RunBefore el doc\n\n    [<JavaScript>]\n    static member RunAfter (ldelim : Dom.Node) (doc: Doc') =\n        let rdelim = JS.Document.CreateTextNode(\"\")\n        ldelim.ParentNode.InsertBefore(rdelim, ldelim.NextSibling) |> ignore\n        Doc'.RunBetween ldelim rdelim doc\n\n    [<JavaScript>]\n    static member RunAfterById id doc =\n        match DU.Doc.GetElementById(id) with\n        | null -> failwith (\"invalid id: \" + id)\n        | el -> Doc'.RunAfter el doc\n\n    [<JavaScript>]\n    static member RunAppend (parent: Dom.Element) (doc: Doc') =\n        let rdelim = JS.Document.CreateTextNode \"\"\n        parent.AppendChild(rdelim) |> ignore\n        Doc'.RunBefore rdelim doc\n\n    [<JavaScript>]\n    static member RunAppendById id doc =\n        match DU.Doc.GetElementById(id) with\n        | null -> failwith (\"invalid id: \" + id)\n        | el -> Doc'.RunAppend el doc\n\n    [<JavaScript>]\n    static member RunPrepend (parent: Dom.Element) (doc: Doc') =\n        let rdelim = JS.Document.CreateTextNode \"\"\n        parent.InsertBefore(rdelim, parent.FirstChild) |> ignore\n        Doc'.RunBefore rdelim doc\n\n    [<JavaScript>]\n    static member RunPrependById id doc =\n        match DU.Doc.GetElementById(id) with\n        | null -> failwith (\"invalid id: \" + id)\n        | el -> Doc'.RunPrepend el doc\n\n    [<JavaScript>]\n    static member Run parent (doc: Doc') =\n        let d = doc.DocNode\n        Docs.LinkElement parent d\n        let st = Docs.CreateRunState parent d\n        let p = Mailbox.StartProcessor (Docs.PerformAnimatedUpdate st d)\n        View.Sink p doc.Updates\n\n    [<JavaScript>]\n    static member RunById id tr =\n        match DU.Doc.GetElementById(id) with\n        | null -> failwith (\"invalid id: \" + id)\n        | el -> Doc'.Run el tr\n\n    [<JavaScript>]\n    static member RunReplaceById id (tr: Doc') =\n        match DU.Doc.GetElementById(id) with\n        | null -> failwith (\"invalid id: \" + id)\n        | el -> (tr :> IControlBody).ReplaceInDom(el)\n\n    [<JavaScript>]\n    static member TextView txt =\n        let node = Docs.CreateTextNode ()\n        txt\n        |> View.Map (Docs.UpdateTextNode node)\n        |> Doc'.Mk (TextDoc node)\n\n    [<JavaScript>]\n    static member Template (els: Node[]) (fillWith: seq<TemplateHole>) =\n        Doc'.ChildrenTemplate (Doc'.FakeRoot els) fillWith\n\n    [<JavaScript>]\n    static member ChildrenTemplate (el: Element) (fillWith: seq<TemplateHole>) =\n        let holes : DocElemNode[] = [||]\n        let updates : View<unit>[] = [||]\n        let attrs : (Element * Attrs.Dyn)[] = [||]\n        let afterRender : (Element -> unit)[] = [||]\n        let fw = Dictionary()\n        for x in fillWith do fw.[TemplateHole.Name x] <- x\n        let els = As<Union<Dom.Node, DocNode>[]> (DomUtility.ChildrenArray el)\n        let addAttr (el: Element) (attr: Attr) =\n            let attr = Attrs.Insert el attr\n            updates.JS.Push (Attrs.Updates attr) |> ignore\n            attrs.JS.Push ((el, attr)) |> ignore\n            Attrs.GetOnAfterRender attr |> Option.iter (fun f ->\n                afterRender.JS.Push(fun _ -> f el) |> ignore)\n        let tryGetAsDoc name =\n            match fw.TryGetValue(name) with\n            | true, TemplateHole.Elt (_, doc) -> Some (As<Doc'> doc)\n            | true, TemplateHole.Text (_, text) -> Some (Doc'.TextNode' text)\n            | true, TemplateHole.TextView (_, tv) -> Some (Doc'.TextView tv)\n            | true, TemplateHole.VarStr (_, v) -> Some (Doc'.TextView v.View)\n            | true, TemplateHole.VarBool (_, v) -> Some (Doc'.TextView (v.View.Map string))\n            | true, TemplateHole.VarInt (_, v) -> Some (Doc'.TextView (v.View.Map (fun i -> i.Input)))\n            | true, TemplateHole.VarIntUnchecked (_, v) -> Some (Doc'.TextView (v.View.Map string))\n            | true, TemplateHole.VarFloat (_, v) -> Some (Doc'.TextView (v.View.Map (fun i -> i.Input)))\n            | true, TemplateHole.VarFloatUnchecked (_, v) -> Some (Doc'.TextView (v.View.Map string))\n            | true, _ -> Console.Warn(\"Content hole filled with attribute data\", name); None\n            | false, _ -> None\n\n        DomUtility.IterSelector el \"[ws-hole]\" <| fun p ->\n            let name = p.GetAttribute(\"ws-hole\")\n            p.RemoveAttribute(\"ws-hole\")\n            while (p.HasChildNodes()) do\n                p.RemoveChild(p.LastChild) |> ignore\n            match tryGetAsDoc name with\n            | None -> ()\n            | Some doc ->\n                Docs.LinkElement p doc.DocNode\n                holes.JS.Push {\n                    Attr = Attrs.Empty p\n                    Children = doc.DocNode\n                    Delimiters = None\n                    El = p\n                    ElKey = Fresh.Int()\n                    Render = None\n                }\n                |> ignore\n                updates.JS.Push doc.Updates |> ignore\n\n        DomUtility.IterSelector el \"[ws-replace]\" <| fun e ->\n            let name = e.GetAttribute(\"ws-replace\")\n            match tryGetAsDoc name with\n            | None -> ()\n            | Some doc ->\n                let p = e.ParentNode :?> Dom.Element\n                let after = JS.Document.CreateTextNode(\"\") :> Dom.Node\n                p.ReplaceChild(after, e) |> ignore\n                let before = Docs.InsertBeforeDelim after doc.DocNode\n                els\n                |> Array.tryFindIndex ((===.) e)\n                |> Option.iter (fun i -> els.[i] <- Union2Of2 doc.DocNode)\n                holes.JS.Push {\n                    Attr = Attrs.Empty p\n                    Children = doc.DocNode\n                    Delimiters = Some (before, after)\n                    El = p\n                    ElKey = Fresh.Int()\n                    Render = None\n                }\n                |> ignore\n                updates.JS.Push doc.Updates |> ignore\n\n        DomUtility.IterSelector el \"[ws-attr]\" <| fun e ->\n            let name = e.GetAttribute(\"ws-attr\")\n            e.RemoveAttribute(\"ws-attr\")\n            match fw.TryGetValue(name) with\n            | true, TemplateHole.Attribute (_, attr) -> addAttr e attr\n            | true, _ -> Console.Warn(\"Attribute hole filled with non-attribute data\", name)\n            | false, _ -> ()\n\n        DomUtility.IterSelector el \"[ws-on]\" <| fun e ->\n            e.GetAttribute(\"ws-on\").Split([|' '|], StringSplitOptions.RemoveEmptyEntries)\n            |> Array.choose (fun x ->\n                let a = x.Split([|':'|], StringSplitOptions.RemoveEmptyEntries)\n                match fw.TryGetValue(a.[1]) with\n                | true, TemplateHole.Event (_, handler) -> Some (Attr.Handler a.[0] handler)\n                | true, _ ->\n                    Console.Warn(\"Event hole on\" + a.[0] + \" filled with non-event data\", a.[1])\n                    None\n                | false, _ -> None\n            )\n            |> Attr.Concat\n            |> addAttr e\n            e.RemoveAttribute(\"ws-on\")\n\n        DomUtility.IterSelector el \"[ws-onafterrender]\" <| fun e ->\n            let name = e.GetAttribute(\"ws-onafterrender\")\n            match fw.TryGetValue(name) with\n            | true, TemplateHole.AfterRender (_, handler) ->\n                e.RemoveAttribute(\"ws-onafterrender\")\n                addAttr e (Attr.OnAfterRender handler)\n            | true, _ -> Console.Warn(\"onafterrender hole filled with non-onafterrender data\", name)\n            | false, _ -> ()\n\n        DomUtility.IterSelector el \"[ws-var]\" <| fun e ->\n            let name = e.GetAttribute(\"ws-var\")\n            e.RemoveAttribute(\"ws-var\")\n            match fw.TryGetValue(name) with\n            | true, TemplateHole.VarStr (_, var) -> addAttr e (Attr.Value var)\n            | true, TemplateHole.VarBool (_, var) -> addAttr e (Attr.Checked var)\n            | true, TemplateHole.VarInt (_, var) -> addAttr e (Attr.IntValue var)\n            | true, TemplateHole.VarIntUnchecked (_, var) -> addAttr e (Attr.IntValueUnchecked var)\n            | true, TemplateHole.VarFloat (_, var) -> addAttr e (Attr.FloatValue var)\n            | true, TemplateHole.VarFloatUnchecked (_, var) -> addAttr e (Attr.FloatValueUnchecked var)\n            | true, _ -> Console.Warn(\"Var hole filled with non-Var data\", name)\n            | false, _ -> ()\n\n        DomUtility.IterSelector el \"[ws-attr-holes]\" <| fun e ->\n            let re = new RegExp(Docs.TextHoleRE, \"g\")\n            let holeAttrs = e.GetAttribute(\"ws-attr-holes\").Split([|' '|], StringSplitOptions.RemoveEmptyEntries)\n            e.RemoveAttribute(\"ws-attr-holes\")\n            for attrName in holeAttrs do\n                let s = e.GetAttribute(attrName)\n                let mutable m = null\n                let mutable lastIndex = 0\n                let res : (string * string)[] = [||]\n                while (m <- re.Exec s; m !==. null) do\n                    let textBefore = s.[lastIndex .. re.LastIndex-m.[0].Length-1]\n                    lastIndex <- re.LastIndex\n                    let holeName = m.[1]\n                    res.JS.Push((textBefore, holeName)) |> ignore\n                let finalText = s.[lastIndex..]\n                re.LastIndex <- 0\n                let value =\n                    Array.foldBack (fun (textBefore, holeName: string) (textAfter, views) ->\n                        let holeContent =\n                            match fw.TryGetValue(holeName) with\n                            | true, TemplateHole.Text (_, t) -> Choice1Of2 t\n                            | true, TemplateHole.TextView (_, v) -> Choice2Of2 v\n                            | true, TemplateHole.VarStr (_, v) -> Choice2Of2 v.View\n                            | true, TemplateHole.VarBool (_, v) -> Choice2Of2 (v.View.Map string)\n                            | true, TemplateHole.VarInt (_, v) -> Choice2Of2 (v.View.Map (fun i -> i.Input))\n                            | true, TemplateHole.VarIntUnchecked (_, v) -> Choice2Of2 (v.View.Map string)\n                            | true, TemplateHole.VarFloat (_, v) -> Choice2Of2 (v.View.Map (fun i -> i.Input))\n                            | true, TemplateHole.VarFloatUnchecked (_, v) -> Choice2Of2 (v.View.Map string)\n                            | true, _ ->\n                                Console.Warn(\"Attribute value hole filled with non-text data\", holeName)\n                                Choice1Of2 \"\"\n                            | false, _ -> Choice1Of2 \"\"\n                        match holeContent with\n                        | Choice1Of2 text -> textBefore + text + textAfter, views\n                        | Choice2Of2 v ->\n                            let v =\n                                if textAfter = \"\" then v else\n                                View.Map (fun s -> s + textAfter) v\n                            textBefore, v :: views\n                    ) res (finalText, [])\n                match value with\n                | s, [] -> Attr.Create attrName s\n                | \"\", [v] -> Attr.Dynamic attrName v\n                | s, [v] -> Attr.Dynamic attrName (View.Map (fun v -> s + v) v)\n                | s, [v1; v2] -> Attr.Dynamic attrName (View.Map2 (fun v1 v2 -> s + v1 + v2) v1 v2)\n                | s, [v1; v2; v3] -> Attr.Dynamic attrName (View.Map3 (fun v1 v2 v3 -> s + v1 + v2 + v3) v1 v2 v3)\n                | s, vs ->\n                    View.Sequence vs\n                    |> View.Map (fun vs -> s + String.concat \"\" vs)\n                    |> Attr.Dynamic attrName\n                |> addAttr e\n\n        let docTreeNode : DocTreeNode =\n            {\n                Els = els\n                Holes = holes\n                Attrs = attrs\n                Render =\n                    if Array.isEmpty afterRender\n                    then None\n                    else Some (fun el -> Array.iter (fun f -> f el) afterRender)\n                Dirty = true\n            }\n        let updates =\n            updates |> Array.TreeReduce (View.Const ()) View.Map2Unit\n\n        match els with\n        | [| Union1Of2 e |] when e.NodeType = Dom.NodeType.Element ->\n            Elt'.TreeNode(docTreeNode, updates) :> Doc'\n        | _ ->\n            Doc'.Mk (TreeDoc docTreeNode) updates\n\n    [<JavaScript>]\n    static member FakeRoot (els: Node[]) =\n        let fakeroot = JS.Document.CreateElement(\"div\")\n        for el in els do fakeroot.AppendChild el |> ignore\n        fakeroot\n\n    [<JavaScript>]\n    static member PrepareSingleTemplate (baseName: string) (name: option<string>) (el: Element) =\n        el.RemoveAttribute(\"ws-template\")\n        match el.GetAttribute(\"ws-replace\") with\n        | null -> ()\n        | replace ->\n            el.RemoveAttribute(\"ws-replace\")\n            match el.ParentNode with\n            | null -> ()\n            | p ->\n                let n = JS.Document.CreateElement(el.TagName)\n                n.SetAttribute(\"ws-replace\", replace)\n                p.ReplaceChild(n, el) |> ignore\n        Doc'.PrepareTemplateStrict baseName name [| el |]\n\n    [<JavaScript>]\n    static member ComposeName baseName name =\n        (baseName + \"/\" + defaultArg name \"\").ToLower()\n\n    [<JavaScript>]\n    static member PrepareTemplateStrict (baseName: string) (name: option<string>) (els: Node[]) =\n        let convertAttrs (el: Dom.Element) =\n            let attrs = el.Attributes\n            let toRemove = [||]\n            let events = [||]\n            let holedAttrs = [||]\n            for i = 0 to attrs.Length - 1 do\n                let a = attrs.[i]\n                if a.NodeName.StartsWith \"ws-on\" && a.NodeName <> \"ws-onafterrender\" && a.NodeName <> \"ws-on\" then\n                    toRemove.JS.Push(a.NodeName) |> ignore\n                    events.JS.Push(a.NodeName.[\"ws-on\".Length..] + \":\" + a.NodeValue.ToLower()) |> ignore\n                elif not (a.NodeName.StartsWith \"ws-\") && RegExp(Docs.TextHoleRE).Test(a.NodeValue) then\n                    a.NodeValue <-\n                        RegExp(Docs.TextHoleRE, \"g\")\n                            .Replace(a.NodeValue, FuncWithArgs (fun (_, h: string) ->\n                                \"${\" + h.ToLower() + \"}\"))\n                    holedAttrs.JS.Push(a.NodeName) |> ignore\n            if not (Array.isEmpty events) then\n                el.SetAttribute(\"ws-on\", String.concat \" \" events)\n            if not (Array.isEmpty holedAttrs) then\n                el.SetAttribute(\"ws-attr-holes\", String.concat \" \" holedAttrs)\n            let lowercaseAttr name =\n                match el.GetAttribute(name) with\n                | null -> ()\n                | x -> el.SetAttribute(name, x.ToLower())\n            lowercaseAttr \"ws-hole\"\n            lowercaseAttr \"ws-replace\"\n            lowercaseAttr \"ws-attr\"\n            lowercaseAttr \"ws-onafterrender\"\n            lowercaseAttr \"ws-var\"\n            Array.iter el.RemoveAttribute toRemove\n\n        let convertTextNode (n: Dom.Node) =\n            let mutable m = null\n            let mutable li = 0\n            let s = n.TextContent\n            let strRE = RegExp(Docs.TextHoleRE, \"g\")\n            while (m <- strRE.Exec s; m !==. null) do\n                n.ParentNode.InsertBefore(JS.Document.CreateTextNode(s.[li..strRE.LastIndex-m.[0].Length-1]), n) |> ignore\n                li <- strRE.LastIndex\n                let hole = JS.Document.CreateElement(\"span\")\n                hole.SetAttribute(\"ws-replace\", m.[1].ToLower())\n                n.ParentNode.InsertBefore(hole, n) |> ignore\n            strRE.LastIndex <- 0\n            n.TextContent <- s.[li..]\n\n        let mapHoles (t: Dom.Element) (mappings: Dictionary<string, string>) =\n            let run attrName =\n                DomUtility.IterSelector t (\"[\" + attrName + \"]\") <| fun e ->\n                    match mappings.TryGetValue(e.GetAttribute(attrName).ToLower()) with\n                    | true, m -> e.SetAttribute(attrName, m)\n                    | false, _ -> ()\n            run \"ws-hole\"\n            run \"ws-replace\"\n            run \"ws-attr\"\n            run \"ws-onafterrender\"\n            run \"ws-var\"\n            DomUtility.IterSelector t \"[ws-on]\" <| fun e ->\n                let a =\n                    e.GetAttribute(\"ws-on\").Split([|' '|], StringSplitOptions.RemoveEmptyEntries)\n                    |> Array.map (fun x ->\n                        let a = x.Split([|':'|], StringSplitOptions.RemoveEmptyEntries)\n                        match mappings.TryGetValue(a.[1]) with\n                        | true, x -> a.[0] + \":\" + x\n                        | false, _ -> x\n                    )\n                    |> String.concat \" \"\n                e.SetAttribute(\"ws-on\", a)\n            DomUtility.IterSelector t \"[ws-attr-holes]\" <| fun e ->\n                let holeAttrs = e.GetAttribute(\"ws-attr-holes\").Split([|' '|], StringSplitOptions.RemoveEmptyEntries)\n                for attrName in holeAttrs do\n                    let s =\n                        (e.GetAttribute(attrName), mappings)\n                        ||> Seq.fold (fun s (KeyValue(a, m)) ->\n                            RegExp(\"\\\\${\" + a + \"}\", \"ig\").Replace(s, \"${\" + m + \"}\")\n                        )\n                    e.SetAttribute(attrName, s)\n\n        let fillInstanceAttrs (instance: Dom.Element) (fillWith: Dom.Element) =\n            convertAttrs fillWith\n            let name = fillWith.NodeName.ToLower()\n            match instance.QuerySelector(\"[ws-attr=\" + name + \"]\") with\n            | null -> Console.Warn(\"Filling non-existent attr hole\", name)\n            | e ->\n                e.RemoveAttribute(\"ws-attr\")\n                for i = 0 to fillWith.Attributes.Length - 1 do\n                    let a = fillWith.Attributes.[i]\n                    if a.Name = \"class\" && e.HasAttribute(\"class\") then\n                        e.SetAttribute(\"class\", e.GetAttribute(\"class\") + \" \" + a.NodeValue)\n                    else\n                        e.SetAttribute(a.Name, a.NodeValue)\n\n        let removeHolesExcept (instance: Dom.Element) (dontRemove: HashSet<string>) =\n            let run attrName =\n                DomUtility.IterSelector instance (\"[\" + attrName + \"]\") <| fun e ->\n                    if not (dontRemove.Contains(e.GetAttribute attrName)) then\n                        e.RemoveAttribute(attrName)\n            run \"ws-attr\"\n            run \"ws-onafterrender\"\n            run \"ws-var\"\n            DomUtility.IterSelector instance \"[ws-hole]\" <| fun e ->\n                if not (dontRemove.Contains(e.GetAttribute \"ws-hole\")) then\n                    e.RemoveAttribute(\"ws-hole\")\n                    while e.HasChildNodes() do\n                        e.RemoveChild(e.LastChild) |> ignore\n            DomUtility.IterSelector instance \"[ws-replace]\" <| fun e ->\n                if not (dontRemove.Contains(e.GetAttribute \"ws-replace\")) then\n                    e.ParentNode.RemoveChild(e) |> ignore\n            DomUtility.IterSelector instance \"[ws-on]\" <| fun e ->\n                let a =\n                    e.GetAttribute(\"ws-on\").Split([|' '|], StringSplitOptions.RemoveEmptyEntries)\n                    |> Array.filter (fun x ->\n                        let a = x.Split([|':'|], StringSplitOptions.RemoveEmptyEntries)\n                        dontRemove.Contains a.[1]\n                    )\n                    |> String.concat \" \"\n                e.SetAttribute(\"ws-on\", a)\n            DomUtility.IterSelector instance \"[ws-attr-holes]\" <| fun e ->\n                let holeAttrs = e.GetAttribute(\"ws-attr-holes\").Split([|' '|], StringSplitOptions.RemoveEmptyEntries)\n                for attrName in holeAttrs do\n                    let s =\n                        RegExp(Docs.TextHoleRE, \"g\")\n                            .Replace(e.GetAttribute(attrName), FuncWithArgs(fun (full: string, h: string) ->\n                                if dontRemove.Contains h then full else \"\"\n                            ))\n                    e.SetAttribute(attrName, s)\n\n        let fillTextHole (instance: Dom.Element) (fillWith: string) =\n            match instance.QuerySelector \"[ws-replace]\" with\n            | null ->\n                Console.Warn(\"Filling non-existent text hole\", name)\n                None\n            | n ->\n                n.ParentNode.ReplaceChild(Dom.Text fillWith, n) |> ignore\n                Some <| n.GetAttribute(\"ws-replace\")\n\n        let rec fill (fillWith: Dom.Element) (p: Dom.Node) n =\n            if fillWith.HasChildNodes() then\n                fill fillWith p (p.InsertBefore(fillWith.LastChild, n))\n\n        let rec fillDocHole (instance: Dom.Element) (fillWith: Dom.Element) =\n            let name = fillWith.NodeName.ToLower()\n            let fillHole (p: Dom.Node) (n: Dom.Node) =\n                // The \"title\" node is treated specially by HTML, its content is considered pure text,\n                // so we need to re-parse it.\n                if name = \"title\" && fillWith.HasChildNodes() then\n                    let parsed = JQuery.JQuery.ParseHTML fillWith.TextContent\n                    fillWith.RemoveChild(fillWith.FirstChild) |> ignore\n                    for i in parsed do\n                        fillWith.AppendChild(i) |> ignore\n                convertElement fillWith\n                fill fillWith p n\n            DomUtility.IterSelector instance \"[ws-attr-holes]\" <| fun e ->\n                let holeAttrs = e.GetAttribute(\"ws-attr-holes\").Split([|' '|], StringSplitOptions.RemoveEmptyEntries)\n                for attrName in holeAttrs do\n                    e.SetAttribute(attrName,\n                        RegExp(\"\\\\${\" + name + \"}\", \"ig\").\n                            Replace(e.GetAttribute(attrName), fillWith.TextContent)\n                    )\n            match instance.QuerySelector(\"[ws-hole=\" + name + \"]\") with\n            | null ->\n                match instance.QuerySelector(\"[ws-replace=\" + name + \"]\") with\n                | null -> ()\n                | e ->\n                    fillHole e.ParentNode e\n                    e.ParentNode.RemoveChild(e) |> ignore\n            | e ->\n                while e.HasChildNodes() do\n                    e.RemoveChild(e.LastChild) |> ignore\n                e.RemoveAttribute(\"ws-hole\")\n                fillHole e null\n\n        and convertInstantiation (el: Dom.Element) =\n            let name = el.NodeName.[3..].ToLower()\n            let name =\n                match name.IndexOf('.') with\n                | -1 -> baseName + \"/\" + name\n                | _ -> name.Replace(\".\", \"/\")\n            if not (Docs.LoadedTemplates.ContainsKey name) then\n                Console.Warn(\"Instantiating non-loaded template\", name)\n            else\n                let t = Docs.LoadedTemplates.[name]\n//            match Docs.LoadedTemplates.TryGetValue name with\n//            | false, _ -> Console.Warn(\"Instantiating non-loaded template\", name)\n//            | true, (t: Dom.Element) ->\n                let instance = t.CloneNode(true) :?> Dom.Element\n                let usedHoles = HashSet()\n                let mappings = Dictionary()\n                // 1. gather mapped and filled holes.\n                let attrs = el.Attributes\n                for i = 0 to attrs.Length - 1 do\n                    let name = attrs.[i].Name.ToLower()\n                    let mappedName = match attrs.[i].NodeValue with \"\" -> name | s -> s.ToLower()\n                    mappings.[name] <- mappedName\n                    if not (usedHoles.Add(name)) then\n                        Console.Warn(\"Hole mapped twice\", name)\n                for i = 0 to el.ChildNodes.Length - 1 do\n                    let n = el.ChildNodes.[i]\n                    if n.NodeType = Dom.NodeType.Element then\n                        let n = n :?> Dom.Element\n                        if not (usedHoles.Add(n.NodeName.ToLower())) then\n                            Console.Warn(\"Hole filled twice\", name)\n                // 2. If single text hole, apply it.\n                let singleTextFill = el.ChildNodes.Length = 1 && el.FirstChild.NodeType = Dom.NodeType.Text\n                if singleTextFill then\n                    fillTextHole instance el.FirstChild.TextContent\n                    |> Option.iter (usedHoles.Add >> ignore)\n                // 3. eliminate non-mapped/filled holes.\n                removeHolesExcept instance usedHoles\n                // 4. apply mappings/fillings.\n                if not singleTextFill then\n                    for i = 0 to el.ChildNodes.Length - 1 do\n                        let n = el.ChildNodes.[i]\n                        if n.NodeType = Dom.NodeType.Element then\n                            let n = n :?> Dom.Element\n                            if n.HasAttributes() then\n                                fillInstanceAttrs instance n\n                            else\n                                fillDocHole instance n\n                mapHoles instance mappings\n                // 5. insert result.\n                fill instance el.ParentNode el\n                el.ParentNode.RemoveChild(el) |> ignore\n\n        and convertElement (el: Dom.Element) =\n            if el.NodeName.ToLower().StartsWith \"ws-\" && not (el.HasAttribute \"ws-template\") then\n                convertInstantiation el\n            else\n                convertAttrs el\n                match el.GetAttribute(\"ws-template\") with\n                | null ->\n                    match el.GetAttribute(\"ws-children-template\") with\n                    | null -> convert el el.FirstChild\n                    | name ->\n                        el.RemoveAttribute(\"ws-children-template\")\n                        Doc'.PrepareTemplate baseName (Some name) (fun () -> DomUtility.ChildrenArray el)\n                        // if it was already prepared, the above does nothing, so always clean anyway!\n                        while el.HasChildNodes() do el.RemoveChild(el.LastChild) |> ignore\n                | name -> Doc'.PrepareSingleTemplate baseName (Some name) el\n\n        and convert (p: Element) (n: Node) =\n            if n !==. null then\n                let next = n.NextSibling\n                if n.NodeType = Dom.NodeType.Text then\n                    convertTextNode n\n                elif n.NodeType = Dom.NodeType.Element then\n                    convertElement (n :?> Dom.Element)\n                convert p next\n\n        let fakeroot = Doc'.FakeRoot els\n        Docs.LoadedTemplates.[Doc'.ComposeName baseName name] <- fakeroot\n        if els.Length > 0 then convert fakeroot els.[0]\n\n    [<JavaScript>]\n    static member PrepareTemplate (baseName: string) (name: option<string>) (els: unit -> Node[]) =\n        if not (Docs.LoadedTemplates.ContainsKey(Doc'.ComposeName baseName name)) then\n            let els = els()\n            for el in els do\n                match el.ParentNode :?> Element with\n                | null -> ()\n                | p -> p.RemoveChild(el) |> ignore\n            Doc'.PrepareTemplateStrict baseName name els\n\n    [<JavaScript>]\n    static member LoadLocalTemplates baseName =\n        let rec run () =\n            match JS.Document.QuerySelector \"[ws-template]\" with\n            | null ->\n                match JS.Document.QuerySelector \"[ws-children-template]\" with\n                | null -> ()\n                | n ->\n                    let name = n.GetAttribute \"ws-children-template\"\n                    n.RemoveAttribute \"ws-children-template\"\n                    Doc'.PrepareTemplate baseName (Some name) (fun () -> DomUtility.ChildrenArray n)\n                    run ()\n            | n ->\n                let name = n.GetAttribute \"ws-template\"\n                Doc'.PrepareSingleTemplate baseName (Some name) n\n                run ()\n        run ()\n\n    [<JavaScript>]\n    static member NamedTemplate (baseName: string) (name: option<string>) (fillWith: seq<TemplateHole>) =\n        let name = Doc'.ComposeName baseName name\n        match Docs.LoadedTemplates.TryGetValue name with\n        | true, t -> Doc'.ChildrenTemplate (t.CloneNode(true) :?> Dom.Element) fillWith\n        | false, _ -> Console.Warn(\"Local template doesn't exist\", name); Doc'.Empty'\n\n    [<JavaScript>]\n    static member GetOrLoadTemplate (baseName: string) (name: option<string>) (els: unit -> Node[]) (fillWith: seq<TemplateHole>) =\n        Doc'.PrepareTemplate baseName name els\n        Doc'.NamedTemplate baseName name fillWith\n\n    [<JavaScript>]\n    static member Flatten view =\n        view\n        |> View.Map Doc'.Concat'\n        |> Doc'.EmbedView\n\n    [<JavaScript>]\n    static member Convert render view =\n        View.MapSeqCached render view |> Doc'.Flatten\n\n    [<JavaScript>]\n    static member ConvertBy key render view =\n        View.MapSeqCachedBy key render view |> Doc'.Flatten\n\n    [<JavaScript>]\n    static member ConvertSeq render view =\n        View.MapSeqCachedView render view |> Doc'.Flatten\n\n    [<JavaScript>]\n    static member ConvertSeqBy key render view =\n        View.MapSeqCachedViewBy key (As render) view |> Doc'.Flatten\n\n    [<JavaScript>]\n    static member InputInternal elemTy attr =\n        let el = DU.CreateElement elemTy\n        Doc'.Elem el (Attr.Concat (attr el)) Doc'.Empty'\n\n    [<JavaScript>]\n    static member Input attr (var: IRef<string>) =\n        Doc'.InputInternal \"input\" (fun _ ->\n            Seq.append attr [| Attr.Value var |])\n\n    [<JavaScript>]\n    static member PasswordBox attr (var: IRef<string>) =\n        Doc'.InputInternal \"input\" (fun _ ->\n            Seq.append attr [|\n                Attr.Value var\n                Attr.Create \"type\" \"password\"\n            |])\n\n    [<JavaScript>]\n    static member IntInputUnchecked attr (var: IRef<int>) =\n        Doc'.InputInternal \"input\" (fun _ ->\n            Seq.append attr [|\n                (if var.Get() = 0 then Attr.Create \"value\" \"0\" else Attr.Empty)\n                Attr.IntValueUnchecked var\n                Attr.Create \"type\" \"number\"\n            |])\n\n    [<JavaScript>]\n    static member IntInput attr (var: IRef<CheckedInput<int>>) =\n        Doc'.InputInternal \"input\" (fun el ->\n            Seq.append attr [|\n                Attr.IntValue var\n                Attr.Create \"type\" \"number\"\n            |])\n\n    [<JavaScript>]\n    static member FloatInputUnchecked attr (var: IRef<float>) =\n        Doc'.InputInternal \"input\" (fun _ ->\n            Seq.append attr [|\n                (if var.Get() = 0. then Attr.Create \"value\" \"0\" else Attr.Empty)\n                Attr.FloatValueUnchecked var\n                Attr.Create \"type\" \"number\"\n            |])\n\n    [<JavaScript>]\n    static member FloatInput attr (var: IRef<CheckedInput<float>>) =\n        Doc'.InputInternal \"input\" (fun el ->\n            Seq.append attr [|\n                Attr.FloatValue var\n                Attr.Create \"type\" \"number\"\n            |])\n\n    [<JavaScript>]\n    static member InputArea attr (var: IRef<string>) =\n        Doc'.InputInternal \"textarea\" (fun _ ->\n            Seq.append attr [| Attr.Value var |])\n\n    [<JavaScript>]\n    static member SelectImpl attrs (show: 'T -> string) (optionElements) (current: IRef<'T>) =\n        let options = ref []\n        let getIndex (el: Element) =\n            el?selectedIndex : int\n        let setIndex (el: Element) (i: int) =\n            el?selectedIndex <- i\n        let getSelectedItem el =\n            let i = getIndex el\n            (!options).[i]\n        let itemIndex x =\n            List.findIndex ((=) x) !options\n        let setSelectedItem (el: Element) item =\n            setIndex el (itemIndex item)\n        let el = DU.CreateElement \"select\"\n        let selectedItemAttr =\n            current.View\n            |> Attr.DynamicCustom setSelectedItem\n        let onChange (x: DomEvent) =\n            current.UpdateMaybe(fun x ->\n                let y = getSelectedItem el\n                if x = y then None else Some y\n            )\n        el.AddEventListener(\"change\", onChange, false)\n        let attrs =\n            Attr.Concat attrs\n            |> Attr.Append selectedItemAttr\n            |> Attr.Append (Attr.OnAfterRender (fun el -> \n                setSelectedItem el <| current.Get()))\n        Doc'.Elem el attrs (optionElements options)\n\n    [<JavaScript>]\n    static member SelectDyn attrs (show: 'T -> string) (vOptions: View<list<'T>>) (current: IRef<'T>) =\n        let optionElements options =\n            vOptions\n            |> View.Map (fun l ->\n                options := l\n                l |> Seq.mapi (fun i x -> i, x)\n            )\n            |> Doc'.Convert (fun (i, o) ->\n                As<Doc'> (\n                    Doc'.Element \"option\" [\n                        Attr.Create \"value\" (string i)\n                    ] [Doc'.TextNode (show o)]\n                )\n            )\n        Doc'.SelectImpl attrs show optionElements current\n\n    [<JavaScript>]\n    static member Select attrs show options current =\n        let optionElements rOptions =\n            rOptions := options\n            options\n            |> List.mapi (fun i o ->\n                As<Doc> (\n                    Doc'.Element \"option\" [\n                        Attr.Create \"value\" (string i)\n                    ] [Doc'.TextNode (show o)]\n                )\n            )\n            |> Doc'.Concat\n        Doc'.SelectImpl attrs show (As optionElements) current\n\n    [<JavaScript>]\n    static member SelectOptional attrs noneText show options current =\n        Doc'.Select attrs\n            (function None -> noneText | Some x -> show x)\n            (None :: List.map Some options)\n            current\n\n    [<JavaScript>]\n    static member SelectDynOptional attrs noneText show vOptions current =\n        Doc'.SelectDyn attrs\n            (function None -> noneText | Some x -> show x)\n            (vOptions |> View.Map (fun options -> None :: List.map Some options))\n            current\n\n    [<JavaScript>]\n    static member CheckBox attrs (chk: IRef<bool>) =\n        Doc'.InputInternal \"input\" (fun _ ->\n            Seq.append attrs [\n                Attr.Create \"type\" \"checkbox\"\n                Attr.Checked chk\n            ])\n\n    [<JavaScript>]\n    static member CheckBoxGroup attrs (item: 'T) (chk: IRef<list<'T>>) =\n        let rv =\n            chk.Lens\n                (List.exists ((=) item))\n                (fun l b ->\n                    if b then\n                        if List.exists ((=) item) l then l else item :: l\n                    else\n                        List.filter ((<>) item) l\n                )\n        Doc'.CheckBox attrs rv\n\n    [<JavaScript>]\n    static member Clickable elem action =\n        let el = DU.CreateElement elem\n        el.AddEventListener(\"click\", (fun (ev: DomEvent) ->\n            ev.PreventDefault()\n            action ()), false)\n        el\n\n    [<JavaScript>]\n    static member Button caption attrs action =\n        let attrs = Attr.Concat attrs\n        let el = Doc'.Clickable \"button\" action\n        Doc'.Elem el attrs (Doc'.TextNode' caption)\n\n    [<JavaScript>]\n    static member ButtonView caption attrs view action =\n        let evAttr = Attr.HandlerView \"click\" view (fun _ _ -> action)\n        let attrs = Attr.Concat (Seq.append [|evAttr|] attrs)\n        Doc'.Elem (DU.CreateElement \"button\") attrs (Doc'.TextNode' caption)\n\n    [<JavaScript>]\n    static member Link caption attrs action =\n        let attrs = Attr.Concat attrs |> Attr.Append (Attr.Create \"href\" \"#\")\n        let el = Doc'.Clickable \"a\" action\n        Doc'.Elem el attrs (Doc'.TextNode' caption)\n\n    [<JavaScript>]\n    static member LinkView caption attrs view action =\n        let evAttr = Attr.HandlerView \"click\" view (fun _ _ -> action)\n        let attrs = Attr.Concat (Seq.append [|evAttr; Attr.Create \"href\" \"#\"|] attrs)\n        Doc'.Elem (DU.CreateElement \"a\") attrs (As (Doc.TextNode caption))\n\n    [<JavaScript>]\n    static member Radio attrs value (var: IRef<_>) =\n        // Radio buttons work by taking a common var, which is given a unique ID.\n        // This ID is serialised and used as the name, giving us the \"grouping\"\n        // behaviour.\n        let el = DU.CreateElement \"input\"\n        el.AddEventListener(\"click\", (fun (x : DomEvent) -> var.Set value), false)\n        let predView = View.Map (fun x -> x = value) var.View\n        let valAttr = Attr.DynamicProp \"checked\" predView\n        let (==>) k v = Attr.Create k v\n        let attr =\n            [\n                \"type\" ==> \"radio\"\n                \"name\" ==> var.Id\n                valAttr\n            ] @ (List.ofSeq attrs) |> Attr.Concat\n        Doc'.Elem el attr Doc'.Empty'\n\n    // Actual proxy members\n\n    [<JavaScript>]\n    static member Element (name: string) (attr: seq<Attr>) (children: seq<Doc>) : Elt =\n        let attr = Attr.Concat attr\n        let children = Doc'.Concat' (As children)\n        As (Doc'.Elem (DU.CreateElement name) attr children)\n\n    static member ToMixedDoc (o: obj) =\n        match o with\n        | :? Doc as d -> d\n        | :? string as t -> Doc.TextNode t\n        | :? Element as e -> Doc'.Static e |> As<Doc>        \n        | :? Function as v ->\n            Doc'.EmbedView (\n                (As<View<_>>v).Map (As Doc'.ToMixedDoc)\n            ) |> As<Doc>\n        | :? Var<obj> as v ->\n            Doc'.EmbedView (\n                v.View.Map (As Doc'.ToMixedDoc)\n            ) |> As<Doc>\n        | null -> Doc.Empty\n        | o -> Doc.TextNode (string o)\n\n    static member MixedNodes (nodes: seq<obj>) =\n        let attrs = ResizeArray()\n        let children = ResizeArray()\n        for n in nodes do\n            match n with\n            | :? Attr as a -> attrs.Add a\n            | _ -> children.Add (Doc'.ToMixedDoc n)\n        attrs :> _ seq, children :> _ seq \n\n    static member ConcatMixed (elts: obj[]) =\n        Doc.Concat (Seq.map Doc'.ToMixedDoc elts)\n\n    [<JavaScript>]\n    static member ElementMixed (tagname: string) (nodes: seq<obj>) =\n        let attrs, children = Doc'.MixedNodes nodes\n        Doc.Element tagname attrs children \n\n    [<JavaScript>]\n    static member SvgElement (name: string) (attr: seq<Attr>) (children: seq<Doc>) : Elt =\n        let attr = Attr.Concat attr\n        let children = Doc'.Concat' (As children)\n        As (Doc'.Elem (DU.CreateSvgElement name) attr children)\n\n    [<JavaScript>]\n    static member SvgElementMixed (tagname: string) (nodes: seq<obj>) =\n        let attrs, children = Doc'.MixedNodes nodes\n        Doc.SvgElement tagname attrs children \n\n    [<JavaScript; Name \"EmptyProxy\">]\n    static member Empty\n        with [<Inline; MethodImpl(MethodImplOptions.NoInlining)>] get () : Doc =\n            As Doc'.Empty'\n\n    [<JavaScript; Inline; Name \"AppendProxy\">]\n    static member Append (a: Doc) (b: Doc) : Doc =\n        As (Doc'.Append' (As a) (As b))\n\n    [<JavaScript; Inline; Name \"ConcatProxy1\">]\n    static member Concat (xs: seq<Doc>) : Doc =\n        As (Doc'.Concat' (As xs))\n\n    [<JavaScript; Inline; Name \"TextNodeProxy\">]\n    static member TextNode (s: string) : Doc =\n        As (Doc'.TextNode' s)\n\n    // TODO: what if it's not a Doc but (eg) an Html.Client.Element ?\n    [<JavaScript; Inline>]\n    static member ClientSide (expr: Microsoft.FSharp.Quotations.Expr<#IControlBody>) : Doc =\n        As expr\n\n    [<JavaScript; Inline; Name \"VerbatimProxy\">]\n    static member Verbatim (s: string) : Doc =\n        As (Doc'.Verbatim' s)\n\nand [<JavaScript; Proxy(typeof<Elt>); Name \"WebSharper.UI.Next.Elt\">]\n    private Elt'(docNode, updates, elt: Dom.Element, rvUpdates: Updates) =\n    inherit Doc'(docNode, updates)\n\n    static member internal New(el: Dom.Element, attr: Attr, children: Doc') =\n        let node = Docs.CreateElemNode el attr children.DocNode\n        let rvUpdates = Updates.Create children.Updates\n        let attrUpdates = Attrs.Updates node.Attr\n        let updates = View.Map2Unit attrUpdates rvUpdates.View\n        new Elt'(ElemDoc node, updates, el, rvUpdates)\n\n    /// Assumes tree.Els = [| Union1Of2 someDomElement |]\n    static member internal TreeNode(tree: DocTreeNode, updates) =\n        let rvUpdates = Updates.Create updates\n        let attrUpdates =\n            tree.Attrs\n            |> Array.map (snd >> Attrs.Updates)\n            |> Array.TreeReduce (View.Const ()) View.Map2Unit\n        let updates = View.Map2Unit attrUpdates rvUpdates.View\n        new Elt'(TreeDoc tree, updates, As<Dom.Element> tree.Els.[0], rvUpdates)\n\n    [<Inline \"$0.elt\">]\n    member this.Element = elt\n\n    member this.on (ev: string, cb: Dom.Element -> #Dom.Event -> unit) =\n        elt.AddEventListener(ev, As<Dom.Event -> unit>(fun ev -> cb (As<Dom.Element>((ev :> Dom.Event).Target)) ev), false)\n        this\n\n    member this.onView (ev: string, view: View<'T>, cb: Dom.Element -> #Dom.Event -> 'T -> unit) =\n        let cb = cb elt\n        elt.AddEventListener(ev, (fun (ev: Dom.Event) -> View.Get (cb (As ev)) view), false)\n        this\n\n    [<Name \"On\"; Inline>]\n    member this.onExpr (ev: string, cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> #Dom.Event -> unit>) =\n        this.on (ev, As<_ -> _ -> _> cb)\n\n    member this.OnAfterRender (cb: Dom.Element -> unit) =\n        match docNode with\n        | ElemDoc e ->\n            e.Render <-\n                match e.Render with\n                | None -> Some cb\n                | Some f -> Some (fun el -> f el; cb el)\n        | TreeDoc e ->\n            e.Render <-\n                match e.Render with\n                | None -> Some cb\n                | Some f -> Some (fun el -> f el; cb el)\n        | _ -> failwith \"Invalid docNode in Elt\"\n        this\n\n    member this.OnAfterRenderView (view: View<'T>, cb: Dom.Element -> 'T -> unit) =\n        let id = Fresh.Id()\n        this.AppendDoc(Doc'.BindView (fun x -> this.Element?(id) <- x; Doc'.Empty') view)\n        this.OnAfterRender(fun e -> cb e e?(id))\n\n    abstract AddHole : DocElemNode -> unit \n    default this.AddHole h = \n        match docNode with\n        | TreeDoc e ->\n            e.Holes.JS.Push h |> ignore\n        | _ -> ()\n\n    abstract ClearHoles : unit -> unit \n    default this.ClearHoles() = \n        match docNode with\n        | TreeDoc e ->\n            e.Holes <- [||]\n        | _ -> ()\n\n    [<Name \"Append\">]\n    member this.AppendDoc(doc: Doc') =\n        match docNode with\n        | ElemDoc e ->\n            e.Children <- AppendDoc(e.Children, doc.DocNode)\n            Docs.InsertDoc elt doc.DocNode DU.AtEnd |> ignore\n        | TreeDoc e ->\n            let after = elt.AppendChild(JS.Document.CreateTextNode \"\")\n            let before = Docs.InsertBeforeDelim after doc.DocNode\n            this.AddHole {\n                El = elt\n                Attr = Attrs.Empty elt\n                Children = doc.DocNode\n                Delimiters = Some (before, after)\n                ElKey = Fresh.Int()\n                Render = None\n            } \n        | _ -> failwith \"Invalid docNode in Elt\"\n        rvUpdates.Value <- View.Map2Unit rvUpdates.Value doc.Updates\n\n    [<Name \"Prepend\">]\n    member this.PrependDoc(doc: Doc') =\n        match docNode with\n        | ElemDoc e ->\n            e.Children <- AppendDoc(doc.DocNode, e.Children)\n            let pos =\n                match elt.FirstChild with\n                | null -> DU.AtEnd\n                | n -> DU.BeforeNode n\n            Docs.InsertDoc elt doc.DocNode pos |> ignore\n        | TreeDoc e ->\n            let after = elt.InsertBefore(JS.Document.CreateTextNode \"\", elt.FirstChild)\n            let before = Docs.InsertBeforeDelim after doc.DocNode\n            this.AddHole {\n                El = elt\n                Attr = Attrs.Empty elt\n                Children = doc.DocNode\n                Delimiters = Some (before, after)\n                ElKey = Fresh.Int()\n                Render = None\n            }\n        | _ -> failwith \"Invalid docNode in Elt\"\n        rvUpdates.Value <- View.Map2Unit rvUpdates.Value doc.Updates\n\n    [<Name \"Clear\">]\n    member this.Clear'() =\n        match docNode with\n        | ElemDoc e ->\n            e.Children <- EmptyDoc\n        | TreeDoc e ->\n            e.Els <- [||]\n            this.ClearHoles()\n        | _ -> failwith \"Invalid docNode in Elt\"\n        rvUpdates.Value <- View.Const()\n        while (elt.HasChildNodes()) do elt.RemoveChild(elt.FirstChild) |> ignore\n\n    [<JavaScript>]\n    member this.ToUpdater() =\n        let docTreeNode : DocTreeNode =\n            match docNode with\n            | ElemDoc e ->\n                {\n                    Els = [| Union1Of2 (upcast elt) |]\n                    Holes = [||]\n                    Attrs = [| elt, e.Attr |]\n                    Render = None\n                    Dirty = true\n                }\n            | TreeDoc e -> e\n            | _ -> failwith \"Invalid docNode in Elt\"\n\n        EltUpdater'(docTreeNode, updates, elt, rvUpdates, Var.Create [||])\n\n    [<Name \"Html\">]\n    member this.Html'() : string =\n        elt?outerHTML\n\n    [<Name \"Id\">]\n    member this.Id'() : string =\n        elt?id\n\n    [<Name \"GetValue\">]\n    member this.GetValue() : string =\n        elt?value\n\n    [<Name \"SetValue\">]\n    member this.SetValue(v: string) : unit =\n        elt?value <- v\n\n    [<Name \"GetText\">]\n    member this.GetText() : string =\n        elt.TextContent\n\n    [<Name \"SetText\">]\n    member this.SetText(v: string) : unit =\n        match docNode with\n        | ElemDoc e ->\n            e.Children <- EmptyDoc\n        | TreeDoc e ->\n            e.Els <- [||]\n            this.ClearHoles()\n        | _ -> failwith \"Invalid docNode in Elt\"\n        rvUpdates.Value <- View.Const()\n        elt.TextContent <- v\n\n    [<Name \"SetAttribute\">]\n    member this.SetAttribute'(name: string, value: string) =\n        elt.SetAttribute(name, value)\n\n    [<Name \"GetAttribute\">]\n    member this.GetAttribute'(name) =\n        elt.GetAttribute(name)\n\n    [<Name \"HasAttribute\">]\n    member this.HasAttribute'(name) =\n        elt.HasAttribute(name)\n\n    [<Name \"RemoveAttribute\">]\n    member this.RemoveAttribute'(name) =\n        elt.RemoveAttribute(name)\n\n    [<Name \"SetProperty\">]\n    member this.SetProperty'(name: string, value: 'T) =\n        elt?(name) <- value\n\n    [<Name \"GetProperty\">]\n    member this.GetProperty'(name: string) : 'T =\n        elt?(name)\n\n    [<Name \"AddClass\"; Direct \"$this.elt.className += ' ' + $cls\">]\n    member this.AddClass'(cls: string) = X<unit>\n\n    [<Name \"RemoveClass\">]\n    member this.RemoveClass'(cls: string) =\n        elt?className <-\n            (elt?className: String).Replace(\n                new RegExp(@\"(?:(\\s|^)\" + cls + @\")+(\\s|$)\", \"g\"),\n                \"$1\")\n\n    [<Name \"HasClass\">]\n    member this.HasClass'(cls: string) =\n        (new RegExp(@\"(\\s|^)\" + cls + @\"(\\s|$)\")).Test(elt?className)\n\n    [<Name \"SetStyle\">]\n    member this.SetStyle'(style: string, value: string) =\n        elt?style?(style) <- value\n\nand [<JavaScript; Proxy(typeof<EltUpdater>)>] \n    private EltUpdater'(treeNode : DocTreeNode, updates, elt, rvUpdates: Updates, holeUpdates: Var<(int * View<unit>)[]>) =\n    inherit Elt'(\n        TreeDoc treeNode, \n        View.Map2Unit updates (holeUpdates.View |> View.BindInner (Array.map snd >> Array.TreeReduce (View.Const ()) View.Map2Unit)),\n        elt, rvUpdates)\n\n    let mutable origHoles = treeNode.Holes\n\n    override this.AddHole h =\n        origHoles.JS.Push h |> ignore\n        treeNode.Holes <- Array.append treeNode.Holes [| h |]\n\n    override this.ClearHoles() =\n        origHoles <- [||]\n        treeNode.Holes <- [||]\n        holeUpdates.Value <- [||]\n\n    member this.AddUpdated(doc: Elt) =\n        let d = As<Elt'> doc\n        match d.DocNode with\n        | ElemDoc e ->\n            treeNode.Holes <- Array.append treeNode.Holes [| e |]\n            let hu = holeUpdates.Value\n            hu.JS.Push ((e.ElKey, d.Updates)) |> ignore\n            holeUpdates.Value <- hu\n        | _ -> failwith \"DocUpdater.AddUpdated expects a single element node\"\n\n    member this.RemoveUpdated(doc: Elt) =\n        let d = As<Elt'> doc\n        match d.DocNode with\n        | ElemDoc e ->\n            let k = e.ElKey\n            treeNode.Holes <-\n                treeNode.Holes |> Array.filter (fun h -> h.ElKey <> k)\n            holeUpdates.Value <-\n                holeUpdates.Value |> Array.filter (function\n                    | uk, _ when uk = k -> false\n                    | _ -> true\n                )  \n        | _ -> failwith \"DocUpdater.RemoveUpdated expects a single element node\"\n\n    member this.RemoveAllUpdated() =\n        treeNode.Holes <- origHoles\n        holeUpdates.Value <- [||]\n\n[<AutoOpen; JavaScript>]\nmodule EltExtensions =\n\n    type Elt with\n\n        [<Inline \"$0.elt\">]\n        member this.Dom =\n            (As<Elt'> this).Element\n\n        [<Inline>]\n        member this.Html =\n            (As<Elt'> this).Html'()\n\n        [<Inline>]\n        member this.Id =\n            (As<Elt'> this).Id'()\n\n        member this.Value\n            with [<Inline>] get() = (As<Elt'> this).GetValue()\n            and [<Inline>] set v = (As<Elt'> this).SetValue(v)\n\n        member this.Text\n            with [<Inline>] get() = (As<Elt'> this).GetText()\n            and [<Inline>] set v = (As<Elt'> this).SetText(v)\n\n[<JavaScript; CompiledName \"DocModule\">]\nmodule Doc =\n\n    [<Inline>]\n    let Static el : Elt =\n        Doc'.Static el\n\n    [<Inline>]\n    let EmbedView (view: View<#Doc>) : Doc =\n        As (Doc'.EmbedView (As view))\n\n    [<Inline>]\n    let BindView (f: 'T -> #Doc) (view: View<'T>) : Doc =\n        As (Doc'.BindView (As f) view)\n\n    [<Inline>]\n    let Async (a: Async<#Doc>) : Doc =\n        As (Doc'.Async (As a))\n\n    [<Inline>]\n    let Template (el: Node[]) (fillWith: seq<TemplateHole>) : Doc =\n        As (Doc'.Template el fillWith)\n\n    [<Inline>]\n    let LoadLocalTemplates baseName =\n        Doc'.LoadLocalTemplates baseName\n\n    [<Inline>]\n    let LoadTemplate (baseName: string) (name: option<string>) (el: unit -> Node[]) =\n        Doc'.PrepareTemplate baseName name el\n\n    [<Inline>]\n    let NamedTemplate (baseName: string) (name: option<string>) (fillWith: seq<TemplateHole>) : Doc =\n        As (Doc'.NamedTemplate baseName name fillWith)\n\n    [<Inline>]\n    let GetOrLoadTemplate (baseName: string) (name: option<string>) (el: unit -> Node[]) (fillWith: seq<TemplateHole>) : Doc =\n        As (Doc'.GetOrLoadTemplate baseName name el fillWith)\n\n    [<Inline>]\n    let Run parent (doc: Doc) =\n        Doc'.Run parent (As doc)\n\n    [<Inline>]\n    let RunById id (tr: Doc) =\n        Doc'.RunById id (As tr)\n\n    [<Inline>]\n    let RunBefore parent (doc: Doc) =\n        Doc'.RunBefore parent (As doc)\n\n    [<Inline>]\n    let RunBeforeById id (tr: Doc) =\n        Doc'.RunBeforeById id (As tr)\n\n    [<Inline>]\n    let RunAfter parent (doc: Doc) =\n        Doc'.RunAfter parent (As doc)\n\n    [<Inline>]\n    let RunAfterById id (tr: Doc) =\n        Doc'.RunAfterById id (As tr)\n\n    [<Inline>]\n    let RunAppend parent (doc: Doc) =\n        Doc'.RunAppend parent (As doc)\n\n    [<Inline>]\n    let RunAppendById id (tr: Doc) =\n        Doc'.RunAppendById id (As tr)\n\n    [<Inline>]\n    let RunPrepend parent (doc: Doc) =\n        Doc'.RunPrepend parent (As doc)\n\n    [<Inline>]\n    let RunPrependById id (tr: Doc) =\n        Doc'.RunPrependById id (As tr)\n\n    [<Inline>]\n    let RunReplace (elt: Node) (doc: Doc) =\n        (doc :> IControlBody).ReplaceInDom(elt)\n\n    [<Inline>]\n    let RunReplaceById id (tr: Doc) =\n        Doc'.RunReplaceById id (As tr)\n\n    [<Inline>]\n    let TextView txt : Doc =\n        As (Doc'.TextView txt)\n\n  // Collections ----------------------------------------------------------------\n\n    [<Inline>]\n    let BindSeqCached (render: 'T -> #Doc) (view: View<#seq<'T>>) : Doc =\n        As (Doc'.Convert (As render) view)\n\n    [<Inline>]\n    let Convert f (v: View<seq<_>>) = BindSeqCached f v\n\n    [<Inline>]\n    let BindSeqCachedBy (key: 'T -> 'K) (render: 'T -> #Doc) (view: View<#seq<'T>>) : Doc =\n        As (Doc'.ConvertBy key (As render) view)\n\n    [<Inline>]\n    let ConvertBy k f (v: View<seq<_>>) = BindSeqCachedBy k f v\n\n    [<Inline>]\n    let BindSeqCachedView (render: View<'T> -> #Doc) (view: View<#seq<'T>>) : Doc =\n        As (Doc'.ConvertSeq (As render) view)\n\n    [<Inline>]\n    let ConvertSeq f (v: View<seq<_>>) = BindSeqCachedView f v\n\n    [<Inline>]\n    let BindSeqCachedViewBy (key: 'T -> 'K) (render: 'K -> View<'T> -> #Doc) (view: View<#seq<'T>>) : Doc =\n        As (Doc'.ConvertSeqBy key render view)\n\n    [<Inline>]\n    let ConvertSeqBy k f (v: View<seq<_>>) = BindSeqCachedViewBy k f v\n\n    [<Inline>]\n    let ToUpdater (e: Elt) = As<EltUpdater>((As<Elt'> e).ToUpdater() )\n\n  // Form helpers ---------------------------------------------------------------\n\n    [<Inline>]\n    let Input attr var =\n        Doc'.Input attr var\n\n    [<Inline>]\n    let PasswordBox attr var =\n        Doc'.PasswordBox attr var\n\n    [<Inline>]\n    let IntInput attr var =\n        Doc'.IntInput attr var\n\n    [<Inline>]\n    let IntInputUnchecked attr var =\n        Doc'.IntInputUnchecked attr var\n\n    [<Inline>]\n    let FloatInput attr var =\n        Doc'.FloatInput attr var\n\n    [<Inline>]\n    let FloatInputUnchecked attr var =\n        Doc'.FloatInputUnchecked attr var\n\n    [<Inline>]\n    let InputArea attr var =\n        Doc'.InputArea attr var\n\n    [<Inline>]\n    let Select attrs show options current =\n        Doc'.Select attrs show options current\n\n    [<Inline>]\n    let SelectDyn attrs show options current =\n        Doc'.SelectDyn attrs show options current\n\n    [<Inline>]\n    let SelectOptional attrs noneText show options current =\n        Doc'.SelectOptional attrs noneText show options current\n\n    [<Inline>]\n    let SelectDynOptional attrs noneText show options current =\n        Doc'.SelectDynOptional attrs noneText show options current\n\n    [<Inline>]\n    let CheckBox attrs chk =\n        Doc'.CheckBox attrs chk\n\n    [<Inline>]\n    let CheckBoxGroup attrs item chk =\n        Doc'.CheckBoxGroup attrs item chk\n\n    [<Inline>]\n    let Button caption attrs action =\n        Doc'.Button caption attrs action\n\n    [<Inline>]\n    let ButtonView caption attrs view action =\n        Doc'.ButtonView caption attrs view action\n\n    [<Inline>]\n    let Link caption attrs action =\n        Doc'.Link caption attrs action\n\n    [<Inline>]\n    let LinkView caption attrs view action =\n        Doc'.LinkView caption attrs view action\n\n    [<Inline>]\n    let Radio attrs value var =\n        Doc'.Radio attrs value var\n\n[<Extension; Sealed; JavaScript>]\ntype DocExtensions =\n\n    [<Extension; Inline>]\n    static member GetDom(this: Elt) = this.Dom\n\n    [<Extension; Inline>]\n    static member GetHtml(this: Elt) = this.Html\n\n    [<Extension; Inline>]\n    static member GetId(this: Elt) = this.Id\n\n    [<Extension; Inline>]\n    static member GetValue(this: Elt) = this.Value\n\n    [<Extension; Inline>]\n    static member SetValue(this: Elt, v) = this.Value <- v\n\n    [<Extension; Inline>]\n    static member GetText(this: Elt) = this.Text\n\n    [<Extension; Inline>]\n    static member SetText(this: Elt, v) = this.Text <- v\n\n    [<Extension; Inline>]\n    static member Doc(v, f) = Doc.BindView f v\n\n    [<Extension; Inline>]\n    static member DocSeqCached(v: View<seq<_>>, f) = Doc.BindSeqCached f v\n\n    [<Extension; Inline>]\n    static member DocSeqCached(v: View<seq<_>>, k, f) = Doc.BindSeqCachedBy k f v\n\n    [<Extension; Inline>]\n    static member DocSeqCached(v: View<seq<_>>, f) = Doc.BindSeqCachedView f v\n\n    [<Extension; Inline>]\n    static member DocSeqCached(v: View<seq<_>>, k, f) = Doc.BindSeqCachedViewBy k f v\n\n    [<Extension; Inline>]\n    static member DocSeqCached(v: View<list<_>>, f) = Doc.BindSeqCached f v\n\n    [<Extension; Inline>]\n    static member DocSeqCached(v: View<list<_>>, k, f) = Doc.BindSeqCachedBy k f v\n\n    [<Extension; Inline>]\n    static member DocSeqCached(v: View<list<_>>, f) = Doc.BindSeqCachedView f v\n\n    [<Extension; Inline>]\n    static member DocSeqCached(v: View<list<_>>, k, f) = Doc.BindSeqCachedViewBy k f v\n\n    [<Extension; Inline>]\n    static member DocSeqCached(v: View<array<_>>, f) = Doc.BindSeqCached f v\n\n    [<Extension; Inline>]\n    static member DocSeqCached(v: View<array<_>>, k, f) = Doc.BindSeqCachedBy k f v\n\n    [<Extension; Inline>]\n    static member DocSeqCached(v: View<array<_>>, f) = Doc.BindSeqCachedView f v\n\n    [<Extension; Inline>]\n    static member DocSeqCached(v: View<array<_>>, k, f) = Doc.BindSeqCachedViewBy k f v\n\n    [<Extension; Inline>]\n    static member DocSeqCached(v: View<ListModelState<_>>, f) = Doc.BindSeqCached f v\n\n    [<Extension; Inline>]\n    static member DocSeqCached(v: View<ListModelState<_>>, k, f) = Doc.BindSeqCachedBy k f v\n\n    [<Extension; Inline>]\n    static member DocSeqCached(v: View<ListModelState<_>>, f) = Doc.BindSeqCachedView f v\n\n    [<Extension; Inline>]\n    static member DocSeqCached(v: View<ListModelState<_>>, k, f) = Doc.BindSeqCachedViewBy k f v\n\n    [<Extension; Inline>]\n    static member RunById(doc: Doc, id: string) =\n        Doc'.RunById id (As<Doc'> doc)\n\n    [<Extension; Inline>]\n    static member Run(doc: Doc, elt: Dom.Element) =\n        Doc'.Run elt (As<Doc'> doc)\n\n    [<Extension; Inline>]\n    static member ToUpdater(elt:Elt) =\n        As<EltUpdater> ((As<Elt'> elt).ToUpdater())\n\n    [<Extension; Inline>]\n    static member Append(this: Elt, doc: Doc) =\n        (As<Elt'> this).AppendDoc(As<Doc'> doc)\n\n    [<Extension; Inline>]\n    static member Prepend(this: Elt, doc: Doc) =\n        (As<Elt'> this).PrependDoc(As<Doc'> doc)\n\n    [<Extension; Inline>]\n    static member AppendChild(this: Elt, doc: Doc) =\n        (As<Elt'> this).AppendDoc(As<Doc'> doc)\n\n    [<Extension; Inline>]\n    static member PrependChild(this: Elt, doc: Doc) =\n        (As<Elt'> this).PrependDoc(As<Doc'> doc)\n\n    [<Extension; Inline>]\n    static member Clear(this: Elt) =\n        (As<Elt'> this).Clear'()\n\n    [<Extension; Inline>]\n    static member On(this: Elt, event, cb: Dom.Element -> Dom.Event -> unit) =\n        As<Elt> ((As<Elt'> this).on(event, cb))\n\n    [<Extension; Inline>]\n    static member OnAfterRender(this: Elt, cb: Dom.Element -> unit) =\n        As<Elt> ((As<Elt'> this).OnAfterRender(cb))\n\n    [<Extension; Inline>]\n    static member OnAfterRenderView(this: Elt, view: View<'T>, cb: Dom.Element -> 'T -> unit) =\n        As<Elt> ((As<Elt'> this).OnAfterRenderView(view, cb))\n\n    [<Extension; Inline>]\n    static member SetAttribute(this: Elt, name, value) =\n        (As<Elt'> this).SetAttribute'(name, value)\n\n    [<Extension; Inline>]\n    static member GetAttribute(this: Elt, name) =\n        (As<Elt'> this).GetAttribute'(name)\n\n    [<Extension; Inline>]\n    static member HasAttribute(this: Elt, name) =\n        (As<Elt'> this).HasAttribute'(name)\n\n    [<Extension; Inline>]\n    static member RemoveAttribute(this: Elt, name) =\n        (As<Elt'> this).RemoveAttribute'(name)\n\n    [<Extension; Inline>]\n    static member SetProperty(this: Elt, name, value) =\n        (As<Elt'> this).SetProperty'(name, value)\n\n    [<Extension; Inline>]\n    static member GetProperty(this: Elt, name) =\n        (As<Elt'> this).GetProperty'(name)\n\n    [<Extension; Inline>]\n    static member AddClass(this: Elt, cls) =\n        (As<Elt'> this).AddClass'(cls)\n\n    [<Extension; Inline>]\n    static member RemoveClass(this: Elt, cls) =\n        (As<Elt'> this).RemoveClass'(cls)\n\n    [<Extension; Inline>]\n    static member HasClass(this: Elt, cls) =\n        (As<Elt'> this).HasClass'(cls)\n\n    [<Extension; Inline>]\n    static member SetStyle(this: Elt, name, value) =\n        (As<Elt'> this).SetStyle'(name, value)\n\n    // {{ event\n    [<Extension; Inline>]\n    static member OnAbort(this: Elt, cb: Dom.Element -> Dom.UIEvent -> unit) = As<Elt> ((As<Elt'> this).on(\"abort\", cb))\n    [<Extension; Inline>]\n    static member OnAbortView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.UIEvent -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"abort\", view, cb))\n    [<Extension; Inline>]\n    static member OnAfterPrint(this: Elt, cb: Dom.Element -> Dom.Event -> unit) = As<Elt> ((As<Elt'> this).on(\"afterprint\", cb))\n    [<Extension; Inline>]\n    static member OnAfterPrintView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.Event -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"afterprint\", view, cb))\n    [<Extension; Inline>]\n    static member OnAnimationEnd(this: Elt, cb: Dom.Element -> Dom.Event -> unit) = As<Elt> ((As<Elt'> this).on(\"animationend\", cb))\n    [<Extension; Inline>]\n    static member OnAnimationEndView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.Event -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"animationend\", view, cb))\n    [<Extension; Inline>]\n    static member OnAnimationIteration(this: Elt, cb: Dom.Element -> Dom.Event -> unit) = As<Elt> ((As<Elt'> this).on(\"animationiteration\", cb))\n    [<Extension; Inline>]\n    static member OnAnimationIterationView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.Event -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"animationiteration\", view, cb))\n    [<Extension; Inline>]\n    static member OnAnimationStart(this: Elt, cb: Dom.Element -> Dom.Event -> unit) = As<Elt> ((As<Elt'> this).on(\"animationstart\", cb))\n    [<Extension; Inline>]\n    static member OnAnimationStartView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.Event -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"animationstart\", view, cb))\n    [<Extension; Inline>]\n    static member OnAudioProcess(this: Elt, cb: Dom.Element -> Dom.Event -> unit) = As<Elt> ((As<Elt'> this).on(\"audioprocess\", cb))\n    [<Extension; Inline>]\n    static member OnAudioProcessView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.Event -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"audioprocess\", view, cb))\n    [<Extension; Inline>]\n    static member OnBeforePrint(this: Elt, cb: Dom.Element -> Dom.Event -> unit) = As<Elt> ((As<Elt'> this).on(\"beforeprint\", cb))\n    [<Extension; Inline>]\n    static member OnBeforePrintView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.Event -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"beforeprint\", view, cb))\n    [<Extension; Inline>]\n    static member OnBeforeUnload(this: Elt, cb: Dom.Element -> Dom.Event -> unit) = As<Elt> ((As<Elt'> this).on(\"beforeunload\", cb))\n    [<Extension; Inline>]\n    static member OnBeforeUnloadView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.Event -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"beforeunload\", view, cb))\n    [<Extension; Inline>]\n    static member OnBeginEvent(this: Elt, cb: Dom.Element -> Dom.Event -> unit) = As<Elt> ((As<Elt'> this).on(\"beginEvent\", cb))\n    [<Extension; Inline>]\n    static member OnBeginEventView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.Event -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"beginEvent\", view, cb))\n    [<Extension; Inline>]\n    static member OnBlocked(this: Elt, cb: Dom.Element -> Dom.Event -> unit) = As<Elt> ((As<Elt'> this).on(\"blocked\", cb))\n    [<Extension; Inline>]\n    static member OnBlockedView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.Event -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"blocked\", view, cb))\n    [<Extension; Inline>]\n    static member OnBlur(this: Elt, cb: Dom.Element -> Dom.FocusEvent -> unit) = As<Elt> ((As<Elt'> this).on(\"blur\", cb))\n    [<Extension; Inline>]\n    static member OnBlurView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.FocusEvent -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"blur\", view, cb))\n    [<Extension; Inline>]\n    static member OnCached(this: Elt, cb: Dom.Element -> Dom.Event -> unit) = As<Elt> ((As<Elt'> this).on(\"cached\", cb))\n    [<Extension; Inline>]\n    static member OnCachedView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.Event -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"cached\", view, cb))\n    [<Extension; Inline>]\n    static member OnCanPlay(this: Elt, cb: Dom.Element -> Dom.Event -> unit) = As<Elt> ((As<Elt'> this).on(\"canplay\", cb))\n    [<Extension; Inline>]\n    static member OnCanPlayView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.Event -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"canplay\", view, cb))\n    [<Extension; Inline>]\n    static member OnCanPlayThrough(this: Elt, cb: Dom.Element -> Dom.Event -> unit) = As<Elt> ((As<Elt'> this).on(\"canplaythrough\", cb))\n    [<Extension; Inline>]\n    static member OnCanPlayThroughView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.Event -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"canplaythrough\", view, cb))\n    [<Extension; Inline>]\n    static member OnChange(this: Elt, cb: Dom.Element -> Dom.Event -> unit) = As<Elt> ((As<Elt'> this).on(\"change\", cb))\n    [<Extension; Inline>]\n    static member OnChangeView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.Event -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"change\", view, cb))\n    [<Extension; Inline>]\n    static member OnChargingChange(this: Elt, cb: Dom.Element -> Dom.Event -> unit) = As<Elt> ((As<Elt'> this).on(\"chargingchange\", cb))\n    [<Extension; Inline>]\n    static member OnChargingChangeView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.Event -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"chargingchange\", view, cb))\n    [<Extension; Inline>]\n    static member OnChargingTimeChange(this: Elt, cb: Dom.Element -> Dom.Event -> unit) = As<Elt> ((As<Elt'> this).on(\"chargingtimechange\", cb))\n    [<Extension; Inline>]\n    static member OnChargingTimeChangeView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.Event -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"chargingtimechange\", view, cb))\n    [<Extension; Inline>]\n    static member OnChecking(this: Elt, cb: Dom.Element -> Dom.Event -> unit) = As<Elt> ((As<Elt'> this).on(\"checking\", cb))\n    [<Extension; Inline>]\n    static member OnCheckingView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.Event -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"checking\", view, cb))\n    [<Extension; Inline>]\n    static member OnClick(this: Elt, cb: Dom.Element -> Dom.MouseEvent -> unit) = As<Elt> ((As<Elt'> this).on(\"click\", cb))\n    [<Extension; Inline>]\n    static member OnClickView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.MouseEvent -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"click\", view, cb))\n    [<Extension; Inline>]\n    static member OnClose(this: Elt, cb: Dom.Element -> Dom.Event -> unit) = As<Elt> ((As<Elt'> this).on(\"close\", cb))\n    [<Extension; Inline>]\n    static member OnCloseView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.Event -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"close\", view, cb))\n    [<Extension; Inline>]\n    static member OnComplete(this: Elt, cb: Dom.Element -> Dom.Event -> unit) = As<Elt> ((As<Elt'> this).on(\"complete\", cb))\n    [<Extension; Inline>]\n    static member OnCompleteView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.Event -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"complete\", view, cb))\n    [<Extension; Inline>]\n    static member OnCompositionEnd(this: Elt, cb: Dom.Element -> Dom.CompositionEvent -> unit) = As<Elt> ((As<Elt'> this).on(\"compositionend\", cb))\n    [<Extension; Inline>]\n    static member OnCompositionEndView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.CompositionEvent -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"compositionend\", view, cb))\n    [<Extension; Inline>]\n    static member OnCompositionStart(this: Elt, cb: Dom.Element -> Dom.CompositionEvent -> unit) = As<Elt> ((As<Elt'> this).on(\"compositionstart\", cb))\n    [<Extension; Inline>]\n    static member OnCompositionStartView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.CompositionEvent -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"compositionstart\", view, cb))\n    [<Extension; Inline>]\n    static member OnCompositionUpdate(this: Elt, cb: Dom.Element -> Dom.CompositionEvent -> unit) = As<Elt> ((As<Elt'> this).on(\"compositionupdate\", cb))\n    [<Extension; Inline>]\n    static member OnCompositionUpdateView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.CompositionEvent -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"compositionupdate\", view, cb))\n    [<Extension; Inline>]\n    static member OnContextMenu(this: Elt, cb: Dom.Element -> Dom.MouseEvent -> unit) = As<Elt> ((As<Elt'> this).on(\"contextmenu\", cb))\n    [<Extension; Inline>]\n    static member OnContextMenuView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.MouseEvent -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"contextmenu\", view, cb))\n    [<Extension; Inline>]\n    static member OnCopy(this: Elt, cb: Dom.Element -> Dom.Event -> unit) = As<Elt> ((As<Elt'> this).on(\"copy\", cb))\n    [<Extension; Inline>]\n    static member OnCopyView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.Event -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"copy\", view, cb))\n    [<Extension; Inline>]\n    static member OnCut(this: Elt, cb: Dom.Element -> Dom.Event -> unit) = As<Elt> ((As<Elt'> this).on(\"cut\", cb))\n    [<Extension; Inline>]\n    static member OnCutView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.Event -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"cut\", view, cb))\n    [<Extension; Inline>]\n    static member OnDblClick(this: Elt, cb: Dom.Element -> Dom.MouseEvent -> unit) = As<Elt> ((As<Elt'> this).on(\"dblclick\", cb))\n    [<Extension; Inline>]\n    static member OnDblClickView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.MouseEvent -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"dblclick\", view, cb))\n    [<Extension; Inline>]\n    static member OnDeviceLight(this: Elt, cb: Dom.Element -> Dom.Event -> unit) = As<Elt> ((As<Elt'> this).on(\"devicelight\", cb))\n    [<Extension; Inline>]\n    static member OnDeviceLightView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.Event -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"devicelight\", view, cb))\n    [<Extension; Inline>]\n    static member OnDeviceMotion(this: Elt, cb: Dom.Element -> Dom.Event -> unit) = As<Elt> ((As<Elt'> this).on(\"devicemotion\", cb))\n    [<Extension; Inline>]\n    static member OnDeviceMotionView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.Event -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"devicemotion\", view, cb))\n    [<Extension; Inline>]\n    static member OnDeviceOrientation(this: Elt, cb: Dom.Element -> Dom.Event -> unit) = As<Elt> ((As<Elt'> this).on(\"deviceorientation\", cb))\n    [<Extension; Inline>]\n    static member OnDeviceOrientationView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.Event -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"deviceorientation\", view, cb))\n    [<Extension; Inline>]\n    static member OnDeviceProximity(this: Elt, cb: Dom.Element -> Dom.Event -> unit) = As<Elt> ((As<Elt'> this).on(\"deviceproximity\", cb))\n    [<Extension; Inline>]\n    static member OnDeviceProximityView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.Event -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"deviceproximity\", view, cb))\n    [<Extension; Inline>]\n    static member OnDischargingTimeChange(this: Elt, cb: Dom.Element -> Dom.Event -> unit) = As<Elt> ((As<Elt'> this).on(\"dischargingtimechange\", cb))\n    [<Extension; Inline>]\n    static member OnDischargingTimeChangeView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.Event -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"dischargingtimechange\", view, cb))\n    [<Extension; Inline>]\n    static member OnDOMActivate(this: Elt, cb: Dom.Element -> Dom.UIEvent -> unit) = As<Elt> ((As<Elt'> this).on(\"DOMActivate\", cb))\n    [<Extension; Inline>]\n    static member OnDOMActivateView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.UIEvent -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"DOMActivate\", view, cb))\n    [<Extension; Inline>]\n    static member OnDOMAttributeNameChanged(this: Elt, cb: Dom.Element -> Dom.Event -> unit) = As<Elt> ((As<Elt'> this).on(\"DOMAttributeNameChanged\", cb))\n    [<Extension; Inline>]\n    static member OnDOMAttributeNameChangedView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.Event -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"DOMAttributeNameChanged\", view, cb))\n    [<Extension; Inline>]\n    static member OnDOMAttrModified(this: Elt, cb: Dom.Element -> Dom.MutationEvent -> unit) = As<Elt> ((As<Elt'> this).on(\"DOMAttrModified\", cb))\n    [<Extension; Inline>]\n    static member OnDOMAttrModifiedView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.MutationEvent -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"DOMAttrModified\", view, cb))\n    [<Extension; Inline>]\n    static member OnDOMCharacterDataModified(this: Elt, cb: Dom.Element -> Dom.MutationEvent -> unit) = As<Elt> ((As<Elt'> this).on(\"DOMCharacterDataModified\", cb))\n    [<Extension; Inline>]\n    static member OnDOMCharacterDataModifiedView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.MutationEvent -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"DOMCharacterDataModified\", view, cb))\n    [<Extension; Inline>]\n    static member OnDOMContentLoaded(this: Elt, cb: Dom.Element -> Dom.Event -> unit) = As<Elt> ((As<Elt'> this).on(\"DOMContentLoaded\", cb))\n    [<Extension; Inline>]\n    static member OnDOMContentLoadedView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.Event -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"DOMContentLoaded\", view, cb))\n    [<Extension; Inline>]\n    static member OnDOMElementNameChanged(this: Elt, cb: Dom.Element -> Dom.Event -> unit) = As<Elt> ((As<Elt'> this).on(\"DOMElementNameChanged\", cb))\n    [<Extension; Inline>]\n    static member OnDOMElementNameChangedView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.Event -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"DOMElementNameChanged\", view, cb))\n    [<Extension; Inline>]\n    static member OnDOMNodeInserted(this: Elt, cb: Dom.Element -> Dom.MutationEvent -> unit) = As<Elt> ((As<Elt'> this).on(\"DOMNodeInserted\", cb))\n    [<Extension; Inline>]\n    static member OnDOMNodeInsertedView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.MutationEvent -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"DOMNodeInserted\", view, cb))\n    [<Extension; Inline>]\n    static member OnDOMNodeInsertedIntoDocument(this: Elt, cb: Dom.Element -> Dom.MutationEvent -> unit) = As<Elt> ((As<Elt'> this).on(\"DOMNodeInsertedIntoDocument\", cb))\n    [<Extension; Inline>]\n    static member OnDOMNodeInsertedIntoDocumentView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.MutationEvent -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"DOMNodeInsertedIntoDocument\", view, cb))\n    [<Extension; Inline>]\n    static member OnDOMNodeRemoved(this: Elt, cb: Dom.Element -> Dom.MutationEvent -> unit) = As<Elt> ((As<Elt'> this).on(\"DOMNodeRemoved\", cb))\n    [<Extension; Inline>]\n    static member OnDOMNodeRemovedView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.MutationEvent -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"DOMNodeRemoved\", view, cb))\n    [<Extension; Inline>]\n    static member OnDOMNodeRemovedFromDocument(this: Elt, cb: Dom.Element -> Dom.MutationEvent -> unit) = As<Elt> ((As<Elt'> this).on(\"DOMNodeRemovedFromDocument\", cb))\n    [<Extension; Inline>]\n    static member OnDOMNodeRemovedFromDocumentView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.MutationEvent -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"DOMNodeRemovedFromDocument\", view, cb))\n    [<Extension; Inline>]\n    static member OnDOMSubtreeModified(this: Elt, cb: Dom.Element -> Dom.MutationEvent -> unit) = As<Elt> ((As<Elt'> this).on(\"DOMSubtreeModified\", cb))\n    [<Extension; Inline>]\n    static member OnDOMSubtreeModifiedView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.MutationEvent -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"DOMSubtreeModified\", view, cb))\n    [<Extension; Inline>]\n    static member OnDownloading(this: Elt, cb: Dom.Element -> Dom.Event -> unit) = As<Elt> ((As<Elt'> this).on(\"downloading\", cb))\n    [<Extension; Inline>]\n    static member OnDownloadingView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.Event -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"downloading\", view, cb))\n    [<Extension; Inline>]\n    static member OnDrag(this: Elt, cb: Dom.Element -> Dom.Event -> unit) = As<Elt> ((As<Elt'> this).on(\"drag\", cb))\n    [<Extension; Inline>]\n    static member OnDragView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.Event -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"drag\", view, cb))\n    [<Extension; Inline>]\n    static member OnDragEnd(this: Elt, cb: Dom.Element -> Dom.Event -> unit) = As<Elt> ((As<Elt'> this).on(\"dragend\", cb))\n    [<Extension; Inline>]\n    static member OnDragEndView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.Event -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"dragend\", view, cb))\n    [<Extension; Inline>]\n    static member OnDragEnter(this: Elt, cb: Dom.Element -> Dom.Event -> unit) = As<Elt> ((As<Elt'> this).on(\"dragenter\", cb))\n    [<Extension; Inline>]\n    static member OnDragEnterView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.Event -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"dragenter\", view, cb))\n    [<Extension; Inline>]\n    static member OnDragLeave(this: Elt, cb: Dom.Element -> Dom.Event -> unit) = As<Elt> ((As<Elt'> this).on(\"dragleave\", cb))\n    [<Extension; Inline>]\n    static member OnDragLeaveView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.Event -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"dragleave\", view, cb))\n    [<Extension; Inline>]\n    static member OnDragOver(this: Elt, cb: Dom.Element -> Dom.Event -> unit) = As<Elt> ((As<Elt'> this).on(\"dragover\", cb))\n    [<Extension; Inline>]\n    static member OnDragOverView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.Event -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"dragover\", view, cb))\n    [<Extension; Inline>]\n    static member OnDragStart(this: Elt, cb: Dom.Element -> Dom.Event -> unit) = As<Elt> ((As<Elt'> this).on(\"dragstart\", cb))\n    [<Extension; Inline>]\n    static member OnDragStartView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.Event -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"dragstart\", view, cb))\n    [<Extension; Inline>]\n    static member OnDrop(this: Elt, cb: Dom.Element -> Dom.Event -> unit) = As<Elt> ((As<Elt'> this).on(\"drop\", cb))\n    [<Extension; Inline>]\n    static member OnDropView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.Event -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"drop\", view, cb))\n    [<Extension; Inline>]\n    static member OnDurationChange(this: Elt, cb: Dom.Element -> Dom.Event -> unit) = As<Elt> ((As<Elt'> this).on(\"durationchange\", cb))\n    [<Extension; Inline>]\n    static member OnDurationChangeView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.Event -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"durationchange\", view, cb))\n    [<Extension; Inline>]\n    static member OnEmptied(this: Elt, cb: Dom.Element -> Dom.Event -> unit) = As<Elt> ((As<Elt'> this).on(\"emptied\", cb))\n    [<Extension; Inline>]\n    static member OnEmptiedView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.Event -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"emptied\", view, cb))\n    [<Extension; Inline>]\n    static member OnEnded(this: Elt, cb: Dom.Element -> Dom.Event -> unit) = As<Elt> ((As<Elt'> this).on(\"ended\", cb))\n    [<Extension; Inline>]\n    static member OnEndedView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.Event -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"ended\", view, cb))\n    [<Extension; Inline>]\n    static member OnEndEvent(this: Elt, cb: Dom.Element -> Dom.Event -> unit) = As<Elt> ((As<Elt'> this).on(\"endEvent\", cb))\n    [<Extension; Inline>]\n    static member OnEndEventView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.Event -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"endEvent\", view, cb))\n    [<Extension; Inline>]\n    static member OnError(this: Elt, cb: Dom.Element -> Dom.Event -> unit) = As<Elt> ((As<Elt'> this).on(\"error\", cb))\n    [<Extension; Inline>]\n    static member OnErrorView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.Event -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"error\", view, cb))\n    [<Extension; Inline>]\n    static member OnFocus(this: Elt, cb: Dom.Element -> Dom.FocusEvent -> unit) = As<Elt> ((As<Elt'> this).on(\"focus\", cb))\n    [<Extension; Inline>]\n    static member OnFocusView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.FocusEvent -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"focus\", view, cb))\n    [<Extension; Inline>]\n    static member OnFullScreenChange(this: Elt, cb: Dom.Element -> Dom.Event -> unit) = As<Elt> ((As<Elt'> this).on(\"fullscreenchange\", cb))\n    [<Extension; Inline>]\n    static member OnFullScreenChangeView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.Event -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"fullscreenchange\", view, cb))\n    [<Extension; Inline>]\n    static member OnFullScreenError(this: Elt, cb: Dom.Element -> Dom.Event -> unit) = As<Elt> ((As<Elt'> this).on(\"fullscreenerror\", cb))\n    [<Extension; Inline>]\n    static member OnFullScreenErrorView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.Event -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"fullscreenerror\", view, cb))\n    [<Extension; Inline>]\n    static member OnGamepadConnected(this: Elt, cb: Dom.Element -> Dom.Event -> unit) = As<Elt> ((As<Elt'> this).on(\"gamepadconnected\", cb))\n    [<Extension; Inline>]\n    static member OnGamepadConnectedView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.Event -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"gamepadconnected\", view, cb))\n    [<Extension; Inline>]\n    static member OnGamepadDisconnected(this: Elt, cb: Dom.Element -> Dom.Event -> unit) = As<Elt> ((As<Elt'> this).on(\"gamepaddisconnected\", cb))\n    [<Extension; Inline>]\n    static member OnGamepadDisconnectedView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.Event -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"gamepaddisconnected\", view, cb))\n    [<Extension; Inline>]\n    static member OnHashChange(this: Elt, cb: Dom.Element -> Dom.Event -> unit) = As<Elt> ((As<Elt'> this).on(\"hashchange\", cb))\n    [<Extension; Inline>]\n    static member OnHashChangeView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.Event -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"hashchange\", view, cb))\n    [<Extension; Inline>]\n    static member OnInput(this: Elt, cb: Dom.Element -> Dom.Event -> unit) = As<Elt> ((As<Elt'> this).on(\"input\", cb))\n    [<Extension; Inline>]\n    static member OnInputView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.Event -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"input\", view, cb))\n    [<Extension; Inline>]\n    static member OnInvalid(this: Elt, cb: Dom.Element -> Dom.Event -> unit) = As<Elt> ((As<Elt'> this).on(\"invalid\", cb))\n    [<Extension; Inline>]\n    static member OnInvalidView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.Event -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"invalid\", view, cb))\n    [<Extension; Inline>]\n    static member OnKeyDown(this: Elt, cb: Dom.Element -> Dom.KeyboardEvent -> unit) = As<Elt> ((As<Elt'> this).on(\"keydown\", cb))\n    [<Extension; Inline>]\n    static member OnKeyDownView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.KeyboardEvent -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"keydown\", view, cb))\n    [<Extension; Inline>]\n    static member OnKeyPress(this: Elt, cb: Dom.Element -> Dom.KeyboardEvent -> unit) = As<Elt> ((As<Elt'> this).on(\"keypress\", cb))\n    [<Extension; Inline>]\n    static member OnKeyPressView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.KeyboardEvent -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"keypress\", view, cb))\n    [<Extension; Inline>]\n    static member OnKeyUp(this: Elt, cb: Dom.Element -> Dom.KeyboardEvent -> unit) = As<Elt> ((As<Elt'> this).on(\"keyup\", cb))\n    [<Extension; Inline>]\n    static member OnKeyUpView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.KeyboardEvent -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"keyup\", view, cb))\n    [<Extension; Inline>]\n    static member OnLanguageChange(this: Elt, cb: Dom.Element -> Dom.Event -> unit) = As<Elt> ((As<Elt'> this).on(\"languagechange\", cb))\n    [<Extension; Inline>]\n    static member OnLanguageChangeView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.Event -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"languagechange\", view, cb))\n    [<Extension; Inline>]\n    static member OnLevelChange(this: Elt, cb: Dom.Element -> Dom.Event -> unit) = As<Elt> ((As<Elt'> this).on(\"levelchange\", cb))\n    [<Extension; Inline>]\n    static member OnLevelChangeView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.Event -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"levelchange\", view, cb))\n    [<Extension; Inline>]\n    static member OnLoad(this: Elt, cb: Dom.Element -> Dom.UIEvent -> unit) = As<Elt> ((As<Elt'> this).on(\"load\", cb))\n    [<Extension; Inline>]\n    static member OnLoadView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.UIEvent -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"load\", view, cb))\n    [<Extension; Inline>]\n    static member OnLoadedData(this: Elt, cb: Dom.Element -> Dom.Event -> unit) = As<Elt> ((As<Elt'> this).on(\"loadeddata\", cb))\n    [<Extension; Inline>]\n    static member OnLoadedDataView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.Event -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"loadeddata\", view, cb))\n    [<Extension; Inline>]\n    static member OnLoadedMetadata(this: Elt, cb: Dom.Element -> Dom.Event -> unit) = As<Elt> ((As<Elt'> this).on(\"loadedmetadata\", cb))\n    [<Extension; Inline>]\n    static member OnLoadedMetadataView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.Event -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"loadedmetadata\", view, cb))\n    [<Extension; Inline>]\n    static member OnLoadEnd(this: Elt, cb: Dom.Element -> Dom.Event -> unit) = As<Elt> ((As<Elt'> this).on(\"loadend\", cb))\n    [<Extension; Inline>]\n    static member OnLoadEndView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.Event -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"loadend\", view, cb))\n    [<Extension; Inline>]\n    static member OnLoadStart(this: Elt, cb: Dom.Element -> Dom.Event -> unit) = As<Elt> ((As<Elt'> this).on(\"loadstart\", cb))\n    [<Extension; Inline>]\n    static member OnLoadStartView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.Event -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"loadstart\", view, cb))\n    [<Extension; Inline>]\n    static member OnMessage(this: Elt, cb: Dom.Element -> Dom.Event -> unit) = As<Elt> ((As<Elt'> this).on(\"message\", cb))\n    [<Extension; Inline>]\n    static member OnMessageView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.Event -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"message\", view, cb))\n    [<Extension; Inline>]\n    static member OnMouseDown(this: Elt, cb: Dom.Element -> Dom.MouseEvent -> unit) = As<Elt> ((As<Elt'> this).on(\"mousedown\", cb))\n    [<Extension; Inline>]\n    static member OnMouseDownView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.MouseEvent -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"mousedown\", view, cb))\n    [<Extension; Inline>]\n    static member OnMouseEnter(this: Elt, cb: Dom.Element -> Dom.MouseEvent -> unit) = As<Elt> ((As<Elt'> this).on(\"mouseenter\", cb))\n    [<Extension; Inline>]\n    static member OnMouseEnterView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.MouseEvent -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"mouseenter\", view, cb))\n    [<Extension; Inline>]\n    static member OnMouseLeave(this: Elt, cb: Dom.Element -> Dom.MouseEvent -> unit) = As<Elt> ((As<Elt'> this).on(\"mouseleave\", cb))\n    [<Extension; Inline>]\n    static member OnMouseLeaveView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.MouseEvent -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"mouseleave\", view, cb))\n    [<Extension; Inline>]\n    static member OnMouseMove(this: Elt, cb: Dom.Element -> Dom.MouseEvent -> unit) = As<Elt> ((As<Elt'> this).on(\"mousemove\", cb))\n    [<Extension; Inline>]\n    static member OnMouseMoveView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.MouseEvent -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"mousemove\", view, cb))\n    [<Extension; Inline>]\n    static member OnMouseOut(this: Elt, cb: Dom.Element -> Dom.MouseEvent -> unit) = As<Elt> ((As<Elt'> this).on(\"mouseout\", cb))\n    [<Extension; Inline>]\n    static member OnMouseOutView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.MouseEvent -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"mouseout\", view, cb))\n    [<Extension; Inline>]\n    static member OnMouseOver(this: Elt, cb: Dom.Element -> Dom.MouseEvent -> unit) = As<Elt> ((As<Elt'> this).on(\"mouseover\", cb))\n    [<Extension; Inline>]\n    static member OnMouseOverView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.MouseEvent -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"mouseover\", view, cb))\n    [<Extension; Inline>]\n    static member OnMouseUp(this: Elt, cb: Dom.Element -> Dom.MouseEvent -> unit) = As<Elt> ((As<Elt'> this).on(\"mouseup\", cb))\n    [<Extension; Inline>]\n    static member OnMouseUpView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.MouseEvent -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"mouseup\", view, cb))\n    [<Extension; Inline>]\n    static member OnNoUpdate(this: Elt, cb: Dom.Element -> Dom.Event -> unit) = As<Elt> ((As<Elt'> this).on(\"noupdate\", cb))\n    [<Extension; Inline>]\n    static member OnNoUpdateView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.Event -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"noupdate\", view, cb))\n    [<Extension; Inline>]\n    static member OnObsolete(this: Elt, cb: Dom.Element -> Dom.Event -> unit) = As<Elt> ((As<Elt'> this).on(\"obsolete\", cb))\n    [<Extension; Inline>]\n    static member OnObsoleteView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.Event -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"obsolete\", view, cb))\n    [<Extension; Inline>]\n    static member OnOffline(this: Elt, cb: Dom.Element -> Dom.Event -> unit) = As<Elt> ((As<Elt'> this).on(\"offline\", cb))\n    [<Extension; Inline>]\n    static member OnOfflineView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.Event -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"offline\", view, cb))\n    [<Extension; Inline>]\n    static member OnOnline(this: Elt, cb: Dom.Element -> Dom.Event -> unit) = As<Elt> ((As<Elt'> this).on(\"online\", cb))\n    [<Extension; Inline>]\n    static member OnOnlineView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.Event -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"online\", view, cb))\n    [<Extension; Inline>]\n    static member OnOpen(this: Elt, cb: Dom.Element -> Dom.Event -> unit) = As<Elt> ((As<Elt'> this).on(\"open\", cb))\n    [<Extension; Inline>]\n    static member OnOpenView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.Event -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"open\", view, cb))\n    [<Extension; Inline>]\n    static member OnOrientationChange(this: Elt, cb: Dom.Element -> Dom.Event -> unit) = As<Elt> ((As<Elt'> this).on(\"orientationchange\", cb))\n    [<Extension; Inline>]\n    static member OnOrientationChangeView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.Event -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"orientationchange\", view, cb))\n    [<Extension; Inline>]\n    static member OnPageHide(this: Elt, cb: Dom.Element -> Dom.Event -> unit) = As<Elt> ((As<Elt'> this).on(\"pagehide\", cb))\n    [<Extension; Inline>]\n    static member OnPageHideView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.Event -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"pagehide\", view, cb))\n    [<Extension; Inline>]\n    static member OnPageShow(this: Elt, cb: Dom.Element -> Dom.Event -> unit) = As<Elt> ((As<Elt'> this).on(\"pageshow\", cb))\n    [<Extension; Inline>]\n    static member OnPageShowView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.Event -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"pageshow\", view, cb))\n    [<Extension; Inline>]\n    static member OnPaste(this: Elt, cb: Dom.Element -> Dom.Event -> unit) = As<Elt> ((As<Elt'> this).on(\"paste\", cb))\n    [<Extension; Inline>]\n    static member OnPasteView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.Event -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"paste\", view, cb))\n    [<Extension; Inline>]\n    static member OnPause(this: Elt, cb: Dom.Element -> Dom.Event -> unit) = As<Elt> ((As<Elt'> this).on(\"pause\", cb))\n    [<Extension; Inline>]\n    static member OnPauseView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.Event -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"pause\", view, cb))\n    [<Extension; Inline>]\n    static member OnPlay(this: Elt, cb: Dom.Element -> Dom.Event -> unit) = As<Elt> ((As<Elt'> this).on(\"play\", cb))\n    [<Extension; Inline>]\n    static member OnPlayView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.Event -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"play\", view, cb))\n    [<Extension; Inline>]\n    static member OnPlaying(this: Elt, cb: Dom.Element -> Dom.Event -> unit) = As<Elt> ((As<Elt'> this).on(\"playing\", cb))\n    [<Extension; Inline>]\n    static member OnPlayingView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.Event -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"playing\", view, cb))\n    [<Extension; Inline>]\n    static member OnPointerLockChange(this: Elt, cb: Dom.Element -> Dom.Event -> unit) = As<Elt> ((As<Elt'> this).on(\"pointerlockchange\", cb))\n    [<Extension; Inline>]\n    static member OnPointerLockChangeView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.Event -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"pointerlockchange\", view, cb))\n    [<Extension; Inline>]\n    static member OnPointerLockError(this: Elt, cb: Dom.Element -> Dom.Event -> unit) = As<Elt> ((As<Elt'> this).on(\"pointerlockerror\", cb))\n    [<Extension; Inline>]\n    static member OnPointerLockErrorView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.Event -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"pointerlockerror\", view, cb))\n    [<Extension; Inline>]\n    static member OnPopState(this: Elt, cb: Dom.Element -> Dom.Event -> unit) = As<Elt> ((As<Elt'> this).on(\"popstate\", cb))\n    [<Extension; Inline>]\n    static member OnPopStateView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.Event -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"popstate\", view, cb))\n    [<Extension; Inline>]\n    static member OnProgress(this: Elt, cb: Dom.Element -> Dom.Event -> unit) = As<Elt> ((As<Elt'> this).on(\"progress\", cb))\n    [<Extension; Inline>]\n    static member OnProgressView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.Event -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"progress\", view, cb))\n    [<Extension; Inline>]\n    static member OnRateChange(this: Elt, cb: Dom.Element -> Dom.Event -> unit) = As<Elt> ((As<Elt'> this).on(\"ratechange\", cb))\n    [<Extension; Inline>]\n    static member OnRateChangeView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.Event -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"ratechange\", view, cb))\n    [<Extension; Inline>]\n    static member OnReadyStateChange(this: Elt, cb: Dom.Element -> Dom.Event -> unit) = As<Elt> ((As<Elt'> this).on(\"readystatechange\", cb))\n    [<Extension; Inline>]\n    static member OnReadyStateChangeView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.Event -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"readystatechange\", view, cb))\n    [<Extension; Inline>]\n    static member OnRepeatEvent(this: Elt, cb: Dom.Element -> Dom.Event -> unit) = As<Elt> ((As<Elt'> this).on(\"repeatEvent\", cb))\n    [<Extension; Inline>]\n    static member OnRepeatEventView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.Event -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"repeatEvent\", view, cb))\n    [<Extension; Inline>]\n    static member OnReset(this: Elt, cb: Dom.Element -> Dom.Event -> unit) = As<Elt> ((As<Elt'> this).on(\"reset\", cb))\n    [<Extension; Inline>]\n    static member OnResetView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.Event -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"reset\", view, cb))\n    [<Extension; Inline>]\n    static member OnResize(this: Elt, cb: Dom.Element -> Dom.UIEvent -> unit) = As<Elt> ((As<Elt'> this).on(\"resize\", cb))\n    [<Extension; Inline>]\n    static member OnResizeView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.UIEvent -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"resize\", view, cb))\n    [<Extension; Inline>]\n    static member OnScroll(this: Elt, cb: Dom.Element -> Dom.UIEvent -> unit) = As<Elt> ((As<Elt'> this).on(\"scroll\", cb))\n    [<Extension; Inline>]\n    static member OnScrollView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.UIEvent -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"scroll\", view, cb))\n    [<Extension; Inline>]\n    static member OnSeeked(this: Elt, cb: Dom.Element -> Dom.Event -> unit) = As<Elt> ((As<Elt'> this).on(\"seeked\", cb))\n    [<Extension; Inline>]\n    static member OnSeekedView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.Event -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"seeked\", view, cb))\n    [<Extension; Inline>]\n    static member OnSeeking(this: Elt, cb: Dom.Element -> Dom.Event -> unit) = As<Elt> ((As<Elt'> this).on(\"seeking\", cb))\n    [<Extension; Inline>]\n    static member OnSeekingView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.Event -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"seeking\", view, cb))\n    [<Extension; Inline>]\n    static member OnSelect(this: Elt, cb: Dom.Element -> Dom.UIEvent -> unit) = As<Elt> ((As<Elt'> this).on(\"select\", cb))\n    [<Extension; Inline>]\n    static member OnSelectView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.UIEvent -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"select\", view, cb))\n    [<Extension; Inline>]\n    static member OnShow(this: Elt, cb: Dom.Element -> Dom.MouseEvent -> unit) = As<Elt> ((As<Elt'> this).on(\"show\", cb))\n    [<Extension; Inline>]\n    static member OnShowView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.MouseEvent -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"show\", view, cb))\n    [<Extension; Inline>]\n    static member OnStalled(this: Elt, cb: Dom.Element -> Dom.Event -> unit) = As<Elt> ((As<Elt'> this).on(\"stalled\", cb))\n    [<Extension; Inline>]\n    static member OnStalledView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.Event -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"stalled\", view, cb))\n    [<Extension; Inline>]\n    static member OnStorage(this: Elt, cb: Dom.Element -> Dom.Event -> unit) = As<Elt> ((As<Elt'> this).on(\"storage\", cb))\n    [<Extension; Inline>]\n    static member OnStorageView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.Event -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"storage\", view, cb))\n    [<Extension; Inline>]\n    static member OnSubmit(this: Elt, cb: Dom.Element -> Dom.Event -> unit) = As<Elt> ((As<Elt'> this).on(\"submit\", cb))\n    [<Extension; Inline>]\n    static member OnSubmitView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.Event -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"submit\", view, cb))\n    [<Extension; Inline>]\n    static member OnSuccess(this: Elt, cb: Dom.Element -> Dom.Event -> unit) = As<Elt> ((As<Elt'> this).on(\"success\", cb))\n    [<Extension; Inline>]\n    static member OnSuccessView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.Event -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"success\", view, cb))\n    [<Extension; Inline>]\n    static member OnSuspend(this: Elt, cb: Dom.Element -> Dom.Event -> unit) = As<Elt> ((As<Elt'> this).on(\"suspend\", cb))\n    [<Extension; Inline>]\n    static member OnSuspendView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.Event -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"suspend\", view, cb))\n    [<Extension; Inline>]\n    static member OnSVGAbort(this: Elt, cb: Dom.Element -> Dom.Event -> unit) = As<Elt> ((As<Elt'> this).on(\"SVGAbort\", cb))\n    [<Extension; Inline>]\n    static member OnSVGAbortView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.Event -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"SVGAbort\", view, cb))\n    [<Extension; Inline>]\n    static member OnSVGError(this: Elt, cb: Dom.Element -> Dom.Event -> unit) = As<Elt> ((As<Elt'> this).on(\"SVGError\", cb))\n    [<Extension; Inline>]\n    static member OnSVGErrorView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.Event -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"SVGError\", view, cb))\n    [<Extension; Inline>]\n    static member OnSVGLoad(this: Elt, cb: Dom.Element -> Dom.Event -> unit) = As<Elt> ((As<Elt'> this).on(\"SVGLoad\", cb))\n    [<Extension; Inline>]\n    static member OnSVGLoadView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.Event -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"SVGLoad\", view, cb))\n    [<Extension; Inline>]\n    static member OnSVGResize(this: Elt, cb: Dom.Element -> Dom.Event -> unit) = As<Elt> ((As<Elt'> this).on(\"SVGResize\", cb))\n    [<Extension; Inline>]\n    static member OnSVGResizeView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.Event -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"SVGResize\", view, cb))\n    [<Extension; Inline>]\n    static member OnSVGScroll(this: Elt, cb: Dom.Element -> Dom.Event -> unit) = As<Elt> ((As<Elt'> this).on(\"SVGScroll\", cb))\n    [<Extension; Inline>]\n    static member OnSVGScrollView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.Event -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"SVGScroll\", view, cb))\n    [<Extension; Inline>]\n    static member OnSVGUnload(this: Elt, cb: Dom.Element -> Dom.Event -> unit) = As<Elt> ((As<Elt'> this).on(\"SVGUnload\", cb))\n    [<Extension; Inline>]\n    static member OnSVGUnloadView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.Event -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"SVGUnload\", view, cb))\n    [<Extension; Inline>]\n    static member OnSVGZoom(this: Elt, cb: Dom.Element -> Dom.Event -> unit) = As<Elt> ((As<Elt'> this).on(\"SVGZoom\", cb))\n    [<Extension; Inline>]\n    static member OnSVGZoomView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.Event -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"SVGZoom\", view, cb))\n    [<Extension; Inline>]\n    static member OnTimeOut(this: Elt, cb: Dom.Element -> Dom.Event -> unit) = As<Elt> ((As<Elt'> this).on(\"timeout\", cb))\n    [<Extension; Inline>]\n    static member OnTimeOutView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.Event -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"timeout\", view, cb))\n    [<Extension; Inline>]\n    static member OnTimeUpdate(this: Elt, cb: Dom.Element -> Dom.Event -> unit) = As<Elt> ((As<Elt'> this).on(\"timeupdate\", cb))\n    [<Extension; Inline>]\n    static member OnTimeUpdateView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.Event -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"timeupdate\", view, cb))\n    [<Extension; Inline>]\n    static member OnTouchCancel(this: Elt, cb: Dom.Element -> Dom.Event -> unit) = As<Elt> ((As<Elt'> this).on(\"touchcancel\", cb))\n    [<Extension; Inline>]\n    static member OnTouchCancelView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.Event -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"touchcancel\", view, cb))\n    [<Extension; Inline>]\n    static member OnTouchEnd(this: Elt, cb: Dom.Element -> Dom.Event -> unit) = As<Elt> ((As<Elt'> this).on(\"touchend\", cb))\n    [<Extension; Inline>]\n    static member OnTouchEndView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.Event -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"touchend\", view, cb))\n    [<Extension; Inline>]\n    static member OnTouchEnter(this: Elt, cb: Dom.Element -> Dom.Event -> unit) = As<Elt> ((As<Elt'> this).on(\"touchenter\", cb))\n    [<Extension; Inline>]\n    static member OnTouchEnterView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.Event -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"touchenter\", view, cb))\n    [<Extension; Inline>]\n    static member OnTouchLeave(this: Elt, cb: Dom.Element -> Dom.Event -> unit) = As<Elt> ((As<Elt'> this).on(\"touchleave\", cb))\n    [<Extension; Inline>]\n    static member OnTouchLeaveView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.Event -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"touchleave\", view, cb))\n    [<Extension; Inline>]\n    static member OnTouchMove(this: Elt, cb: Dom.Element -> Dom.Event -> unit) = As<Elt> ((As<Elt'> this).on(\"touchmove\", cb))\n    [<Extension; Inline>]\n    static member OnTouchMoveView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.Event -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"touchmove\", view, cb))\n    [<Extension; Inline>]\n    static member OnTouchStart(this: Elt, cb: Dom.Element -> Dom.Event -> unit) = As<Elt> ((As<Elt'> this).on(\"touchstart\", cb))\n    [<Extension; Inline>]\n    static member OnTouchStartView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.Event -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"touchstart\", view, cb))\n    [<Extension; Inline>]\n    static member OnTransitionEnd(this: Elt, cb: Dom.Element -> Dom.Event -> unit) = As<Elt> ((As<Elt'> this).on(\"transitionend\", cb))\n    [<Extension; Inline>]\n    static member OnTransitionEndView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.Event -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"transitionend\", view, cb))\n    [<Extension; Inline>]\n    static member OnUnload(this: Elt, cb: Dom.Element -> Dom.UIEvent -> unit) = As<Elt> ((As<Elt'> this).on(\"unload\", cb))\n    [<Extension; Inline>]\n    static member OnUnloadView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.UIEvent -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"unload\", view, cb))\n    [<Extension; Inline>]\n    static member OnUpdateReady(this: Elt, cb: Dom.Element -> Dom.Event -> unit) = As<Elt> ((As<Elt'> this).on(\"updateready\", cb))\n    [<Extension; Inline>]\n    static member OnUpdateReadyView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.Event -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"updateready\", view, cb))\n    [<Extension; Inline>]\n    static member OnUpgradeNeeded(this: Elt, cb: Dom.Element -> Dom.Event -> unit) = As<Elt> ((As<Elt'> this).on(\"upgradeneeded\", cb))\n    [<Extension; Inline>]\n    static member OnUpgradeNeededView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.Event -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"upgradeneeded\", view, cb))\n    [<Extension; Inline>]\n    static member OnUserProximity(this: Elt, cb: Dom.Element -> Dom.Event -> unit) = As<Elt> ((As<Elt'> this).on(\"userproximity\", cb))\n    [<Extension; Inline>]\n    static member OnUserProximityView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.Event -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"userproximity\", view, cb))\n    [<Extension; Inline>]\n    static member OnVersionChange(this: Elt, cb: Dom.Element -> Dom.Event -> unit) = As<Elt> ((As<Elt'> this).on(\"versionchange\", cb))\n    [<Extension; Inline>]\n    static member OnVersionChangeView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.Event -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"versionchange\", view, cb))\n    [<Extension; Inline>]\n    static member OnVisibilityChange(this: Elt, cb: Dom.Element -> Dom.Event -> unit) = As<Elt> ((As<Elt'> this).on(\"visibilitychange\", cb))\n    [<Extension; Inline>]\n    static member OnVisibilityChangeView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.Event -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"visibilitychange\", view, cb))\n    [<Extension; Inline>]\n    static member OnVolumeChange(this: Elt, cb: Dom.Element -> Dom.Event -> unit) = As<Elt> ((As<Elt'> this).on(\"volumechange\", cb))\n    [<Extension; Inline>]\n    static member OnVolumeChangeView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.Event -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"volumechange\", view, cb))\n    [<Extension; Inline>]\n    static member OnWaiting(this: Elt, cb: Dom.Element -> Dom.Event -> unit) = As<Elt> ((As<Elt'> this).on(\"waiting\", cb))\n    [<Extension; Inline>]\n    static member OnWaitingView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.Event -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"waiting\", view, cb))\n    [<Extension; Inline>]\n    static member OnWheel(this: Elt, cb: Dom.Element -> Dom.WheelEvent -> unit) = As<Elt> ((As<Elt'> this).on(\"wheel\", cb))\n    [<Extension; Inline>]\n    static member OnWheelView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.WheelEvent -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"wheel\", view, cb))\n    // }}\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2014 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\nnamespace WebSharper.UI.Next\nopen WebSharper\n\nopen System\nopen WebSharper.UI.Next.Client\n\n[<JavaScript>]\ntype Flow<'T>(render: Var<Doc> -> ('T -> unit) -> unit) =\n\n    new (define: Func<Func<'T, unit>, Doc>) =\n        Flow(fun var cont -> Var.Set var (define.Invoke (Func<_,_>(cont))))\n\n    member this.Render = render\n\n[<JavaScript>]\n[<Sealed>]\ntype Flow =\n\n    static member Map f (x: Flow<'A>) =\n        Flow(fun var cont -> x.Render var (fun r -> (f r) |> cont))\n\n    // \"Unwrap\" the value from the flowlet, use it as an argument to the\n    // continuation k, and return the value of the applied continuation.\n\n    // Semantically, what we're doing here is running the form (or other\n    // input mechanism, but let's stick with thinking about forms), getting\n    // the result, and then using this as an input to the continuation.\n    static member Bind (m: Flow<'A>) (k: 'A -> Flow<'B>) =\n        Flow(fun var cont -> m.Render var (fun r -> (k r).Render var cont))\n\n    static member Return x =\n        Flow(fun var cont -> cont x)\n\n    static member Embed (fl: Flow<'A>) =\n        let var = Var.Create Doc.Empty\n        fl.Render var ignore\n        Doc.EmbedView var.View\n\n    static member Define (f: ('A -> unit) -> Doc) =\n        Flow(Func<_,_>(fun (x: Func<'A, unit>) -> f x.Invoke))\n\n    static member Static doc =\n        Flow(fun var cont -> Var.Set var doc; cont ())\n\n[<JavaScript>]\n[<Sealed>]\ntype FlowBuilder() =\n    member x.Bind(comp, func) = Flow.Bind comp func\n    member x.Return(value) = Flow.Return value\n    member x.ReturnFrom(inner: Flow<'A>) = inner\n\ntype Flow with\n\n    static member Do =\n        FlowBuilder()\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2014 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\nnamespace WebSharper.UI.Next\n\n// NOTES: need better facilities for the user to construct routers. In particular,\n// should be possible to encode numbers, semi-automatically provide bijections,\n// and so on.\n\nopen WebSharper\nopen WebSharper.JavaScript\nmodule A = AppendList\nmodule T = Trie\n\ntype RouteMap<'T> =\n    {\n        Des : (list<string> * Map<string, string>) -> 'T\n        Ser : 'T -> (list<string> * Map<string, string>)\n    }\n\n[<JavaScript>]\nmodule Route =\n\n    let private NoHash (s: string) =\n        if s.StartsWith(\"#\") then s.Substring(1) else s\n\n    [<Inline \"decodeURIComponent($x)\">]\n    [<MethodImpl(MethodImplOptions.NoInlining)>]\n    let private Decode (x: string) : string = U\n\n    [<Inline \"encodeURIComponent($x)\">]\n    [<MethodImpl(MethodImplOptions.NoInlining)>]\n    let private Encode (x: string) : string = U\n\n    type T =\n        private\n        | Route of AppendList<string> * Map<string, string>\n\n    let ParseHash (hash: string) =\n        let hash = NoHash hash\n        let path, query =\n            match hash.IndexOf '?' with\n            | -1 -> hash, \"\"\n            | i -> hash.[..i-1], hash.[i+1..]\n        let path =\n            if path = \"\" then [||] \n            else path.Split('/') |> Array.map Decode\n            |> A.FromArray\n        let query =\n            query.Split('&')\n            |> Array.map (fun s ->\n                match s.IndexOf '=' with\n                | -1 -> Decode s, \"\"\n                | i -> Decode (s.[..i-1]), Decode (s.[i+1..]))\n            |> Map.ofArray\n        Route (path, query)\n\n    let MakeHash (Route (path, query)) =\n        let path =\n            A.ToArray path\n            |> Array.map Encode\n            |> String.concat \"/\"\n        if Map.isEmpty query then\n            path\n        else\n            path + \"?\" +\n            (query\n            |> Seq.map (fun (KeyValue(k, v)) -> Encode k + \"=\" + Encode v)\n            |> String.concat \"&\")\n\n    [<MethodImpl(MethodImplOptions.NoInlining)>]\n    let SameHash a b =\n        NoHash a = NoHash b\n\n    let ToList (Route (rt, q)) =\n        let path =\n            A.ToArray rt\n            |> Array.toList\n        path, q\n\n    let FromList (xs, q) =\n        let a =\n            List.toArray xs\n            |> A.FromArray\n        Route(a, q)\n\n    let Append (Route (pa, qa)) (Route (pb, qb)) =\n        Route (A.Append pa pb, Map.foldBack Map.add qa qb)\n\ntype RouteContext<'T> =\n    {\n        /// Local site changes call for changing the route.\n        UpdateRoute : Route.T -> unit\n    }\n\ntype RouteBody<'T> =\n    {\n        /// Local route has changed by user via History API or similar.\n        OnRouteChanged : Route.T -> unit\n        /// This site has been selected.\n        OnSelect : unit -> unit\n        /// Identifier.\n        RouteId : int\n        /// Value characterizing the site.\n        RouteValue : 'T\n    }\n\ntype RouteId =\n    | RouteId of int\n\ntype RoutePart<'T> =\n    | Part of int * (RouteContext<'T> -> RouteBody<'T>)\n\ntype Router<'T> =\n    | R of option<'T> * Trie<string,RoutePart<'T>>\n\n[<JavaScript>]\nmodule Routing =\n\n    let InstallMap (rt: RouteMap<'T>) : Var<'T> =\n        let win = JS.Window\n        let same a b = rt.Ser a = rt.Ser b\n        let cur () =\n            Route.ParseHash win.Location.Hash\n            |> Route.ToList\n            |> rt.Des\n        let var = Var.Create (cur ())\n        let set value =\n            if not (same var.Value value) then\n                var.Value <- value\n        let onUpdate = System.Action<_>(fun (evt: Dom.Event) -> set (cur ()))\n        win.Onpopstate <- onUpdate\n        win.Onhashchange <- onUpdate\n        var.View\n        |> View.Sink (fun loc ->\n            let ha = Route.MakeHash (Route.FromList (rt.Ser loc))\n            if not (Route.SameHash win.Location.Hash ha) then\n                win.Location.Replace (\"#\" + ha))\n        var\n\n    // Given some sub-sites in a Trie, the code tries to preserve an equality:\n    //\n    //    globalRoute = currentSite.Prefix ++ currentSite.Route currentSite.State\n\n    [<MethodImpl(MethodImplOptions.NoInlining)>]\n    let DoRoute map route =\n        map.Des (Route.ToList route)\n\n    [<MethodImpl(MethodImplOptions.NoInlining)>]\n    let DoLink map va =\n        Route.FromList (map.Ser va)\n\n    let DefineRoute r init render =\n        let state = Var.Create init\n        let id = Fresh.Int ()\n        let site = render (RouteId id) state\n        let t =\n            T.Leaf (Part (id, fun ctx ->\n                state.View\n                |> View.Sink (fun va ->\n                    ctx.UpdateRoute (DoLink r va))\n                {\n                    OnRouteChanged = fun route ->\n                        state.Value <- DoRoute r route\n                    OnSelect = fun () ->\n                        ctx.UpdateRoute (DoLink r state.Value)\n                    RouteId = id\n                    RouteValue = site\n                }))\n        R (Some site, t)\n\n    let MergeRouters sites =\n        let sites = Array.ofSeqNonCopying sites\n        let merged =\n            sites\n            |> Seq.map (fun (R (_, t)) -> t)\n            |> T.Merge\n        let value =\n            sites\n            |> Seq.tryPick (fun (R (x, _)) -> x)\n        match merged with\n        | None -> failwith \"Invalid Site.Merge: need more prefix disambiguation\"\n        | Some t -> R (value, t)\n\n    type State<'T> =\n        {\n            mutable Bodies : Dictionary<int,RouteBody<'T>>\n            CurrentRoute : Var<Route.T>\n            mutable CurrentSite : int\n            mutable Selection : Var<'T>\n        }\n\n    let ComputeBodies trie =\n        let d = Dictionary()\n        trie\n        |> T.ToArray\n        |> Array.iter (fun body ->\n            d.[body.RouteId] <- body)\n        d\n\n    /// Set current route if needed.\n    let SetCurrentRoute state route =\n        if state.CurrentRoute.Value <> route then\n            state.CurrentRoute.Value <- route\n\n    /// User updates URL manually or via history API.\n    let OnGlobalRouteChange state site rest =\n        if state.CurrentSite <> site.RouteId then\n            state.CurrentSite <- site.RouteId\n            state.Selection.Value <- site.RouteValue\n        site.OnRouteChanged rest\n\n    /// A given site updates its internal state.\n    let OnInternalSiteUpdate state ix prefix rest =\n        if state.CurrentSite = ix then\n            let route = Route.Append (Route.FromList (prefix, Map.empty)) rest\n            SetCurrentRoute state route\n\n    /// User selects an different current site, which may update the global route.\n    let OnSelectSite state (RouteId id) =\n        if state.CurrentSite <> id then\n            state.CurrentSite <- id\n            state.Bodies.[id].OnSelect ()\n\n    let Install key (R (va, site)) =\n        let currentRoute = InstallMap { Ser = Route.ToList; Des = Route.FromList }\n        let state =\n            {\n                Bodies = U\n                CurrentRoute = currentRoute\n                CurrentSite = 0\n                Selection = U\n            }\n        // Initialize all sub-sites\n        let siteTrie =\n            site\n            |> T.Map (fun prefix (Part (id, init)) ->\n                init { UpdateRoute = OnInternalSiteUpdate state id prefix })\n        state.Bodies <- ComputeBodies siteTrie\n        // Setup handling changes to the currently selected site\n        let parseRoute route =\n            let path, query = Route.ToList route\n            T.Lookup siteTrie path\n            // TODO check query\n        let glob =\n            match parseRoute currentRoute.Value with\n            | T.NotFound ->\n                match va with\n                | None -> failwith \"Site.Install fails on empty site\"\n                | Some v -> v\n                |> Var.Create\n            | T.Found (site, rest) ->\n                state.CurrentSite <- site.RouteId\n                Var.Create site.RouteValue\n        state.Selection <- glob\n        glob.View\n        |> View.Sink (fun site ->\n            OnSelectSite state (key site))\n        // Setup handling currentRoute changes\n        let updateRoute route =\n            match parseRoute route with\n            | T.Found (site, rest) ->\n                Route.FromList (rest, Map.empty)\n                |> OnGlobalRouteChange state site\n            | T.NotFound -> ()\n        updateRoute currentRoute.Value\n        currentRoute.View\n        |> View.Sink updateRoute\n        glob\n\n[<JavaScript>]\n[<Sealed>]\ntype RouteMap =\n\n    static member CreateWithQuery ser des =\n        { Ser = ser; Des = des }\n\n    static member Create ser des =\n        { Ser = (fun x -> ser x, Map.empty); Des = fst >> des }\n\n    static member Install map =\n        Routing.InstallMap map\n\n[<JavaScript>]\n[<Sealed>]\ntype Router =\n\n    static member Dir prefix sites =\n        Router.Prefix prefix (Router.Merge sites)\n\n    static member Install key site =\n        Routing.Install key site\n\n    static member Merge sites =\n        Routing.MergeRouters sites\n\n    static member Prefix prefix (R (va, tree)) =\n        R (va, T.Prefix prefix tree)\n\n    static member Route r init render =\n        Routing.DefineRoute r init render\n", "namespace WebSharper.UI.Next\n\nopen WebSharper\nopen WebSharper.JavaScript\nopen WebSharper.UI.Next\nopen WebSharper.UI.Next.Notation\nopen WebSharper.JQuery\n\n[<JavaScript>]\nmodule Input =\n\n    type MousePosSt =\n        {\n            mutable Active : bool\n            PosV : Var<int * int>\n        }\n\n    type MouseBtnSt =\n        {\n            mutable Active : bool\n            Left : Var<bool>\n            Middle : Var<bool>\n            Right : Var<bool>\n        }\n\n    let MousePosSt = { Active = false; PosV = Var.Create (0, 0) }\n    let MouseBtnSt =\n        {\n            Active = false;\n            Left = Var.Create false\n            Middle = Var.Create false\n            Right = Var.Create false\n        }\n\n    // Add the button listener if it hasn't been added already.\n    // Button listener adds mousedown and mouseup events, which modify\n    // MouseBtnSt vars.\n    let ActivateButtonListener =\n        let buttonListener (evt: Dom.MouseEvent) down =\n            match evt.Button with\n            | 0 -> Var.Set MouseBtnSt.Left down\n            | 1 -> Var.Set MouseBtnSt.Middle down\n            | 2 -> Var.Set MouseBtnSt.Right down\n            | _ -> ()\n\n        if not MouseBtnSt.Active then\n            MouseBtnSt.Active <- true\n            JS.Document.AddEventListener(\"mousedown\",\n                (fun (evt: DomEvent) -> buttonListener (evt :?> Dom.MouseEvent) true), false)\n            JS.Document.AddEventListener(\"mouseup\",\n                (fun (evt: DomEvent) -> buttonListener (evt :?> Dom.MouseEvent) false), false)\n\n    [<Sealed>]\n    type Mouse =\n\n        static member Position =\n\n            let onMouseMove (evt: Dom.Event) =\n                // We know this is a mouse event, so safe to downcast\n                let mEvt = evt :?> Dom.MouseEvent\n                Var.Set MousePosSt.PosV (mEvt.ClientX, mEvt.ClientY)\n\n            // Add the mouse movement event if it's not there already.\n            if not MousePosSt.Active then\n                JS.Document.AddEventListener(\"mousemove\", onMouseMove, false)\n                MousePosSt.Active <- true\n\n            View.FromVar MousePosSt.PosV\n\n        static member LeftPressed =\n            ActivateButtonListener\n            MouseBtnSt.Left.View\n\n        static member MiddlePressed =\n            ActivateButtonListener\n            MouseBtnSt.Middle.View\n\n        static member RightPressed =\n            ActivateButtonListener\n            MouseBtnSt.Right.View\n\n        static member MousePressed =\n            ActivateButtonListener\n            // True if any button is pressed\n            View.Const (fun l m r -> l || m || r)\n            <*> MouseBtnSt.Left.View\n            <*> MouseBtnSt.Middle.View\n            <*> MouseBtnSt.Right.View\n\n    type Key = int\n\n    // State for keyboard listener: which keys are pressed, whether the listener\n    // is active, and the last key that has been presed\n    type KeyListenerSt =\n        {\n            KeysPressed : Var<Key list>\n            mutable KeyListenerActive : bool\n            LastPressed : Var<Key>\n        }\n\n    let KeyListenerState =\n        {\n            KeysPressed = Var.Create []\n            KeyListenerActive = false\n            LastPressed = Var.Create (-1)\n        }\n\n    let ActivateKeyListener =\n        if not KeyListenerState.KeyListenerActive then\n            // Using JQuery for cross-compatibility.\n            JQuery.Of(JS.Document).Keydown(fun el evt ->\n                let keyCode = evt.Which\n                Var.Set KeyListenerState.LastPressed keyCode\n                let xs = Var.Get KeyListenerState.KeysPressed\n                if not (List.exists (fun x -> x = keyCode) xs) then\n                    KeyListenerState.KeysPressed.Value <- xs @ [keyCode]\n            ) |> ignore\n\n            JQuery.Of(JS.Document).Keyup(fun el evt ->\n                let keyCode = evt.Which\n                Var.Update KeyListenerState.KeysPressed\n                    (List.filter (fun x -> x <> keyCode))\n            ) |> ignore\n\n    [<Sealed>]\n    type Keyboard =\n\n        static member KeysPressed =\n            ActivateKeyListener\n            KeyListenerState.KeysPressed.View\n\n        static member LastPressed =\n            ActivateKeyListener\n            KeyListenerState.LastPressed.View\n\n        static member IsPressed key =\n            ActivateKeyListener\n            View.Map (List.exists (fun x -> x = key))\n                KeyListenerState.KeysPressed.View\n"],
"names": [],
"mappings": "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"
}
