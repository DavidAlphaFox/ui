{
"version": 3,
"sourceRoot": "Source",
"sources": ["WebSharper.UI.Next/Abbrev.fs", "WebSharper.UI.Next/AppendList.fs", "WebSharper.UI.Next/DomUtility.fs", "WebSharper.UI.Next/Trie.fs", "WebSharper.UI.Next/Snap.fs", "WebSharper.UI.Next/Reactive.fs", "WebSharper.UI.Next/Models.fs", "WebSharper.UI.Next/Animation.fs", "WebSharper.UI.Next/Attr.Client.fs", "WebSharper.UI.Next/Doc.Client.fs", "WebSharper.UI.Next/Flow.fs", "WebSharper.UI.Next/Routing.fs", "WebSharper.UI.Next/Input.fs"],
"sourcesContent": ["// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2014 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\nnamespace WebSharper.UI.Next\n\nopen System\nopen System.Collections\nopen WebSharper\nopen WebSharper.JavaScript\n\nmodule Array =\n\n    /// Returns defaultValue if array is empty.\n    /// Otherwise makes a binary tree of the array elements and uses reduction to combine\n    /// all items into a single value.\n    [<JavaScript>]\n    let TreeReduce (defaultValue: 'A) (reduction: 'A -> 'A -> 'A) (array: 'A[]) : 'A =\n        let l = array.Length\n        let rec loop off len =\n            match len with\n            | n when n <= 0 -> defaultValue\n            | 1 when off >= 0 && off < l ->\n                array.[off]\n            | n ->\n                let l2 = len / 2\n                let a = loop off l2\n                let b = loop (off + l2) (len - l2)\n                reduction a b\n        loop 0 l\n\n    /// Returns defaultValue if array is empty.\n    /// Otherwise makes a binary tree of the array elements and uses reduction to combine \n    /// all items into a single value using the mapping function first on each item.\n    [<JavaScript>]\n    let MapTreeReduce (mapping: 'A -> 'B) (defaultValue: 'B) (reduction: 'B -> 'B -> 'B) (array: 'A[]) : 'B =\n        let l = array.Length\n        let rec loop off len =\n            match len with\n            | n when n <= 0 -> defaultValue\n            | 1 when off >= 0 && off < l ->\n                mapping array.[off]\n            | n ->\n                let l2 = len / 2\n                let a = loop off l2\n                let b = loop (off + l2) (len - l2)\n                reduction a b\n        loop 0 l\n\n    [<JavaScript>]\n    /// Same as Array.ofSeq, but if argument is an array, it does not copy it.\n    let ofSeqNonCopying (xs: seq<'T>) : 'T [] =\n        if xs :? System.Array then\n            xs :?> 'T[]\n        elif xs :? _ list then\n            Array.ofList (xs :?> 'T list)\n        elif Object.ReferenceEquals(xs, null) then\n            [||]\n        else\n            let q : 'T [] = [||]\n            use o = xs.GetEnumerator()\n            while o.MoveNext() do\n                q.JS.Push(o.Current) |> ignore\n            q\n\n    [<JavaScript>]\n    /// Unsafe operation, modifies each element of an array by a mapping function.\n    let mapInPlace (f: 'T1 -> 'T2) (arr: 'T1 []) =\n        if IsClient then\n            for i = 0 to Array.length arr - 1 do\n                arr.JS.[i] <- As (f arr.JS.[i])\n            As<'T2[]> arr\n        else Array.map f arr\n\nmodule internal String =\n\n    [<JavaScript>]\n    let isBlank s =\n        String.forall Char.IsWhiteSpace s\n\n/// Abbreviations and small utilities for this assembly.\n[<AutoOpen>]\nmodule internal Abbrev =\n\n    type Dictionary<'K,'V> = Generic.Dictionary<'K,'V>\n    type Document = Dom.Document\n    type Element = Dom.Element\n    type HashSet<'T> = Generic.HashSet<'T>\n    type IComparable = System.IComparable\n    type IEnumerable = Collections.IEnumerable\n    type IEnumerable<'T> = Generic.IEnumerable<'T>\n    type IEqualityComparer<'T> = Generic.IEqualityComparer<'T>\n    type MethodImplAttribute = System.Runtime.CompilerServices.MethodImplAttribute\n    type MethodImplOptions = System.Runtime.CompilerServices.MethodImplOptions\n    type Node = Dom.Node\n    type Object = System.Object\n    type TextNode = Dom.Text\n    type DomEvent = Dom.Event\n\n    [<JavaScript; Inline>]\n    let U<'T> = As<'T> JS.Undefined\n\n    [<Inline \"$f()\">]\n    let lock root f = lock root f\n\n    [<Inline; JavaScript>]\n    let ( ? ) (x: obj) (y: string) = ( ? ) x y\n\n    [<Inline; JavaScript>]\n    let ( ?<- ) (x: obj) (y: string) (z: obj) = ( ?<- ) x y z\n\n    [<JavaScript>]\n    module Fresh =\n\n        let mutable private counter = 0\n\n        let Int () =\n            counter <- counter + 1\n            counter\n\n        let Id () =\n            counter <- counter + 1\n            \"uid\" + string counter\n\n    [<JavaScript>]\n    module HashSet =\n\n        let ToArray (set: HashSet<'T>) =\n            let arr = Array.create set.Count JS.Undefined\n            set.CopyTo(arr)\n            arr\n\n        let Except (excluded: HashSet<'T>) (included: HashSet<'T>) =\n            let set = HashSet<'T>(ToArray included)\n            set.ExceptWith(ToArray excluded)\n            set\n\n        let Intersect (a: HashSet<'T>) (b: HashSet<'T>) =\n            let set = HashSet<'T>(ToArray a)\n            set.IntersectWith(ToArray b)\n            set\n\n        let Filter (ok: 'T -> bool) (set: HashSet<'T>) =\n            HashSet<'T>(ToArray set |> Array.filter ok)\n\n    [<JavaScript>]\n    module Dict =\n\n        let ToKeyArray (d: Dictionary<_,_>) =\n            let arr = Array.create d.Count JS.Undefined\n            d |> Seq.iteri (fun i kv -> arr.[i] <- kv.Key)\n            arr\n\n        let ToValueArray (d: Dictionary<_,_>) =\n            let arr = Array.create d.Count JS.Undefined\n            d |> Seq.iteri (fun i kv -> arr.[i] <- kv.Value)\n            arr\n\n    module Queue =\n\n        [<Inline \"$q\">]\n        let ToArray (q: Generic.Queue<_>) = q.ToArray()\n\n    [<JavaScript>]\n    [<Sealed>]\n    type Slot<'T,'K when 'K : equality>(key: 'T -> 'K, value: 'T) =\n        member s.Value = value\n\n        override s.Equals(o: obj) =\n            key value = key (o :?> Slot<'T,'K>).Value\n\n        override s.GetHashCode() = hash (key value)\n\n    [<JavaScript>]\n    type Slot =\n        static member Create key value = Slot(key, value)\n\n    [<JavaScript>]\n    module Async =\n\n        [<Direct \"console.log('WebSharper UI.Next: Uncaught asynchronous exception', $e)\">]\n        let OnError (e: exn) = ()\n\n        let StartTo comp k =\n            Async.StartWithContinuations (comp, k, OnError, ignore)\n\n        [<Inline \"WebSharper.Concurrency.scheduler().Fork($f)\">]\n        let Schedule f =\n            async { return f () }\n            |> Async.Start\n\n    [<JavaScript>]\n    module Mailbox =\n\n        type MailboxState =\n            | Idle = 0\n            | Working = 1\n            | WorkingMore = 2\n\n        /// Simplified MailboxProcessor implementation.\n        let StartProcessor procAsync =\n            let st = ref MailboxState.Idle\n            let rec work() =\n                async {\n                    do! procAsync\n                    match !st with\n                    | MailboxState.Working -> \n                        st := MailboxState.Idle\n                    | MailboxState.WorkingMore ->\n                        st := MailboxState.Working\n                        return! work() \n                    | _ -> ()\n                }\n            let post() =\n                match !st with\n                | MailboxState.Idle ->\n                    st := MailboxState.Working\n                    Async.Start (work()) \n                | MailboxState.Working -> \n                    st := MailboxState.WorkingMore\n                | _ -> ()\n            post\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2014 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\nnamespace WebSharper.UI.Next\nopen WebSharper\n\nopen System.Collections.Generic\n\ntype AppendList<'T> =\n    | AL0\n    | AL1 of 'T\n    | AL2 of AppendList<'T> * AppendList<'T>\n    | AL3 of 'T []\n\n[<JavaScript>]\nmodule AppendList =\n\n    type T<'T> = AppendList<'T>\n\n    let Empty<'T> : T<'T> = AL0\n\n    let Append x y =\n        match x, y with\n        | AL0, x | x, AL0 -> x\n        | _ -> AL2 (x, y)\n\n    let Concat xs =\n        Array.ofSeqNonCopying xs\n        |> Array.TreeReduce Empty Append\n\n    let Single x =\n        AL1 x\n\n    let ToArray xs =\n        let out = Queue()\n        let rec loop xs =\n            match xs with\n            | AL0 -> ()\n            | AL1 x -> out.Enqueue x\n            | AL2 (x, y) -> loop x; loop y\n            | AL3 xs -> Array.iter (fun v -> out.Enqueue v) xs\n        loop xs\n        out.ToArray()\n\n    let FromArray xs =\n        match Array.length xs with\n        | 0 -> AL0\n        | 1 -> AL1 xs.[0]\n        | _ -> AL3 (Array.copy xs)\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2014 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\nnamespace WebSharper.UI.Next\n\nopen WebSharper\nopen WebSharper.JavaScript\nopen WebSharper.JQuery\n\n/// Utility functions for manipulating DOM.\n[<JavaScript>]\nmodule internal DomUtility =\n\n    /// The current DOM Document.\n    let Doc = JS.Document\n\n    /// Appends a child node to the given DOM element.\n    [<MethodImpl(MethodImplOptions.NoInlining)>]\n    let AppendTo (ctx: Element) node =\n        ctx.AppendChild(node) |> ignore\n\n    /// Removes all attributes from the given DOM element.\n    let ClearAttrs (ctx: Element) =\n        while ctx.HasAttributes() do\n            ctx.RemoveAttributeNode(ctx.Attributes.[0] :?> _) |> ignore\n\n    /// Removes all child nodes from the given DOM element.\n    let Clear (ctx: Element) =\n        while ctx.HasChildNodes() do\n            ctx.RemoveChild(ctx.FirstChild) |> ignore\n\n    /// Creates a new DOM element.\n    [<MethodImpl(MethodImplOptions.NoInlining)>]\n    let CreateElement (name: string) =\n        Doc.CreateElement name\n\n    /// Creates an element in the SVG namespace.\n    [<MethodImpl(MethodImplOptions.NoInlining)>]\n    let CreateSvgElement (name: string) =\n        Doc.CreateElementNS(\"http://www.w3.org/2000/svg\", name)\n\n    /// Creates a new DOM text node with the given value.\n    [<MethodImpl(MethodImplOptions.NoInlining)>]\n    let CreateText s =\n        Doc.CreateTextNode(s)\n\n    /// Creates a new DOM attribute.\n    let CreateAttr name value =\n        let a = Doc.CreateAttribute(name)\n        a.Value <- value\n        a\n\n    /// Removes a DOM attribute.\n    let RemoveAttr (el: Element) (attrName: string) =\n        el.RemoveAttribute attrName\n\n    /// Sets the value of the attribute given by\n    /// `name` to `value` in element `el`.\n    let SetAttr (el: Element) name value =\n        el.SetAttribute(name, value)\n\n    [<Direct \"$target.setProperty($name, $value)\">]\n    let private SetProperty (target: obj) (name: string) (value: string) = ()\n\n    /// Sets a style property.\n    let SetStyle (el: Element) name value =\n        SetProperty el?style name value\n\n    /// Safe remove of a node\n    let RemoveNode (parent: Element) (el: Node) =\n        // make sure not to remove already removed nodes\n        if Object.ReferenceEquals(el.ParentNode, parent) then\n            parent.RemoveChild(el) |> ignore\n\n    /// Position in a `children` list of a DOM Element\n    /// where a node can be inserted.\n    [<AllowNullLiteral>]\n    type InsertPos [<Inline \"$x\">] private (x: Node) =\n        [<Inline>]\n        static member AtEnd = null : InsertPos\n        [<Inline>]\n        static member BeforeNode n = InsertPos n\n    [<Inline>]\n    let AtEnd = InsertPos.AtEnd\n    [<Inline>]\n    let BeforeNode n = InsertPos.BeforeNode n\n\n    /// Inserts a new child node into the tree under\n    /// a given `parent` at given `pos`.\n    let InsertAt (parent: Element) (pos: InsertPos) (node: Node) =\n        let currentPos (node: Node) =\n            match node.NextSibling with\n            | null -> AtEnd\n            | s -> BeforeNode s\n        let canSkip =\n            node.ParentNode ===. parent\n            && pos ===. currentPos node\n        if not canSkip then\n            parent.InsertBefore(node, As pos) |> ignore\n\n    /// Adds a class.\n    let AddClass (element: Element) (cl: string) =\n        JQuery.Of(element).AddClass(cl) |> ignore\n\n    /// Removes a class.\n    let RemoveClass (element: Element) (cl: string) =\n        JQuery.Of(element).RemoveClass(cl) |> ignore\n\n    /// Retrieve the children of an element as an array.\n    let ChildrenArray (element: Element) : Dom.Node[] =\n        let a = [||]\n        for i = 0 to element.ChildNodes.Length - 1 do\n            a.JS.Push(element.ChildNodes.[i]) |> ignore\n        a\n\n    /// Iterate through a NodeList assuming it's all Elements.\n    let IterSelector (el: Element) (selector: string) (f: Element -> unit) =\n        let l = el.QuerySelectorAll(selector)\n        for i = 0 to l.Length - 1 do f (l.[i] :?> Element)\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2014 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\nnamespace WebSharper.UI.Next\nopen WebSharper\n\nopen System.Collections.Generic\nmodule M = Map\n\n/// Trie lookup structure.\ntype Trie<'K,'V when 'K : comparison> =\n    | TrieBranch of Map<'K,Trie<'K,'V>> // invariant: not empty\n    | TrieEmpty\n    | TrieLeaf of 'V\n\n/// Trie combinators.\n[<JavaScript>]\nmodule Trie =\n\n    /// Branch trie, maintaining invariant.\n    let TrieBranch xs =\n        if M.isEmpty xs then TrieEmpty else TrieBranch xs\n\n    /// Singleton trie.\n    let Leaf v =\n        TrieLeaf v\n\n    /// Prefix a trie - becomes a branch.\n    let Prefix key trie =\n        TrieBranch (Map [key, trie])\n\n    /// Finds a value in a multi-map.\n    [<MethodImpl(MethodImplOptions.NoInlining)>]\n    let MultiFind key map =\n        defaultArg (M.tryFind key map) []\n\n    /// Adds a value to a multi-map.\n    let MultiAdd key value map =\n        Map.add key (value :: MultiFind key map) map\n\n    /// Makes sure all results are Some.\n    let AllSome (xs: seq<option<'T>>) =\n        let e = xs.GetEnumerator()\n        let r = ResizeArray()\n        let mutable ok = true\n        while ok && e.MoveNext() do\n            match e.Current with\n            | None -> ok <- false\n            | Some x -> r.Add(x)\n        if ok then Some (r.ToArray() :> seq<_>) else None\n\n    /// Merges multiple maps into one given a merge function on values.\n    let MergeMaps merge maps =\n        Seq.collect M.toSeq maps\n        |> Seq.fold (fun s (k, v) -> MultiAdd k v s) M.empty\n        |> M.toSeq\n        |> Seq.map (fun (k, vs) -> merge vs |> Option.map (fun v -> (k, v)))\n        |> AllSome\n        |> Option.map Map.ofSeq\n\n    /// Checks for leaves.\n    [<MethodImpl(MethodImplOptions.NoInlining)>]\n    let IsLeaf t =\n        match t with\n        | TrieLeaf _ -> true\n        | _ -> false\n\n    /// Merges tries.\n    let rec Merge (ts: seq<_>) =\n        let ts = Array.ofSeqNonCopying ts\n        match ts.Length with\n        | 0 -> Some TrieEmpty\n        | 1 -> Some ts.[0]\n        | _ ->\n            // leaves do not merge\n            if Array.exists IsLeaf ts then None else\n                ts\n                |> Seq.choose (function\n                    | TrieBranch map -> Some map\n                    | _ -> None)\n                |> MergeMaps Merge\n                |> Option.map TrieBranch\n\n    /// Inner loop for Map function.\n    let rec MapLoop loc f trie =\n        match trie with\n        | TrieBranch mp ->\n            mp\n            |> M.map (fun k v -> MapLoop (loc @ [k]) f v)\n            |> TrieBranch\n        | TrieEmpty -> TrieEmpty\n        | TrieLeaf x -> TrieLeaf (f loc x)\n\n    /// Maps a function.\n    let Map f trie =\n        MapLoop [] f trie\n\n    /// Map with a counter.\n    let Mapi f trie =\n        let counter = ref 0\n        let next () =\n            let c = !counter\n            counter := c + 1\n            c\n        Map (fun x -> f (next ()) x) trie\n\n    /// Collects all values.\n    let ToArray trie =\n        // TODO: more efficient than this.\n        let all = Queue()\n        Map (fun _ v -> all.Enqueue v) trie\n        |> ignore\n        all.ToArray()\n\n    /// Result of lookup function.\n    type LookupResult<'K,'V> =\n        | Found of value: 'V * remainder: list<'K>\n        | NotFound\n\n    /// Lookup main loop.\n    let rec Look key trie =\n        match trie, key with\n        | TrieLeaf v, _ -> Found (v, key)\n        | TrieBranch map, k :: ks ->\n            match M.tryFind k map with\n            | Some trie -> Look ks trie\n            | None -> NotFound\n        | _ -> NotFound\n\n    /// Looks up a value in the trie.\n    let Lookup trie key =\n        Look (Seq.toList key) trie\n\n    /// Empty trie.\n    let Empty<'K,'V when 'K : comparison> : Trie<'K,'V> =\n        TrieEmpty\n\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2014 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\nnamespace WebSharper.UI.Next\n\nopen System.Collections.Generic\nopen WebSharper\nopen WebSharper.JavaScript\n\n(*\n\nSnap implements a snapshot of a time-varying value.\n\nFinal states:\n\n    Forever     -- will never be obsolete\n    Obsolete    -- is obsolete\n\nDistinguishing Forever state is important as it avoids a class of\nmemory leaks connected with waiting on a Snap to become obsolete\nwhen it will never do so.\n\nState transitions:\n\n    Waiting         -> Forever      // MarkForever\n    Waiting         -> Obsolete     // MarkObsolete\n    Waiting         -> Ready        // MarkReady\n    Ready           -> Obsolete     // MarkObsolete\n\n*)\n\n[<JavaScript false>]\ntype ISnap =\n    abstract Obsolete : unit -> unit\n    abstract IsNotObsolete : unit -> bool\n\ntype OnObsoleted = Union<ISnap, unit -> unit>\n\n[<JavaScript>]\ntype SnapState<'T> =\n    | Forever of 'T\n    | [<Constant null>] Obsolete\n    | Ready of 'T * Queue<OnObsoleted>\n    | Waiting of Queue<'T -> unit> * Queue<OnObsoleted>\n\n[<JavaScript; AutoOpen>]\nmodule SnapInternals =\n\n    [<Inline \"typeof $o == 'object' ? $doObs($o) : $o()\">]\n    let obs (o: OnObsoleted) doObs =  \n        match o with\n        | Union1Of2 sn -> doObs sn\n        | Union2Of2 f -> f()\n\n    [<Inline \"typeof $o == 'object' ? $doObs($o) : $doFunc($o)\">]\n    let clean (o: OnObsoleted) doObs doFunc =  \n        match o with\n        | Union1Of2 sn -> doObs sn\n        | Union2Of2 f -> doFunc f\n\ntype Snap<'T> =\n    {\n        [<Name \"s\">] mutable State : SnapState<'T>\n    }\n\n    [<JavaScript>]\n    static member Obsolete(sn: Snap<'T>) =\n        match sn.State with\n        | Forever _ | Obsolete -> ()\n        | Ready (_, q) | Waiting (_, q) ->\n            sn.State <- Obsolete\n            let qa = Queue.ToArray q\n            for i = 0 to qa.Length - 1 do \n                obs qa.[i] (fun sn -> sn.Obsolete())\n\n    interface ISnap with\n        member this.Obsolete() =\n            Snap.Obsolete(this)\n\n        member this.IsNotObsolete() =\n            match this.State with\n            | Obsolete -> false\n            | _ -> true\n\n[<Proxy(typeof<ISnap>)>]\ntype internal ISnapProxy =\n    [<Inline>]\n    member this.Obsolete() =\n        Snap.Obsolete(As<Snap<obj>> this)\n\n    [<Inline \"$this.s\">]\n    member this.IsNotObsolete() = X<bool>\n\n[<JavaScript>]\nmodule Snap =\n\n  // constructors\n\n    [<Inline>]\n    let Make st = { State = st }\n\n    [<Inline>]\n    let Create () = Make (Waiting (Queue(), Queue()))\n\n    [<Inline>]\n    let CreateForever v = Make (Forever v)\n\n    [<Inline>]\n    let CreateWithValue v = Make (Ready (v, Queue()))\n\n  // misc\n\n    [<Inline>]\n    let IsForever snap =\n        match snap.State with\n        | Forever _ -> true\n        | _ -> false\n\n    [<Inline>]\n    let IsObsolete snap =\n        match snap.State with\n        | Obsolete -> true\n        | _ -> false\n\n    [<Inline>]\n    let IsDone snap =\n        match snap.State with\n        | Forever _ | Ready _ -> true\n        | _ -> false\n\n  // transitions\n\n    let MarkForever sn v =\n        match sn.State with\n        | Waiting (q, _) ->\n            sn.State <- Forever v\n            let qa = Queue.ToArray q\n            for i = 0 to qa.Length - 1 do \n                qa.[i] v\n        | _ -> ()\n\n    [<Inline>]\n    let MarkObsolete (sn: Snap<_>) =\n        (sn :> ISnap).Obsolete()\n\n    let MarkReady sn v =\n        match sn.State with\n        | Waiting (q1, q2) ->\n            sn.State <- Ready (v, q2)\n            let qa = Queue.ToArray q1\n            for i = 0 to qa.Length - 1 do \n                qa.[i] v\n        | _ -> ()\n\n    let MarkDone res sn v =\n        if IsForever sn then\n            MarkForever res v\n        else\n            MarkReady res v\n\n    let EnqueueSafe (q: Queue<_>) x =\n        q.Enqueue x\n        if q.Count % 20 = 0 then\n            let qcopy = q.ToArray()\n            q.Clear()\n            for i = 0 to qcopy.Length - 1 do\n                clean qcopy.[i]\n                    (fun sn -> if sn.IsNotObsolete() then q.Enqueue (Union1Of2 sn))\n                    (fun f -> q.Enqueue (Union2Of2 f)) \n\n  // eliminators\n\n    let When snap avail (obs: ISnap) =\n        match snap.State with\n        | Forever v -> avail v\n        | Obsolete -> obs.Obsolete()\n        | Ready (v, q1) -> EnqueueSafe q1 (Union1Of2 obs); avail v\n        | Waiting (q1, q2) -> q1.Enqueue avail; EnqueueSafe q2 (Union1Of2 obs)\n\n    let WhenRun snap avail obs =\n        match snap.State with\n        | Forever v -> avail v\n        | Obsolete -> obs()\n        | Ready (v, q1) -> q1.Enqueue (Union2Of2 obs); avail v\n        | Waiting (q1, q2) -> q1.Enqueue avail; q2.Enqueue (Union2Of2 obs)\n\n    let WhenReady snap avail =\n        match snap.State with\n        | Forever v\n        | Ready (v, _) -> avail v\n        | Obsolete -> ()\n        | Waiting (q1, _) -> q1.Enqueue avail\n\n    let WhenObsolete snap (obs: ISnap) =\n        match snap.State with\n        | Forever v -> ()\n        | Obsolete -> obs.Obsolete()\n        | Ready (v, q) -> EnqueueSafe q (Union1Of2 obs)\n        | Waiting (q1, q2) -> EnqueueSafe q2 (Union1Of2 obs)\n\n    let WhenObsoleteRun snap obs =\n        match snap.State with\n        | Forever v -> ()\n        | Obsolete -> obs()\n        | Ready (v, q) -> q.Enqueue (Union2Of2 obs)\n        | Waiting (q1, q2) -> q2.Enqueue (Union2Of2 obs)\n\n    let ValueAndForever snap =\n        match snap.State with\n        | Forever v -> Some (v, true)\n        | Ready (v, _) -> Some (v, false)\n        | _ -> None\n\n  // combinators\n\n    let Join snap =\n        let res = Create ()\n        let onReady x =\n            let y = x ()\n            When y (fun v ->\n                if IsForever y && IsForever snap then\n                    MarkForever res v\n                else\n                    MarkReady res v) res\n        When snap onReady res\n        res\n\n    let JoinInner snap =\n        let res = Create ()\n        let onReady x =\n            let y = x ()\n            When y (fun v ->\n                if IsForever y && IsForever snap then\n                    MarkForever res v\n                else\n                    MarkReady res v) res\n            WhenObsolete snap y\n        When snap onReady res\n        res\n\n    let CreateForeverAsync a =\n        let o = Make (Waiting (Queue(), Queue()))\n        Async.StartTo a (MarkForever o)\n        o\n\n    let Sequence (snaps : seq<Snap<'T>>) =\n        let snaps = Array.ofSeq snaps\n        if Array.isEmpty snaps then CreateForever Seq.empty\n        else\n            let res = Create () : Snap<seq<'T>>\n            let w = ref (snaps.Length - 1)\n            let cont _ =\n                if !w = 0 then\n                    // all source snaps should have a value\n                    let vs = \n                        snaps |> Array.map (fun s -> \n                            match s.State with\n                            | Forever v | Ready (v, _) -> v\n                            | _ -> failwith \"value not found by View.Sequence\")\n                    if Array.forall IsForever snaps then\n                        MarkForever res (vs :> seq<_>)\n                    else\n                        MarkReady res (vs :> seq<_>)\n                else\n                    decr w\n            snaps\n            |> Array.iter (fun s -> When s cont res)\n            res\n\n    let Map fn sn =\n        match sn.State with\n        | Forever x -> CreateForever (fn x) // optimization\n        | _ ->\n            let res = Create ()\n            When sn (fun a -> MarkDone res sn (fn a)) res\n            res\n\n    let Copy sn =\n        match sn.State with\n        | Forever _ \n        | Obsolete -> sn // optimization\n        | Ready (v, _) ->\n            let res = CreateWithValue v\n            WhenObsolete sn res\n            res\n        | Waiting _ ->\n            let res = Create ()\n            When sn (MarkDone res sn) res\n            res\n\n    let MapCachedBy eq prev fn sn =\n        let fn x =\n            match !prev with\n            | Some (x', y) when eq x x' -> y\n            | _ ->\n                let y = fn x\n                prev := Some (x, y)\n                y\n        Map fn sn\n\n    let Map2Opt1 fn x sn2 = Map (fun y -> fn x y) sn2\n    let Map2Opt2 fn y sn1 = Map (fun x -> fn x y) sn1\n    let Map2 fn sn1 sn2 =\n        match sn1.State, sn2.State with\n        | Forever x, Forever y -> CreateForever (fn x y) // optimization\n        | Forever x, _ -> Map2Opt1 fn x sn2 // optimize for known sn1\n        | _, Forever y -> Map2Opt2 fn y sn1 // optimize for known s2\n        | _ ->\n            let res = Create ()\n            let cont _ =\n                if not (IsDone res) then \n                    match ValueAndForever sn1, ValueAndForever sn2 with\n                    | Some (x, f1), Some (y, f2) ->\n                        if f1 && f2 then\n                            MarkForever res (fn x y)\n                        else\n                            MarkReady res (fn x y) \n                    | _ -> ()\n            When sn1 cont res\n            When sn2 cont res\n            res\n\n    let Map2Unit sn1 sn2 =\n        match sn1.State, sn2.State with\n        | Forever (), Forever () -> CreateForever () // optimization\n        | Forever (), _ -> sn2 // optimize for known sn1\n        | _, Forever () -> sn1 // optimize for known s2\n        | _ ->\n            let res = Create ()\n            let cont () =\n                if not (IsDone res) then \n                    match ValueAndForever sn1, ValueAndForever sn2 with\n                    | Some (_, f1), Some (_, f2) ->\n                        if f1 && f2 then\n                            MarkForever res ()\n                        else\n                            MarkReady res () \n                    | _ -> ()\n            When sn1 cont res\n            When sn2 cont res\n            res\n\n    let Map3Opt1 fn x y sn3   = Map (fun z -> fn x y z) sn3\n    let Map3Opt2 fn x z sn2   = Map (fun y -> fn x y z) sn2\n    let Map3Opt3 fn x sn2 sn3 = Map2 (fun y z -> fn x y z) sn2 sn3\n    let Map3Opt4 fn y z sn1   = Map (fun x -> fn x y z) sn1\n    let Map3Opt5 fn y sn1 sn3 = Map2 (fun x z -> fn x y z) sn1 sn3\n    let Map3Opt6 fn z sn1 sn2 = Map2 (fun x y -> fn x y z) sn1 sn2\n    let Map3 fn sn1 sn2 sn3 =\n        match sn1.State, sn2.State, sn3.State with\n        | Forever x, Forever y, Forever z -> CreateForever (fn x y z)\n        | Forever x, Forever y, _         -> Map3Opt1 fn x y sn3  \n        | Forever x, _,         Forever z -> Map3Opt2 fn x z sn2  \n        | Forever x, _,         _         -> Map3Opt3 fn x sn2 sn3\n        | _,         Forever y, Forever z -> Map3Opt4 fn y z sn1  \n        | _,         Forever y, _         -> Map3Opt5 fn y sn1 sn3\n        | _,         _,         Forever z -> Map3Opt6 fn z sn1 sn2    \n        | _,         _,         _         ->\n            let res = Create ()\n            let cont _ =\n                if not (IsDone res) then \n                    match ValueAndForever sn1, ValueAndForever sn2, ValueAndForever sn3 with\n                    | Some (x, f1), Some (y, f2), Some (z, f3) ->\n                        if f1 && f2 && f3 then\n                            MarkForever res (fn x y z)\n                        else\n                            MarkReady res (fn x y z) \n                    | _ -> ()\n            When sn1 cont res\n            When sn2 cont res\n            When sn3 cont res\n            res\n\n    let SnapshotOn sn1 sn2 =\n        let res = Create ()\n        let cont _ =\n            if not (IsDone res) then \n                match ValueAndForever sn1, ValueAndForever sn2 with\n                | Some (_, f1), Some (y, f2) ->\n                    if f1 || f2 then\n                        MarkForever res y \n                    else\n                        MarkReady res y\n                | _ -> ()\n        When sn1 cont res\n        WhenReady sn2 cont\n        res\n\n    let MapAsync fn snap =\n        let res = Create ()\n        When snap\n            (fun v -> Async.StartTo (fn v) (MarkDone res snap))\n            res\n        res\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2014 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\nnamespace WebSharper.UI.Next\n\n#nowarn \"40\" // AsyncAwait let rec\n\nopen WebSharper\n\n[<JavaScript>]\ntype IRef<'T> =\n    [<Name \"RGet\">]\n    abstract Get : unit -> 'T\n    [<Name \"RSet\">]\n    abstract Set : 'T -> unit\n    [<Name \"RVal\">]\n    abstract Value : 'T with get, set\n    [<Name \"RUpd\">]\n    abstract Update : ('T -> 'T) -> unit\n    [<Name \"RUpdM\">]\n    abstract UpdateMaybe : ('T -> 'T option) -> unit\n    [<Name \"RView\">]\n    abstract View : View<'T>\n    [<Name \"RId\">]\n    abstract Id : string\n\nand [<JavaScript>] View<'T> =\n    | V of (unit -> Snap<'T>)\n\n[<AutoOpen>]\nmodule ViewOptimization =\n    open WebSharper.JavaScript\n    [<Inline \"$x\">]\n    let V (x: unit -> Snap<'T>) = V x\n    [<Inline \"$x\">]\n    let (|V|) (x: View<'T>) = let (V v) = x in v\n    [<Inline \"$x\">]\n    let getSnapV (x: Snap<View<'T>>) = Snap.Map (|V|) x\n    [<Inline \"$x\">]\n    let getSnapF (x: 'A -> View<'T>) = x >> (|V|)\n    [<Inline \"null\">]\n    let jsNull<'T>() = Unchecked.defaultof<'T>\n    [<Inline \"Error().stack\">]\n    let jsStack<'T>() = \"\"\n    \n/// Var either holds a Snap or is in Const state.\n[<JavaScript>]\ntype Var<'T> =\n    {\n        [<Name \"o\">] mutable Const : bool\n        [<Name \"c\">] mutable Current : 'T\n        [<Name \"s\">] mutable Snap : Snap<'T>\n        [<Name \"i\">] Id : int\n        [<Name \"v\">] VarView : View<'T>\n    }\n\n    [<Inline>]\n    member this.View = this.VarView\n\n    interface IRef<'T> with\n        member this.Get() = Var.Get this\n        member this.Set v = Var.Set this v\n        member this.Value\n            with get() = Var.Get this\n            and set v = Var.Set this v\n        member this.Update f = Var.Update this f\n        member this.UpdateMaybe f =\n            match f (Var.Get this) with\n            | None -> ()\n            | Some v -> Var.Set this v\n        member this.View = this.View\n        member this.Id = \"uinref\" + string (Var.GetId this)\n\nand [<JavaScript; Sealed>] Var =\n\n    [<MethodImpl(MethodImplOptions.NoInlining)>]\n    static member Create v =\n        let mutable var = jsNull()\n        var <-\n            {\n                Const = false\n                Current = v\n                Snap = Snap.CreateWithValue v\n                Id = Fresh.Int ()\n                VarView = V (fun () -> var.Snap)\n            }\n        var\n\n    static member CreateLogged (name: string) v =\n        if not (WebSharper.JavaScript.JS.Global?UINVars) then\n            WebSharper.JavaScript.JS.Global?UINVars <- [||]\n        let res = Var.Create v\n        WebSharper.JavaScript.JS.Global?UINVars?push([| name; WebSharper.JavaScript.Pervasives.As res |])\n        res\n\n    static member Create() =\n        let mutable var = jsNull()\n        var <-\n            {\n                Const = false\n                Current = ()\n                Snap = Snap.CreateWithValue ()\n                Id = Fresh.Int ()\n                VarView = V (fun () -> var.Snap)\n            }\n        var\n\n    [<Inline>]\n    static member Get var =\n        var.Current\n\n    static member Set var value =\n        if var.Const then\n            printfn \"WebSharper UI.Next: invalid attempt to change value of a Var after calling SetFinal\"\n        else\n            Snap.MarkObsolete var.Snap\n            var.Current <- value\n            var.Snap <- Snap.CreateWithValue value\n\n    static member SetFinal var value =\n        if var.Const then\n            printfn \"WebSharper UI.Next: invalid attempt to change value of a Var after calling SetFinal\"\n        else\n            Snap.MarkObsolete var.Snap\n            var.Const <- true\n            var.Current <- value\n            var.Snap <- Snap.CreateForever value\n\n    static member Update var fn =\n        Var.Set var (fn (Var.Get var))\n\n    [<Inline>]\n    static member GetId var =\n        var.Id\n\n    [<Inline>]\n    static member Observe var =\n        var.Snap\n\ntype [<JavaScript>] Updates = \n    {\n        [<Name \"c\">] mutable Current : View<unit>\n        [<Name \"s\">] mutable Snap : Snap<unit>\n        [<Name \"v\">] VarView : View<unit>\n    }\n\n    [<Inline>]\n    member this.View = this.VarView\n\n    static member Create v =\n        let mutable var = jsNull()\n        var <-\n            {\n                Current = v\n                Snap = jsNull()\n                VarView = \n                    let obs () =\n                        let mutable c = var.Snap\n                        if obj.ReferenceEquals(c, null) then\n                            let (V observe) = var.Current\n                            c <- observe() |> Snap.Copy\n                            var.Snap <- c\n                            Snap.WhenObsoleteRun c (fun () -> \n                                var.Snap <- jsNull())\n                            c\n                        else c\n                    \n                    V obs\n            }\n        var\n\n    member this.Value\n        with [<Inline>] get() = this.Current\n        and set v =\n            let sn = this.Snap\n            if not (obj.ReferenceEquals(sn, null)) then\n                Snap.MarkObsolete sn\n            this.Current <- v\n\ntype ViewNode<'A,'B> =\n    {\n        [<Name \"e\">] NValue : 'B\n        [<Name \"r\">] NVar : Var<'A>\n        [<Name \"w\">] NView : View<'A>\n    }\n\ntype LazyView<'T> =\n    {\n        [<Name \"c\">] mutable Current : Snap<'T>\n        [<Name \"o\">] mutable Observe : unit -> Snap<'T>  \n    } \n\n[<JavaScript>]\n[<Sealed>]\ntype View =\n\n    [<Inline>]\n    static member FromVar (var: Var<'T>) =\n        var.View\n\n    static member CreateLazy observe =\n        let lv =\n            {\n                Current = jsNull()\n                Observe = observe \n            }\n        let obs () =\n            let mutable c = lv.Current\n            if obj.ReferenceEquals(c, null) then\n                c <- lv.Observe()\n                lv.Current <- c\n                if Snap.IsForever c then \n                    lv.Observe <- jsNull()\n                else\n                    Snap.WhenObsoleteRun c (fun () -> \n                        lv.Current <- jsNull()) \n                c\n            else c\n        V obs\n\n    static member Map fn (V observe) =\n        View.CreateLazy (fun () ->\n            observe () |> Snap.Map fn)\n\n    static member MapCachedBy eq fn (V observe) =\n        let vref = ref None\n        View.CreateLazy (fun () ->\n            observe () |> Snap.MapCachedBy eq vref fn)\n\n    static member MapCached fn v =\n        View.MapCachedBy (=) fn v\n\n    static member Map2 fn (V o1) (V o2) =\n        View.CreateLazy (fun () ->\n            let s1 = o1 ()\n            let s2 = o2 ()\n            Snap.Map2 fn s1 s2)\n\n    static member Map2Unit (V o1) (V o2) =\n        View.CreateLazy (fun () ->\n            let s1 = o1 ()\n            let s2 = o2 ()\n            Snap.Map2Unit s1 s2)\n\n    static member Map3 fn (V o1) (V o2) (V o3) =\n        View.CreateLazy (fun () ->\n            let s1 = o1 ()\n            let s2 = o2 ()\n            let s3 = o3 ()\n            Snap.Map3 fn s1 s2 s3)\n\n    static member MapAsync fn (V observe) =\n        View.CreateLazy (fun () -> observe () |> Snap.MapAsync fn)\n\n    static member MapAsync2 fn v1 v2 =\n        View.Map2 fn v1 v2 |> View.MapAsync id\n\n    static member Get (f: 'T -> unit) (V observe) =\n        let ok = ref false\n        let rec obs () =\n            Snap.WhenRun (observe ())\n                (fun v ->\n                    if not !ok then\n                        ok := true\n                        f v)\n                (fun () -> if not !ok then obs ())\n        obs ()\n\n    static member GetAsync v =\n        Async.FromContinuations (fun (ok, _, _) -> View.Get ok v)\n\n    static member SnapshotOn def (V o1) (V o2) =\n        let sInit = Snap.CreateWithValue def\n\n        let obs () =\n            let s1 = o1 ()\n            if Snap.IsObsolete sInit then\n                let s2 = o2 ()\n                Snap.SnapshotOn s1 s2\n            else\n                Snap.WhenObsolete s1 sInit\n                sInit\n\n        View.CreateLazy obs\n\n     // Collections --------------------------------------------------------------\n\n    static member MapSeqCachedBy<'A,'B,'K,'SeqA when 'K : equality and 'SeqA :> seq<'A>>\n            (key: 'A -> 'K) (conv: 'A -> 'B) (view: View<'SeqA>) =\n        // Save history only for t - 1, discard older history.\n        let state = ref (Dictionary())\n        view\n        |> View.Map (fun xs ->\n            let prevState = !state\n            let newState = Dictionary()\n            let result =\n                Seq.toArray xs\n                |> Array.mapInPlace (fun x ->\n                    let k = key x\n                    let res =\n                        if prevState.ContainsKey k\n                            then prevState.[k]\n                            else conv x\n                    newState.[k] <- res\n                    res)\n                :> seq<_>\n            state := newState\n            result)\n\n    static member MapSeqCached conv view =\n        View.MapSeqCachedBy (fun x -> x) conv view\n\n    static member ConvertSeqNode conv value =\n        let var = Var.Create value\n        let view = View.FromVar var\n        {\n            NValue = conv view\n            NVar = var\n            NView = view\n        }\n\n    static member MapSeqCachedViewBy<'A,'B,'K,'SeqA when 'K : equality and 'SeqA :> seq<'A>>\n            (key: 'A -> 'K) (conv: 'K -> View<'A> -> 'B) (view: View<'SeqA>) =\n        // Save history only for t - 1, discard older history.\n        let state = ref (Dictionary())\n        view\n        |> View.Map (fun xs ->\n            let prevState = !state\n            let newState = Dictionary()\n            let result =\n                Seq.toArray xs\n                |> Array.mapInPlace (fun x ->\n                    let k = key x\n                    let node =\n                        if prevState.ContainsKey k then\n                            let n = prevState.[k]\n                            Var.Set n.NVar x\n                            n\n                        else\n                            View.ConvertSeqNode (fun v -> conv k v) x\n                    newState.[k] <- node\n                    node.NValue)\n                :> seq<_>\n            state := newState\n            result)\n\n    static member MapSeqCachedView conv view =\n        View.MapSeqCachedViewBy (fun x -> x) (fun _ v -> conv v) view\n\n    [<Inline>]\n    static member Convert<'A, 'B when 'A : equality> (f: 'A -> 'B) v =\n        View.MapSeqCached f v\n\n    [<Inline>]\n    static member ConvertBy<'A, 'B, 'K when 'K : equality> (k: 'A -> 'K) (f: 'A -> 'B) v =\n        View.MapSeqCachedBy k f v\n\n    [<Inline>]\n    static member ConvertSeq<'A, 'B when 'A : equality> (f: View<'A> -> 'B) v =\n        View.MapSeqCachedView f v\n\n    [<Inline>]\n    static member ConvertSeqBy<'A, 'B, 'K when 'K : equality> (k: 'A -> 'K) (f: 'K -> View<'A> -> 'B) v =\n        View.MapSeqCachedViewBy k f v\n\n  // More cominators ------------------------------------------------------------\n\n    static member Join (V observe : View<View<'T>>) : View<'T> =\n        View.CreateLazy (fun () ->\n            Snap.Join (getSnapV (observe ())))\n\n    static member Bind (fn: 'A -> View<'B>) view =\n        View.Join (View.Map fn view)\n\n    static member JoinInner (V observe : View<View<'T>>) : View<'T> =\n        View.CreateLazy (fun () ->\n            Snap.JoinInner (getSnapV (observe ())))\n\n    static member BindInner fn view =\n        View.JoinInner (View.Map fn view)\n\n    static member UpdateWhile def v1 v2 =\n        let value = ref def\n        View.BindInner (fun pred ->\n            if pred then\n                View.Map (fun v ->\n                    value := v\n                    v\n                ) v2   \n            else View.Const (!value) \n        ) v1\n\n    static member Sequence views =\n        View.CreateLazy(fun () ->\n            views\n            |> Seq.map (fun (V observe) -> observe ())\n            |> Snap.Sequence)\n\n    static member Const x =\n        let o = Snap.CreateForever x\n        V (fun () -> o)\n\n    static member ConstAsync a =\n        let o = Snap.CreateForeverAsync a\n        V (fun () -> o)\n\n    static member TryWith (f: exn -> View<'T>) (V observe: View<'T>) : View<'T> =\n        View.CreateLazy (fun () ->\n            try\n                observe ()\n            with exn ->\n                let (V obs) = f exn\n                obs ()\n        )\n\n    static member TryFinally (f: unit -> unit) (V observe: View<'T>) : View<'T> =\n        View.CreateLazy (fun () ->\n            try\n                observe ()\n            finally\n                f ()\n        )\n\n    static member Sink act (V observe) =\n        let rec loop () =\n            let sn = observe ()\n            Snap.WhenRun sn act (fun () ->\n                Async.Schedule loop)\n        Async.Schedule loop\n\n    static member RemovableSink act (V observe) =\n        let cont = ref true\n        let rec loop () =\n            let sn = observe ()\n            Snap.WhenRun sn\n                (fun x -> if !cont then act x)\n                (fun () -> if !cont then Async.Schedule loop)\n        Async.Schedule loop\n        fun () -> cont := false\n\n    static member AsyncAwait filter view =\n        Async.FromContinuations <| fun (ok, _, _) ->\n            let rec remove =\n                View.RemovableSink (fun value ->\n                    if filter value then\n                        remove ()\n                        ok value\n                ) view\n            ()\n\n    static member Apply fn view =\n        View.Map2 (fun f x -> f x) fn view\n\ntype Var with\n\n    [<JavaScript>]\n    static member Lens (iref: IRef<_>) get update =\n        let id = Fresh.Id()\n        let view = iref.View |> View.Map get\n\n        { new IRef<'V> with\n\n            member this.Get() =\n                get (iref.Get())\n\n            member this.Set(v) =\n                iref.Update(fun t -> update t v)\n\n            member this.Value\n                with get () = get (iref.Get())\n                and set v = iref.Update(fun t -> update t v)\n\n            member this.Update(f) =\n                iref.Update(fun t -> update t (f (get t)))\n\n            member this.UpdateMaybe(f) =\n                iref.UpdateMaybe(fun t -> Option.map (fun x -> update t x) (f (get t)))\n\n            member this.View =\n                view\n\n            member this.Id =\n                id\n        }\n\ntype Var<'T> with\n\n    [<JavaScript>]\n    member v.Value\n        with [<Inline; Name \"get_VarValue\">] get () = Var.Get v\n        and [<Inline; Name \"set_VarValue\">] set value = Var.Set v value\n\n// These methods apply to any View<'A>, so we can use `type View with`\n// and they'll be compiled as normal instance methods on View<'A>.\ntype View<'A> with\n\n    [<JavaScript; Inline>]\n    member v.Map f = View.Map f v\n\n    //[<JavaScript; Inline>]\n    //member v.Map (f: System.Func<_, 'B>) =\n    //    View.Map (FSharpConvert.Fun f) v\n\n    [<JavaScript; Inline>]\n    member v.MapAsync f = View.MapAsync f v\n\n    //member v.MapAsync (f: System.Func<_, System.Threading.Tasks.Task<'B>>) =\n    //    v |> View.MapAsync (fun a ->\n    //        async {\n    //            let! res = f.Invoke(a) |> Async.AwaitTask\n    //            return res\n    //        })\n\n    [<JavaScript; Inline>]\n    member v.Bind f = View.Bind f v\n\n    [<JavaScript; Inline>]\n    member v.BindInner f = View.BindInner f v\n\n    //[<JavaScript; Inline>]\n    //member v.Bind (f: System.Func<_, View<'B>>) =\n    //    View.Bind (FSharpConvert.Fun f) v\n\n    [<JavaScript; Inline>]\n    member v.SnapshotOn init v' = View.SnapshotOn init v' v\n\n    [<JavaScript; Inline>]\n    member v.UpdateWhile init vPred = View.UpdateWhile init vPred v\n\n[<AutoOpen>]\nmodule IRefExtension =\n\n    type IRef<'T> with\n\n        [<JavaScript; Inline>]\n        member iref.Lens get update =\n            Var.Lens iref get update\n\ntype ViewBuilder =\n    | B\n\n    [<JavaScript; Inline>]\n    member b.Bind(x, f) = View.Bind f x\n\n    [<JavaScript; Inline>]\n    member b.Return x = View.Const x\n\n    [<JavaScript; Inline>]\n    member b.ReturnFrom(v: View<'T>) = v\n\n    [<JavaScript; Inline>]\n    member b.TryWith(v, f) = View.TryWith f v\n\n    [<JavaScript; Inline>]\n    member b.TryFinally(v, f) = View.TryFinally f v\n\ntype View with\n    [<JavaScript>]\n    static member Do = B\n\n[<Sealed; JavaScript>]\ntype Submitter<'T> (input: View<'T>, init: 'T) =\n    let var = Var.Create ()\n    let view = View.SnapshotOn init var.View input\n\n    [<Inline>]\n    member this.View = view\n\n    member this.Trigger() = var.Value <- ()\n\n    [<Inline>]\n    member this.Input = input\n\n[<Sealed; JavaScript>]\ntype Submitter =\n\n    [<Inline>]\n    static member CreateDefault input =\n        Submitter<_>(input, Unchecked.defaultof<_>)\n\n    [<Inline>]\n    static member Create input init =\n        Submitter<_>(input, init)\n\n    static member CreateOption input =\n        Submitter<_>(View.Map Some input, None)\n\n    [<Inline>]\n    static member View (s: Submitter<_>) =\n        s.View\n\n    [<Inline>]\n    static member Trigger (s: Submitter<_>) =\n        s.Trigger()\n\n    [<Inline>]\n    static member Input (s: Submitter<_>) =\n        s.Input\n\n[<assembly:System.Runtime.CompilerServices.Extension>]\ndo ()\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2014 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\nnamespace WebSharper.UI.Next\nopen WebSharper\n\nopen System\n\n[<JavaScript>]\ntype Key =\n    | Key of int\n\n    static member Fresh () = Key (Fresh.Int ())\n\n[<JavaScript>]\ntype Model<'I,'M>(var: Var<'M>, view: View<'I>) =\n\n    new (proj: Func<'M, 'I>, init: 'M) =\n        let var = Var.Create init\n        let view = View.Map proj.Invoke var.View\n        Model(var, view)\n\n    [<Inline>]\n    member this.Var = var\n    [<Inline>]\n    member this.View = view\n\n[<JavaScript>]\n[<Sealed>]\ntype Model =\n\n    static member Create proj init =\n        Model(Func<_,_>(proj), init)\n\n    static member Update update (m: Model<'I, 'M>) =\n        Var.Update m.Var (fun x -> update x; x)\n\n    [<Inline>]\n    static member View (m: Model<'I, 'M>) =\n        m.View\n\ntype Storage<'T> =\n    [<Name \"SAppend\">]\n    abstract member Append : appending: 'T -> ``to``: 'T[] -> 'T[]\n    [<Name \"SAppendMany\">]\n    abstract member AppendMany : appending: seq<'T> -> ``to``: 'T[] -> 'T[]\n    [<Name \"SPrepend\">]\n    abstract member Prepend : appending: 'T -> ``to``: 'T[] -> 'T[]\n    [<Name \"SPrependMany\">]\n    abstract member PrependMany : appending: seq<'T> -> ``to``: 'T[] -> 'T[]\n    [<Name \"SInit\">]\n    abstract member Init : unit -> 'T[]\n    [<Name \"SRemoveIf\">]\n    abstract member RemoveIf : ('T -> bool) -> 'T [] -> 'T[]\n    [<Name \"SSetAt\">]\n    abstract member SetAt : int -> 'T -> 'T[] -> 'T[]\n    [<Name \"SSet\">]\n    abstract member Set : 'T seq -> 'T[]\n\ntype Serializer<'T> =\n    {\n        Encode : 'T -> obj\n        Decode : obj -> 'T\n    }\n\n[<JavaScript>]\nmodule Serializer =\n    open WebSharper\n    open WebSharper.JavaScript\n\n    let Default =\n        {\n            Encode = box\n            Decode = unbox\n        }\n\n    [<Inline>]\n    let Typed =\n        {\n            Encode = WebSharper.Json.Encode<'T>\n            Decode = WebSharper.Json.Decode<'T>\n        }\n\n[<JavaScript>]\nmodule Storage =\n    open WebSharper\n    open WebSharper.JavaScript\n    \n    type private ArrayStorage<'T>(init) =\n\n        interface Storage<'T> with\n            member x.Append i arr = arr.JS.Push i |> ignore; arr\n            member x.AppendMany is arr = arr.JS.Push (Array.ofSeqNonCopying is) |> ignore; arr\n            member x.Prepend i arr = arr.JS.Unshift i |> ignore; arr\n            member x.PrependMany is arr = arr.JS.Unshift (Array.ofSeqNonCopying is) |> ignore; arr\n            member x.Init () = init\n            member x.RemoveIf pred arr = Array.filter (fun i -> not (pred i)) arr\n            member x.SetAt idx elem arr = arr.[idx] <- elem; arr\n            member x.Set coll = Seq.toArray coll\n\n    type private LocalStorageBackend<'T>(id : string, serializer : Serializer<'T>) =\n        let storage = JS.Window.LocalStorage\n        let set (arr : 'T[]) = \n            storage.SetItem(id, arr |> Array.map serializer.Encode |> Json.Stringify)\n            arr\n        let clear () = storage.RemoveItem(id)\n\n        interface Storage<'T> with\n            member x.Append i arr = arr.JS.Push i |> ignore; set arr\n            member x.AppendMany is arr = arr.JS.Push (Array.ofSeqNonCopying is) |> ignore; set arr\n            member x.Prepend i arr = arr.JS.Unshift i |> ignore; set arr\n            member x.PrependMany is arr = arr.JS.Unshift (Array.ofSeqNonCopying is) |> ignore; set arr\n\n            member x.Init () =\n                let item = storage.GetItem(id)\n                if item = null then [||]\n                else \n                    try\n                        let arr = As<obj []> <| Json.Parse(item)\n                        arr |> Array.map serializer.Decode\n                    with _ -> [||]\n\n            member x.RemoveIf pred arr = set <| Array.filter (fun i -> not (pred i)) arr\n            member x.SetAt idx elem arr = arr.[idx] <- elem; set arr\n            member x.Set coll = set <| Seq.toArray coll\n\n    let InMemory init =\n        new ArrayStorage<_>(init) :> Storage<_>\n\n    let LocalStorage id serializer =\n        new LocalStorageBackend<_>(id, serializer) :> Storage<_>\n\ntype ListModelState<'T> =\n    [<Inline>]\n    member this.Length =\n        JavaScript.Pervasives.As<'T[]>(this).Length\n    [<Inline>]\n    member this.Item\n        with get i = JavaScript.Pervasives.As<'T[]>(this).[i]\n    [<Inline>]\n    member this.ToArray() =                             \n        Array.copy (JavaScript.Pervasives.As<'T[]>(this))\n    [<Inline>]\n    member this.ToArray(pred: Predicate<'T>) =\n        Array.filter pred.Invoke (JavaScript.Pervasives.As<'T[]>(this))\n    interface seq<'T> with\n        member this.GetEnumerator() = (JavaScript.Pervasives.As<'T[]>(this)).GetEnumerator()\n        member this.GetEnumerator() = (JavaScript.Pervasives.As<'T seq>(this)).GetEnumerator()\n\n[<JavaScript>]\ntype ListModel<'Key, 'T when 'Key : equality>\n    (\n        key : System.Func<'T, 'Key>,\n        var: IRef<'T[]>,\n        storage : Storage<'T>\n    ) =\n\n    let v = var.View.Map(fun x -> Array.copy x :> _ seq)\n           \n    let it = Dictionary<'Key, Snap<option<'T>>>()\n\n    new (key: System.Func<'T, 'Key>, init: seq<'T>) =\n        let init = Seq.toArray init\n        ListModel<'Key, 'T>(key, Var.Create init, Storage.InMemory init)\n\n    new (key: System.Func<'T, 'Key>) =\n        ListModel<'Key, 'T>(key, [||])\n\n    new (key: System.Func<'T, 'Key>, storage: Storage<'T>) =\n        let var =\n            Seq.distinctBy key.Invoke (storage.Init ())\n            |> Seq.toArray\n            |> Var.Create\n        ListModel<'Key, 'T>(key, var, storage)\n\n    [<Inline>]\n    member this.key x = key.Invoke x\n    [<Inline>]\n    member this.Var = var\n    [<Inline>]\n    member this.Storage = storage\n    [<Inline>]\n    member this.View = v\n    [<Inline>]\n    member this.ViewState = JavaScript.Pervasives.As<View<ListModelState<'T>>> var.View\n    [<Inline>]\n    member this.itemSnaps = it\n\n    interface seq<'T> with\n        member this.GetEnumerator() =\n            (Seq.ofArray var.Value).GetEnumerator()\n\n        member this.GetEnumerator() =\n            var.Value.GetEnumerator()\n\n[<JavaScript>]\nmodule ListModels =\n               \n    let Contains keyFn item xs =\n        let t = keyFn item\n        Array.exists (fun it -> keyFn it = t) xs\n\ntype ListModel<'Key,'T> with\n\n    [<Inline>]\n    member m.Key x = m.key x\n\n    [<Inline>]\n    member m.Add item =\n        m.Append item\n\n    member m.ObsoleteKey key =\n        match m.itemSnaps.TryGetValue(key) with\n        | true, sn ->\n            Snap.MarkObsolete sn \n            m.itemSnaps.Remove key |> ignore\n        | _ -> ()\n\n    member m.ObsoleteAll() =\n        m.itemSnaps |> Seq.iter (fun ksn -> Snap.MarkObsolete ksn.Value)\n        m.itemSnaps.Clear()\n\n    member m.Append item =\n        let v = m.Var.Value\n        let t = m.Key item\n        match Array.tryFindIndex (fun it -> m.Key it = t) v with\n        | None -> m.Var.Value <- m.Storage.Append item v\n        | Some index -> \n            m.Var.Value <- m.Storage.SetAt index item v\n        m.ObsoleteKey t\n\n    member m.AppendMany items =\n        let toAppend = ResizeArray()\n        let v =\n            (m.Var.Value, items)\n            ||> Seq.fold (fun v item ->\n                let t = m.Key item\n                m.ObsoleteKey t\n                match Array.tryFindIndex (fun it -> m.Key it = t) v with\n                | Some index ->\n                    m.Storage.SetAt index item v\n                | None -> toAppend.Add item; v)\n        m.Var.Value <- m.Storage.AppendMany toAppend v\n\n    member m.Prepend item =\n        let v = m.Var.Value\n        let t = m.Key item\n        match Array.tryFindIndex (fun it -> m.Key it = t) v with\n        | None -> m.Var.Value <- m.Storage.Prepend item v\n        | Some index -> \n            m.Var.Value <- m.Storage.SetAt index item v\n        m.ObsoleteKey t\n\n    member m.PrependMany items =\n        let toPrepend = ResizeArray()\n        let v =\n            (m.Var.Value, items)\n            ||> Seq.fold (fun v item ->\n                let t = m.Key item\n                m.ObsoleteKey t\n                match Array.tryFindIndex (fun it -> m.Key it = t) v with\n                | Some index -> \n                    m.Storage.SetAt index item v\n                | None -> toPrepend.Add item; v)\n        m.Var.Value <- m.Storage.PrependMany toPrepend v\n\n    member m.Remove item =\n        let v = m.Var.Value\n        if ListModels.Contains m.key item v then\n            let keyFn = m.key\n            let k = keyFn item\n            m.Var.Value <- m.Storage.RemoveIf (fun i -> keyFn i = k) v\n            m.ObsoleteKey k\n\n    member m.RemoveBy (f: 'T -> bool) =\n        for v in m.Var.Value do\n            if f v then\n                m.ObsoleteKey (m.key v)\n        m.Var.Value <- m.Storage.RemoveIf f m.Var.Value\n\n    member m.RemoveByKey key =\n        m.Var.Value <- m.Storage.RemoveIf (fun i -> m.Key i = key) m.Var.Value\n        m.ObsoleteKey key\n\n    member m.Iter fn =\n        Array.iter fn m.Var.Value\n\n    member m.Set lst =\n        m.Var.Value <- m.Storage.Set lst\n        m.ObsoleteAll()\n\n    member m.ContainsKey key =\n        Array.exists (fun it -> m.key it = key) m.Var.Value\n\n    member m.ContainsKeyAsView key =\n        m.Var.View |> View.Map (Array.exists (fun it -> m.key it = key))\n\n    member m.Find pred =\n        Array.find pred m.Var.Value\n\n    member m.TryFind pred =\n        Array.tryFind pred m.Var.Value\n\n    member m.FindAsView pred =\n        m.Var.View |> View.Map (Array.find pred)\n\n    member m.TryFindAsView pred =\n        m.Var.View |> View.Map (Array.tryFind pred)\n\n    member m.FindByKey key =\n        Array.find (fun it -> m.key it = key) m.Var.Value\n\n    member m.TryFindByKey key =\n        Array.tryFind (fun it -> m.key it = key) m.Var.Value\n\n    member m.TryFindByKeyAsView key =\n        ViewOptimization.V (fun () -> \n            match m.itemSnaps.TryGetValue(key) with\n            | true, snap -> snap                \n            | _ ->\n                let it = m.TryFindByKey(key)\n                let sn = Snap.CreateWithValue it\n                m.itemSnaps.Add(key, sn)\n                sn\n        )\n\n    member m.FindByKeyAsView key =\n        m.TryFindByKeyAsView key |> View.Map Option.get\n\n    member m.UpdateAll fn =\n        m.Var.Update <| fun a ->\n            a |> Array.iteri (fun i x ->\n                fn x |> Option.iter (fun y -> a.[i] <- y))\n            m.Storage.Set a\n        m.ObsoleteAll()\n\n    member m.UpdateBy fn key =\n        let v = m.Var.Value\n        match Array.tryFindIndex (fun it -> m.key it = key) v with\n        | None -> ()\n        | Some index ->\n            match fn v.[index] with\n            | None -> ()\n            | Some value ->\n                m.Var.Value <- m.Storage.SetAt index value v\n                m.ObsoleteKey key\n\n    [<Inline>]\n    member m.UpdateByU(fn, key) =\n        m.UpdateBy fn key\n\n    member m.Clear () =\n        m.Var.Value <- m.Storage.Set Seq.empty\n        m.ObsoleteAll()\n\n    member m.Length =\n        m.Var.Value.Length\n\n    member m.LengthAsView =\n        m.Var.View |> View.Map (fun arr -> arr.Length)\n\n    member m.LensInto (get: 'T -> 'V) (update: 'T -> 'V -> 'T) (key : 'Key) : IRef<'V> =\n        let id = Fresh.Id()\n\n        let view = m.FindByKeyAsView(key) |> View.Map get\n    \n        { new IRef<'V> with\n\n            member r.Get() =\n                m.FindByKey key |> get\n\n            member r.Set(v) =\n                m.UpdateBy (fun i -> Some (update i v)) key\n\n            member r.Value\n                with get() = r.Get()\n                and set v = r.Set v\n\n            member r.Update(f) =\n                m.UpdateBy (fun i -> Some (update i (f (get i)))) key\n\n            member r.UpdateMaybe(f) =\n                m.UpdateBy (fun i -> Option.map (fun v -> update i v) (f (get i))) key\n\n            member r.View =\n                view\n\n            member r.Id =\n                id\n        }\n\n    [<Inline>]\n    member m.LensIntoU (get: 'T -> 'V, update: 'T -> 'V -> 'T, key : 'Key) : IRef<'V> =\n        m.LensInto get update key\n\n    member m.Lens (key: 'Key) =\n        m.LensInto id (fun _ -> id) key\n\n    member m.Value\n        with [<Inline>] get () = m.Var.Value :> seq<_>\n        and [<Inline>] set v = m.Set(v)\n\n[<JavaScript>]\ntype ListModel =\n\n    static member CreateWithStorage<'Key,'T when 'Key : equality>\n            (key: 'T -> 'Key) (storage : Storage<'T>) =\n        ListModel<'Key, 'T>(key, storage)\n\n    static member Create<'Key, 'T when 'Key : equality> (key: 'T -> 'Key) init =\n        ListModel.CreateWithStorage key (Storage.InMemory <| Seq.toArray init)\n\n    static member FromSeq init =\n        ListModel.Create id init\n\n    static member Wrap<'Key, 'T, 'U when 'Key : equality>\n            (underlying: ListModel<'Key, 'U>)\n            (extract: 'T -> 'U)\n            (createItem: 'U -> 'T)\n            (updateItem: 'T -> 'U -> 'T) =\n        let state = ref (Dictionary<'Key, 'T>())\n        let init =\n            underlying.Var.Value |> Array.map (fun u ->\n                let t = createItem u\n                (!state).[underlying.Key u] <- t\n                t)\n        let var : IRef<'T[]> =\n            underlying.Var.Lens\n                <| fun us ->\n                    let newState = Dictionary<'Key, 'T>()\n                    let ts =\n                        us |> Array.map (fun u ->\n                            let k = underlying.Key u\n                            let t =\n                                if (!state).ContainsKey(k) then\n                                    updateItem (!state).[k] u\n                                else\n                                    createItem u\n                            newState.[k] <- t\n                            t\n                        )\n                    state := newState\n                    ts\n                <| fun us ts ->\n                    let newState = Dictionary<'Key, 'T>()\n                    let us =\n                        ts |> Array.map (fun t ->\n                            let u = extract t\n                            newState.[underlying.Key u] <- t\n                            u)\n                    state := newState\n                    us\n        ListModel<'Key, 'T>(Func<_,_>(extract >> underlying.Key), var, Storage.InMemory init)\n\n    [<Inline>]\n    static member View (m: ListModel<_,_>) =\n        m.View\n\n    [<Inline>]\n    static member ViewState (m: ListModel<_,_>) =\n        m.ViewState\n\n    [<Inline>]\n    static member Key (m: ListModel<_,_>) =\n        m.key\n\ntype ListModel<'Key,'T> with\n\n    member this.Wrap extract wrap update =\n        ListModel.Wrap this extract wrap update\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2014 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\nnamespace WebSharper.UI.Next\n\nopen System\nopen WebSharper\nopen WebSharper.JavaScript\nopen System.Runtime.InteropServices\n\ntype Time = double\ntype NormalizedTime = double\n\n// Interpolation --------------------------------------------------------------\n\ntype Interpolation<'T> =\n    [<Name \"Interpolate\">]\n    abstract Interpolate : NormalizedTime -> 'T -> 'T -> 'T\n\n[<JavaScript>]\ntype DoubleInterpolation =\n    | DoubleInterpolation\n\n    interface Interpolation<double> with\n        member d.Interpolate t x y =\n            x + t * (y - x)\n\n[<JavaScript>]\n[<Sealed>]\ntype Interpolation =\n    static member Double = DoubleInterpolation :> Interpolation<_>\n\n// Easing ---------------------------------------------------------------------\n\n[<JavaScript>]\ntype Easing (transformTime : Converter<NormalizedTime, NormalizedTime>) =\n\n    member this.TransformTime t = transformTime.Invoke t\n    static member Custom f = Easing (fun t -> f t)\n\n[<JavaScript>]\nmodule Easings =\n\n    let CubicInOut =\n        let f t =\n            let t2 = t * t\n            let t3 = t2 * t\n            3. * t2 - 2. * t3\n        Easing.Custom f\n\ntype Easing with\n    static member CubicInOut = Easings.CubicInOut\n\n// Animation ------------------------------------------------------------------\n\ntype Anim<'T> =\n    private {\n        Compute : Time -> 'T\n        Duration : Time\n    }\n\ntype Animation =\n    | Finally of (unit -> unit)\n    | Work of Anim<unit>\n\n[<JavaScript>]\n[<Name \"An\">]\ntype Anim =\n    | Anim of AppendList<Animation>\n\n[<JavaScript>]\nmodule Anims =\n\n    [<MethodImpl(MethodImplOptions.NoInlining)>]\n    let List (Anim xs) =\n        xs\n\n    let Finalize (Anim all) =\n        AppendList.ToArray all\n        |> Array.iter (function\n            | Finally f -> f ()\n            | _ -> ())\n\n    [<MethodImpl(MethodImplOptions.NoInlining)>]\n    let Def d f =\n        { Compute = f; Duration = d}\n\n    let Const v =\n        Def 0. (fun t -> v)\n\n    // \"Prolongs\" an animation to the given time by adding in several\n    // no-ops after the animation finishes.\n    let Prolong nextDuration anim =\n        let comp = anim.Compute\n        let dur = anim.Duration\n        let last = lazy anim.Compute anim.Duration\n        let compute t = if t >= dur then last.Value else comp t\n\n        {\n            Compute = compute\n            Duration = nextDuration\n        }\n\n    let ConcatActions xs =\n        let xs = Array.ofSeqNonCopying xs\n        match xs.Length with\n        | 0 -> Const ()\n        | 1 -> xs.[0]\n        | _ ->\n            let dur = xs |> Seq.map (fun anim -> anim.Duration) |> Seq.max\n            let xs = Array.map (Prolong dur) xs\n            Def dur (fun t -> Array.iter (fun anim -> anim.Compute t) xs)\n\n    let Actions (Anim all) =\n        AppendList.ToArray all\n        |> Array.choose (function\n            | Work w -> Some w\n            | _ -> None)\n        |> ConcatActions\n\n    let mutable UseAnimations = true\n\ntype Anim with\n\n    static member UseAnimations \n        with get() = Anims.UseAnimations\n        and set v = Anims.UseAnimations <- v \n\n    static member Append (Anim a) (Anim b) =\n        Anim (AppendList.Append a b)\n\n    static member Concat xs =\n        xs\n        |> Seq.map Anims.List\n        |> AppendList.Concat\n        |> Anim\n\n    static member Const v =\n        Anims.Const v\n\n    static member Simple (inter: Interpolation<'T>) (easing: Easing) dur x y=\n        {\n            Duration = dur\n            Compute = fun t ->\n                let t = easing.TransformTime (t / dur)\n                inter.Interpolate t x y\n        }\n\n    static member Delayed (inter: Interpolation<'T>) (easing: Easing) dur delay x y =\n        {\n            Duration = dur + delay\n            Compute = fun t ->\n              //  JavaScript.Log <| \"T: \" + (string t) + \", delay: \" + (string delay)\n                if t <= delay then\n                    x\n                else\n                    let normalisedTime = easing.TransformTime ((t - delay) / dur)\n                    inter.Interpolate normalisedTime x y\n        }\n\n    static member Map f anim =\n        Anims.Def anim.Duration (anim.Compute >> f)\n\n    static member Pack anim =\n        Anim (AppendList.Single (Work anim))\n\n    static member Play anim =\n        async {\n            do! Anims.Actions anim\n                |> Anim.Run ignore\n            return Anims.Finalize anim\n        }\n\n    static member Run k anim =\n        let dur = anim.Duration\n        if dur = 0. then async.Zero() else\n        Async.FromContinuations <| fun (ok, _, _) ->\n            let rec loop start now =\n                let t = now - start\n                k (anim.Compute t)\n                if t <= dur then\n                    JS.RequestAnimationFrame (fun t -> loop start t) |> ignore\n                else ok ()\n            JS.RequestAnimationFrame (fun t -> loop t t) |> ignore\n\n    static member WhenDone f main =\n        main\n        |> Anim.Append (Anim (AppendList.Single (Finally f)))\n\n    static member Empty =\n        Anim AppendList.Empty\n\n// Transitions ----------------------------------------------------------------\n\ntype TFlags =\n    | TTrivial = 0\n    | TChange = 1\n    | TEnter = 2\n    | TExit = 4\n\n[<JavaScript>]\ntype Trans<'T>\n    (\n        change: Func<'T, 'T, Anim<'T>>,\n        enter: Func<'T, Anim<'T>>,\n        exit: Func<'T, Anim<'T>>,\n        flags: TFlags\n    ) =\n\n    new () =\n        Trans(\n            (fun x y -> Anim.Const y),\n            (fun t -> Anim.Const t),\n            (fun t -> Anim.Const t),\n            TFlags.TTrivial\n        )\n\n    new (ch: Func<'T, 'T, Anim<'T>>) =\n        Trans(\n            ch,\n            (fun t -> Anim.Const t),\n            (fun t -> Anim.Const t),\n            TFlags.TChange\n        )\n\n    new (ch: Func<'T, 'T, Anim<'T>>, enter, exit) =\n        Trans(\n            ch,\n            (if enter = null then Func<_,_>(fun t -> Anim.Const t) else enter),\n            (if exit = null then Func<_,_>(fun t -> Anim.Const t) else exit),\n            TFlags.TChange ||| \n                (if enter = null then TFlags.TTrivial else TFlags.TEnter) |||\n                (if exit = null then TFlags.TTrivial else TFlags.TExit)\n        )\n\n    member this.TChange x y = change.Invoke(x, y)\n    member this.TEnter = enter.Invoke\n    member this.TExit = exit.Invoke\n    member this.TFlags = flags\n\n    member this.Copy(?change, ?enter, ?exit, ?flags) =\n        let ch = defaultArg change this.TChange\n        let en = defaultArg enter this.TEnter\n        let ex = defaultArg exit this.TExit\n        let fl = defaultArg flags this.TFlags\n        Trans(Func<_,_,_>(ch), Func<_,_>(en),\n            Func<_,_>(ex), fl)\n\n[<JavaScript>]\n[<Sealed>]\ntype Trans =\n\n  // Using a Trans ---------------\n\n    static member AnimateChange (tr: Trans<'T>) x y = tr.TChange x y\n    static member AnimateEnter (tr: Trans<'T>) x = tr.TEnter x\n    static member AnimateExit (tr: Trans<'T>) x = tr.TExit x\n    static member CanAnimateChange (tr: Trans<'T>) = tr.TFlags.HasFlag(TFlags.TChange)\n    static member CanAnimateEnter (tr: Trans<'T>) = tr.TFlags.HasFlag(TFlags.TEnter)\n    static member CanAnimateExit (tr: Trans<'T>) = tr.TFlags.HasFlag(TFlags.TExit)\n\n  // Creating a Trans ------------\n\n    static member Trivial () =\n        Trans()\n\n    static member Create (ch: 'T -> 'T -> Anim<'T>) =\n        Trans(Func<_,_,_>(ch))\n\n    static member Change ch (tr: Trans<'T>) =\n        tr.Copy(change = ch, flags = (tr.TFlags ||| TFlags.TChange))\n\n    static member Enter f (tr: Trans<'T>) =\n        tr.Copy(enter = f, flags = (tr.TFlags ||| TFlags.TEnter))\n\n    static member Exit f (tr: Trans<'T>) =\n        tr.Copy(exit = f, flags = (tr.TFlags ||| TFlags.TExit))\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2014 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\nnamespace WebSharper.UI.Next.Client\n\nopen System.Collections.Generic\nopen Microsoft.FSharp.Quotations\nopen WebSharper\nopen WebSharper.JavaScript\nopen WebSharper.UI.Next\nmodule DU = DomUtility\n\ntype IAttrNode =\n    [<Name \"NChanged\">]\n    abstract Changed : View<unit>\n    [<Name \"NGetChangeAnim\">]\n    abstract GetChangeAnim : Element -> Anim\n    [<Name \"NGetEnterAnim\">]\n    abstract GetEnterAnim : Element -> Anim\n    [<Name \"NGetExitAnim\">]\n    abstract GetExitAnim : Element -> Anim\n    [<Name \"NSync\">]\n    abstract Sync : Element -> unit\n\n[<JavaScript; Sealed; Name \"WebSharper.UI.Next.AnimatedAttrNode\">]\ntype AnimatedAttrNode<'T>(tr: Trans<'T>, view: View<'T>, push: Element -> 'T -> unit) =\n    let mutable logical : option<'T> = None // current logical value\n    let mutable visible : option<'T> = None // current value pushed to the parent element\n    let mutable dirty = true // logical <> visible\n\n    let updates =\n        view\n        |> View.Map (fun x ->\n            logical <- Some x\n            dirty <- true)\n\n    let pushVisible el v =\n        visible <- Some v\n        dirty <- true\n        push el v\n\n    let sync p =\n        if dirty then\n            Option.iter (fun v -> push p v) logical\n            visible <- logical\n            dirty <- false\n\n    interface IAttrNode with\n\n        member a.GetChangeAnim parent =\n            match visible, logical with\n            | Some v, Some l when dirty ->\n                Trans.AnimateChange tr v l\n                |> Anim.Map (pushVisible parent)\n                |> Anim.Pack\n            | _ -> Anim.Empty\n            |> Anim.WhenDone (fun () -> sync parent)\n\n        member a.GetEnterAnim parent =\n            match visible, logical with\n            | Some vi, Some lo when dirty ->\n                Trans.AnimateChange tr vi lo\n                |> Anim.Map (pushVisible parent)\n                |> Anim.Pack\n            | None, Some lo ->\n                Trans.AnimateEnter tr lo\n                |> Anim.Map (pushVisible parent)\n                |> Anim.Pack\n            | _ -> Anim.Empty\n            |> Anim.WhenDone (fun () -> sync parent)\n\n        member a.GetExitAnim parent =\n            match visible with\n            | Some cur ->\n                Trans.AnimateExit tr cur\n                |> Anim.Map (pushVisible parent)\n                |> Anim.Pack\n            | _ -> Anim.Empty\n            |> Anim.WhenDone (fun () -> dirty <- true; visible <- None)\n\n        /// NOTE: enter or change animation will do the sync.\n        member a.Sync parent = ()\n\n        member a.Changed = updates\n\n[<JavaScript; Sealed; Name \"WebSharper.UI.Next.DynamicAttrNode\">]\ntype DynamicAttrNode<'T>(view: View<'T>, push: Element -> 'T -> unit) =\n    let mutable value = U\n    let mutable dirty = false\n    let updates = view |> View.Map (fun x -> value <- x; dirty <- true)\n    interface IAttrNode with\n        member a.GetChangeAnim parent = Anim.Empty\n        member a.GetEnterAnim parent = Anim.Empty\n        member a.GetExitAnim parent = Anim.Empty\n        member a.Sync parent = if dirty then push parent value; dirty <- false\n        member a.Changed = updates\n\ntype AttrFlags =\n    | Defaults = 0\n    | HasEnterAnim = 1\n    | HasExitAnim = 2\n    | HasChangeAnim = 4\n\n[<JavaScript; Proxy(typeof<Attr>); Name \"WebSharper.UI.Next.AttrProxy\"; Prototype>]\ntype internal AttrProxy =\n    | [<Constant(null)>] A0\n    | A1 of IAttrNode\n    | A2 of AttrProxy * AttrProxy\n    | A3 of init: (Element -> unit)\n    | A4 of onAfterRender: (Element -> unit)\n\n[<JavaScript; Name \"WebSharper.UI.Next.Attrs\">]\nmodule Attrs =\n\n    type Dyn =\n        {\n            DynElem : Element\n            DynFlags : AttrFlags\n            DynNodes : IAttrNode []\n            [<OptionalField>]\n            OnAfterRender : option<Element -> unit>\n        }\n\n    let HasChangeAnim attr =\n        attr.DynFlags.HasFlag AttrFlags.HasChangeAnim\n\n    let HasEnterAnim attr =\n        attr.DynFlags.HasFlag AttrFlags.HasEnterAnim\n\n    let HasExitAnim attr =\n        attr.DynFlags.HasFlag AttrFlags.HasExitAnim\n\n    let Flags a =\n        if a !==. null && JS.HasOwnProperty a \"flags\"\n        then a?flags\n        else AttrFlags.Defaults\n\n    let SetFlags (a: AttrProxy) (f: AttrFlags) =\n        a?flags <- f\n\n    /// Synchronizes dynamic attributes.\n    let Sync elem dyn =\n        dyn.DynNodes\n        |> Array.iter (fun d ->\n            d.Sync elem)\n\n    /// Inserts static attributes and computes dynamic attributes.\n    let Insert elem (tree: Attr) =\n        let nodes = Queue()\n        let oar = Queue()\n        let rec loop node =\n            if not (Object.ReferenceEquals(node, null)) then // work around WS issue with UseNullAsTrueValue\n            match node with\n            | A0 -> ()\n            | A1 n -> nodes.Enqueue n\n            | A2 (a, b) -> loop a; loop b\n            | A3 mk -> mk elem\n            | A4 cb -> oar.Enqueue cb\n        loop (As<AttrProxy> tree)\n        let arr = nodes.ToArray()\n        {\n            DynElem = elem\n            DynFlags = Flags tree\n            DynNodes = arr\n            OnAfterRender =\n                if oar.Count = 0 then None else\n                Some (fun el -> Seq.iter (fun f -> f el) oar)\n        }\n\n    let Empty e =\n        {\n            DynElem = e\n            DynFlags = AttrFlags.Defaults\n            DynNodes = [||]\n            OnAfterRender = None\n        }\n\n    let Updates dyn =\n        dyn.DynNodes\n        |> Array.MapTreeReduce (fun x -> x.Changed) (View.Const ()) View.Map2Unit\n\n    let GetAnim dyn f =\n        dyn.DynNodes\n        |> Array.map (fun n -> f n dyn.DynElem)\n        |> Anim.Concat\n\n    let GetEnterAnim dyn =\n        GetAnim dyn (fun n -> n.GetEnterAnim)\n\n    let GetExitAnim dyn =\n        GetAnim dyn (fun n -> n.GetExitAnim)\n\n    let GetChangeAnim dyn =\n        GetAnim dyn (fun n -> n.GetChangeAnim)\n\n    [<Inline>]\n    let GetOnAfterRender dyn =\n        dyn.OnAfterRender\n\n    let AppendTree a b =\n        // work around WS issue with UseNullAsTrueValue\n        if Object.ReferenceEquals(a, null) then b\n        elif Object.ReferenceEquals(b, null) then a\n        else\n        let x = A2 (a, b)\n        SetFlags x (Flags a ||| Flags b)\n        x\n//        match a, b with\n//        | A0, x | x, A0 -> x\n//        | _ -> A2 (a, b)\n\n    let internal EmptyAttr = A0\n\n    let internal Animated tr view set =\n        let node = AnimatedAttrNode (tr, view, set)\n        let mutable flags = AttrFlags.HasChangeAnim\n        if Trans.CanAnimateEnter tr then\n            flags <- flags ||| AttrFlags.HasEnterAnim\n        if Trans.CanAnimateExit tr then\n            flags <- flags ||| AttrFlags.HasExitAnim\n        let n = A1 node\n        SetFlags n flags\n        n\n\n    [<MethodImpl(MethodImplOptions.NoInlining)>]\n    let internal Dynamic view set =\n        A1 (DynamicAttrNode (view, set))\n\n    [<MethodImpl(MethodImplOptions.NoInlining)>]\n    let internal Static attr =\n        A3 attr\n\n\n[<JavaScript>]\ntype AttrProxy with\n\n    static member Create name value =\n        As<Attr> (Attrs.Static (fun el -> DU.SetAttr el name value))\n\n    static member Append (a: Attr) (b: Attr) =\n        As<Attr> (Attrs.AppendTree (As a) (As b))\n\n    [<Inline>]\n    static member Empty =\n        As<Attr> Attrs.EmptyAttr\n\n    static member Concat (xs: seq<Attr>) =\n        Array.ofSeqNonCopying xs\n        |> Array.TreeReduce Attr.Empty Attr.Append\n\n    static member Handler (event: string) (q: Expr<Element -> #DomEvent-> unit>) =\n        As<Attr> (Attrs.Static (fun el -> el.AddEventListener(event, (As<Element -> DomEvent -> unit> q) el, false)))\n\n[<JavaScript; Name \"WebSharper.UI.Next.CheckedInput\">]\ntype CheckedInput<'T> =\n    | Valid of value: 'T * inputText: string\n    | Invalid of inputText: string\n    | Blank of inputText: string\n\n    static member Make(x: 'T) =\n        Valid (x, x.ToString())\n\n    member this.Input =\n        match this with\n        | Valid (_, x)\n        | Invalid x\n        | Blank x -> x\n\n[<JavaScript; Name \"WebSharper.UI.Next.AttrModule\">]\nmodule Attr =\n\n    let Style name value =\n        As<Attr> (Attrs.Static (fun el -> DU.SetStyle el name value))\n\n    let Class name =\n        As<Attr> (Attrs.Static (fun el -> DU.AddClass el name))\n\n    let Animated name tr view attr =\n        As<Attr> (Attrs.Animated tr view (fun el v -> DU.SetAttr el name (attr v)))\n\n    let AnimatedStyle name tr view attr =\n        As<Attr> (Attrs.Animated tr view (fun el v -> DU.SetStyle el name (attr v)))\n\n    let Dynamic name view =\n        As<Attr> (Attrs.Dynamic view (fun el v -> DU.SetAttr el name v))\n\n    let DynamicCustom set view =\n        As<Attr> (Attrs.Dynamic view set)\n\n    let DynamicStyle name view =\n        As<Attr> (Attrs.Dynamic view (fun el v -> DU.SetStyle el name v))\n\n    let Handler name (callback: Element -> #DomEvent -> unit) =\n        As<Attr> (Attrs.Static (fun el -> el.AddEventListener(name, As<DomEvent -> unit> (callback el), false)))\n\n    let HandlerView name (view: View<'T>) (callback: Element -> #DomEvent -> 'T -> unit) =\n        let init (el: Element) =\n            let callback = callback el\n            el.AddEventListener(name, (fun (ev: DomEvent) -> View.Get (callback (As ev)) view), false)\n        As<Attr> (Attrs.Static init)\n\n    let OnAfterRender (callback: Element -> unit) =\n        As<Attr> (A4 callback)\n\n    let OnAfterRenderView (v: View<'T>) (callback: Element -> 'T -> unit) =\n        let id = Fresh.Id()\n        Attr.Append\n            (OnAfterRender (fun el -> callback el el?(id)))\n            (DynamicCustom (fun el x -> el?(id) <- x) v)\n\n    let DynamicClass name view ok =\n        As<Attr> (Attrs.Dynamic view (fun el v ->\n            if ok v then DU.AddClass el name else DU.RemoveClass el name))\n\n    let DynamicPred name predView valView =\n        let viewFn el (p, v) =\n            if p then\n                DU.SetAttr el name v\n            else\n                DU.RemoveAttr el name\n        let tupleView = View.Map2 (fun pred value -> (pred, value)) predView valView\n        As<Attr> (Attrs.Dynamic tupleView viewFn)\n\n    let DynamicProp name view =\n        As<Attr> (Attrs.Dynamic view (fun el v ->\n            el?(name) <- v))\n\n    let CustomVar (var: IRef<'a>) (set: Element -> 'a -> unit) (get: Element -> 'a option) =\n        let onChange (el: Element) (e: DomEvent) =\n            var.UpdateMaybe(fun v ->\n                match get el with\n                | Some x as o when x <> v -> o\n                | _ -> None)\n        let set e v =\n            match get e with\n            | Some x when x = v -> ()\n            | _ -> set e v\n        Attr.Concat [\n            Handler \"change\" onChange\n            Handler \"input\" onChange\n            Handler \"keypress\" onChange\n            DynamicCustom set var.View\n        ]\n\n    let CustomValue (var: IRef<'a>) (toString : 'a -> string) (fromString : string -> 'a option) =\n        CustomVar var (fun e v -> e?value <- toString v) (fun e -> fromString e?value)\n\n    let ContentEditableText (var: IRef<string>) =\n        CustomVar var (fun e v -> e.TextContent <- v) (fun e -> Some e.TextContent)\n        |> Attr.Append (Attr.Create \"contenteditable\" \"true\")\n\n    let ContentEditableHtml (var: IRef<string>) =\n        CustomVar var (fun e v -> e?innerHTML <- v) (fun e -> Some e?innerHTML)\n        |> Attr.Append (Attr.Create \"contenteditable\" \"true\")\n\n    let Value (var: IRef<string>) =\n        CustomValue var id (id >> Some)\n\n    [<JavaScript; Inline \"$e.checkValidity?$e.checkValidity():true\">]\n    let CheckValidity (e: Dom.Element) = X<bool>\n\n    let IntValueUnchecked (var: IRef<int>) =\n        let parseInt (s: string) =\n            if String.isBlank s then Some 0 else\n            let pd : int = JS.Plus s\n            if pd !==. (pd >>. 0) then None else Some pd\n        CustomValue var string parseInt\n\n    let IntValue (var: IRef<CheckedInput<int>>) =\n        let parseCheckedInt (el: Dom.Element) : option<CheckedInput<int>> =\n            let s = el?value\n            if String.isBlank s then\n                if CheckValidity el then Blank s else Invalid s\n            else\n                match System.Int32.TryParse(s) with\n                | true, i -> Valid (i, s)\n                | false, _ -> Invalid s\n            |> Some\n        CustomVar var\n            (fun el i ->\n                let i = i.Input\n                if el?value <> i then el?value <- i)\n            parseCheckedInt\n\n    let FloatValueUnchecked (var: IRef<float>) =\n        let parseFloat (s: string) =\n            if String.isBlank s then Some 0. else\n            let pd : float = JS.Plus s\n            if JS.IsNaN pd then None else Some pd\n        CustomValue var string parseFloat\n\n    let FloatValue (var: IRef<CheckedInput<float>>) =\n        let parseCheckedFloat (el: Dom.Element) : option<CheckedInput<float>> =\n            let s = el?value\n            if String.isBlank s then\n                if CheckValidity el then Blank s else Invalid s\n            else\n                let i = JS.Plus s\n                if JS.IsNaN i then Invalid s else Valid (i, s)\n            |> Some\n        CustomVar var\n            (fun el i ->\n                let i = i.Input\n                if el?value <> i then el?value <- i)\n            parseCheckedFloat\n\n    let Checked (var: IRef<bool>) =\n        let onSet (el: Dom.Element) (ev: Dom.Event) =\n            if var.Value <> el?``checked`` then\n                var.Value <- el?``checked``\n        Attr.Concat [\n            DynamicProp \"checked\" var.View\n            Handler \"change\" onSet\n            Handler \"click\" onSet\n        ]\n\n    let ValidateForm () =\n        OnAfterRender Resources.H5F.Setup\n\n[<assembly:System.Reflection.AssemblyVersionAttribute(\"4.0.0.0\")>]\ndo()\n", "namespace WebSharper.UI.Next.Client\n\nopen System\nopen System.Collections.Generic\nopen System.Runtime.CompilerServices\nopen WebSharper\nopen WebSharper.JavaScript\nopen WebSharper.UI.Next\n\nmodule DU = DomUtility\n\n[<JavaScript>]\ntype DocNode =\n    | AppendDoc of DocNode * DocNode\n    | ElemDoc of DocElemNode\n    | EmbedDoc of DocEmbedNode\n    | [<Constant(null)>] EmptyDoc\n    | TextDoc of DocTextNode\n    | TextNodeDoc of TextNode\n    | TreeDoc of DocTreeNode\n\nand [<CustomEquality>]\n    [<JavaScript>]\n    [<NoComparison>]\n    [<Name \"WebSharper.UI.Next.DocElemNode\">]\n    DocElemNode =\n    {\n        Attr : Attrs.Dyn\n        mutable Children : DocNode\n        [<OptionalField>]\n        Delimiters : (Node * Node) option\n        El : Element\n        ElKey : int\n        [<OptionalField>]\n        mutable Render : option<Dom.Element -> unit>\n    }\n\n    override this.Equals(o: obj) =\n        this.ElKey = (o :?> DocElemNode).ElKey\n\n    override this.GetHashCode() =\n        this.ElKey\n\nand DocEmbedNode =\n    {\n        mutable Current : DocNode\n        mutable Dirty : bool\n    }\n\nand DocTextNode =\n    {\n        Text : TextNode\n        mutable Dirty : bool\n        mutable Value : string\n    }\n\nand DocTreeNode =\n    {\n        mutable Els : Union<Node, DocNode>[]\n        mutable Dirty : bool\n        mutable Holes : DocElemNode[]\n        Attrs : (Element * Attrs.Dyn)[]\n        [<OptionalField>]\n        mutable Render : option<Dom.Element -> unit>\n    }\n\ntype EltUpdater =\n    inherit Elt\n\n    member this.AddUpdated(doc: Elt) = ()\n    member this.RemoveUpdated(doc: Elt) = ()\n    member this.RemoveAllUpdated() = ()\n\n[<JavaScript; Name \"WebSharper.UI.Next.Docs\">]\nmodule Docs =\n\n    /// Sets of DOM nodes.\n    type DomNodes =\n        | DomNodes of Node[]\n\n        /// Actual chidlren of an element.\n        static member Children (elem: Element) (delims: option<Node * Node>) =\n            match delims with\n            | None ->\n                DomNodes (Array.init elem.ChildNodes.Length elem.ChildNodes.Item)\n            | Some (ldelim, rdelim) ->\n                let a = Array<_>()\n                let mutable n = ldelim.NextSibling\n                while n !==. rdelim do\n                    a.Push(n) |> ignore\n                    n <- n.NextSibling\n                DomNodes (As a)\n\n        /// Shallow children of an element node.\n        static member DocChildren node =\n            let q = Queue()\n            let rec loop doc =\n                match doc with\n                | AppendDoc (a, b) -> loop a; loop b\n                | EmbedDoc d -> loop d.Current\n                | ElemDoc e -> q.Enqueue (e.El :> Node)\n                | EmptyDoc -> ()\n                | TextNodeDoc tn -> q.Enqueue (tn :> Node)\n                | TextDoc t -> q.Enqueue (t.Text :> Node)\n                | TreeDoc t ->\n                    t.Els |> Array.iter (function\n                        | Union1Of2 e -> q.Enqueue e\n                        | Union2Of2 n -> loop n\n                    )\n            loop node.Children\n            DomNodes (Array.ofSeqNonCopying q)\n\n        /// Set difference - currently only using equality O(N^2).\n        /// Can do better? Can store <hash> data on every node?\n        static member Except (DomNodes excluded) (DomNodes included) =\n            included\n            |> Array.filter (fun n ->\n                excluded\n                |> Array.forall (fun k -> not (n ===. k)))\n            |> DomNodes\n\n        /// Iteration.\n        static member Iter f (DomNodes ns) =\n            Array.iter f ns\n\n        /// Iteration.\n        static member FoldBack f (DomNodes ns) z =\n            Array.foldBack f ns z\n\n    /// Inserts a node at position.\n    [<MethodImpl(MethodImplOptions.NoInlining)>]\n    let InsertNode parent node pos =\n        DU.InsertAt parent pos node\n        DU.BeforeNode node\n\n    /// Inserts a doc at position.\n    let rec InsertDoc parent doc pos =\n        match doc with\n        | AppendDoc (a, b) -> InsertDoc parent a (InsertDoc parent b pos)\n        | ElemDoc e -> InsertNode parent e.El pos\n        | EmbedDoc d -> d.Dirty <- false; InsertDoc parent d.Current pos\n        | EmptyDoc -> pos\n        | TextDoc t -> InsertNode parent t.Text pos\n        | TextNodeDoc t -> InsertNode parent t pos\n        | TreeDoc t ->\n            Array.foldBack (fun el pos ->\n                match el with\n                | Union1Of2 e -> InsertNode parent e pos\n                | Union2Of2 n -> InsertDoc parent n pos\n            ) t.Els pos\n\n    /// Synchronizes an element with its children (shallow).\n    let DoSyncElement (el : DocElemNode) =\n        let parent = el.El\n        let rec ins doc pos =\n            match doc with\n            | AppendDoc (a, b) -> ins a (ins b pos)\n            | ElemDoc e -> DU.BeforeNode e.El\n            | EmbedDoc d ->\n                if d.Dirty then\n                    d.Dirty <- false\n                    InsertDoc parent d.Current pos\n                else\n                    ins d.Current pos\n            | EmptyDoc -> pos\n            | TextDoc t -> DU.BeforeNode t.Text\n            | TextNodeDoc t -> DU.BeforeNode t\n            | TreeDoc t ->\n                if t.Dirty then t.Dirty <- false\n                Array.foldBack (fun el pos ->\n                    match el with\n                    | Union1Of2 e -> DU.BeforeNode e\n                    | Union2Of2 n -> ins n pos\n                ) t.Els pos\n        let ch = DomNodes.DocChildren el\n        // remove children that are not in the current set\n        DomNodes.Children el.El el.Delimiters\n        |> DomNodes.Except ch\n        |> DomNodes.Iter (DU.RemoveNode el.El)\n        // insert current children\n        let pos =\n            match el.Delimiters with\n            | None -> DU.AtEnd\n            | Some (_, rdelim) -> DU.BeforeNode rdelim\n        ins el.Children pos |> ignore\n\n    /// Optimized version of DoSyncElement.\n    let SyncElement (el: DocElemNode) =\n        /// Test if any children have changed.\n        let rec hasDirtyChildren el =\n            let rec dirty doc =\n                match doc with\n                | AppendDoc (a, b) -> dirty a || dirty b\n                | EmbedDoc d -> d.Dirty || dirty d.Current\n                | TreeDoc t -> t.Dirty || Array.exists hasDirtyChildren t.Holes\n                | _ -> false\n            dirty el.Children\n        Attrs.Sync el.El el.Attr\n        if hasDirtyChildren el then\n            DoSyncElement el\n\n    /// Links an element to children by inserting them.\n    [<MethodImpl(MethodImplOptions.NoInlining)>]\n    let LinkElement el children =\n        InsertDoc el children DU.AtEnd |> ignore\n\n    /// Links an element to previous siblings by inserting them.\n    [<MethodImpl(MethodImplOptions.NoInlining)>]\n    let LinkPrevElement (el: Node) children =\n        InsertDoc (el.ParentNode :?> _) children (DU.BeforeNode el) |> ignore\n\n    let InsertBeforeDelim (afterDelim: Dom.Node) (doc: DocNode) =\n        let p = afterDelim.ParentNode\n        let before = JS.Document.CreateTextNode(\"\") :> Dom.Node\n        p.InsertBefore(before, afterDelim) |> ignore\n        LinkPrevElement afterDelim doc\n        before\n\n    /// Invokes and clears an element's afterRender callback(s).\n    let AfterRender (el: DocElemNode) =\n        match el.Render with\n        | None -> ()\n        | Some f -> f el.El; el.Render <- None\n\n    /// Synchronizes the document (deep).\n    let rec Sync doc =\n        match doc with\n        | AppendDoc (a, b) -> Sync a; Sync b\n        | ElemDoc el -> SyncElemNode el\n        | EmbedDoc n -> Sync n.Current\n        | EmptyDoc\n        | TextNodeDoc _ -> ()\n        | TextDoc d ->\n            if d.Dirty then\n                d.Text.NodeValue <- d.Value\n                d.Dirty <- false\n        | TreeDoc t ->\n            Array.iter SyncElemNode t.Holes\n            Array.iter (fun (e, a) -> Attrs.Sync e a) t.Attrs\n            AfterRender (As t)\n\n    /// Synchronizes an element node (deep).\n    and [<MethodImpl(MethodImplOptions.NoInlining)>] SyncElemNode el =\n        SyncElement el\n        Sync el.Children\n        AfterRender el\n\n    /// A set of node element nodes.\n    type NodeSet =\n        | NodeSet of HashSet<DocElemNode>\n\n        /// Filters out only nodes that have on-remove animations.\n        static member Filter f (NodeSet set) =\n            NodeSet (HashSet.Filter f set)\n\n        /// Finds all node elements in a tree.\n        static member FindAll doc =\n            let q = Queue()\n            let rec loop node =\n                match node with\n                | AppendDoc (a, b) -> loop a; loop b\n                | ElemDoc el -> loopEN el\n                | EmbedDoc em -> loop em.Current\n                | TreeDoc t -> t.Holes |> Array.iter loopEN\n                | _ -> ()\n            and loopEN el =\n                q.Enqueue el\n                loop el.Children\n            loop doc\n            NodeSet (HashSet q)\n\n        /// Set difference.\n        static member Except (NodeSet excluded) (NodeSet included) =\n            NodeSet (included |> HashSet.Except excluded)\n\n        /// Set intersection.\n        static member Intersect (NodeSet a) (NodeSet b) =\n            NodeSet (HashSet.Intersect a b)\n\n        /// Checks if empty.\n        static member IsEmpty (NodeSet ns) =\n            ns.Count = 0\n\n        /// The empty set.\n        static member Empty =\n            NodeSet (HashSet ())\n\n        /// Converts to array.\n        static member ToArray (NodeSet ns) =\n            HashSet.ToArray ns\n\n    /// State of the Doc.Run (updator) proces.\n    type RunState =\n        {\n            mutable PreviousNodes : NodeSet\n            Top : DocElemNode\n        }\n\n    /// Creates an element node.\n    let CreateElemNode el attr children =\n        LinkElement el children\n        let attr = Attrs.Insert el attr\n        {\n            Attr = attr\n            Children = children\n            Delimiters = None\n            El = el\n            ElKey = Fresh.Int ()\n            Render = Attrs.GetOnAfterRender attr\n        }\n\n    /// Creates an element node that handles a delimited subset of its children.\n    let CreateDelimitedElemNode (ldelim: Node) (rdelim: Node) attr children =\n        let el = ldelim.ParentNode :?> Dom.Element\n        LinkPrevElement rdelim children\n        let attr = Attrs.Insert el attr\n        {\n            Attr = attr\n            Children = children\n            Delimiters = Some (ldelim, rdelim)\n            El = el\n            ElKey = Fresh.Int ()\n            Render = Attrs.GetOnAfterRender attr\n        }\n\n    /// Creates a new RunState.\n    let CreateRunState parent doc =\n        {\n            PreviousNodes = NodeSet.Empty\n            Top = CreateElemNode parent Attr.Empty doc\n        }\n\n    /// Creates a new RunState for a delimited subset of the children of a node.\n    let CreateDelimitedRunState ldelim rdelim doc =\n        {\n            PreviousNodes = NodeSet.Empty\n            Top = CreateDelimitedElemNode ldelim rdelim Attr.Empty doc\n        }\n\n    /// Computes the animation of nodes that animate removal.\n    let ComputeExitAnim st cur =\n        st.PreviousNodes\n        |> NodeSet.Filter (fun n -> Attrs.HasExitAnim n.Attr)\n        |> NodeSet.Except cur\n        |> NodeSet.ToArray\n        |> Array.map (fun n -> Attrs.GetExitAnim n.Attr)\n        |> Anim.Concat\n\n    /// Computes the animation for changed nodes.\n    let ComputeChangeAnim st cur =\n        let relevant = NodeSet.Filter (fun n -> Attrs.HasChangeAnim n.Attr)\n        NodeSet.Intersect (relevant st.PreviousNodes) (relevant cur)\n        |> NodeSet.ToArray\n        |> Array.map (fun n -> Attrs.GetChangeAnim n.Attr)\n        |> Anim.Concat\n\n    /// Computes the animation for entering nodes.\n    let ComputeEnterAnim st cur =\n        cur\n        |> NodeSet.Filter (fun n -> Attrs.HasEnterAnim n.Attr)\n        |> NodeSet.Except st.PreviousNodes\n        |> NodeSet.ToArray\n        |> Array.map (fun n -> Attrs.GetEnterAnim n.Attr)\n        |> Anim.Concat\n\n    let SyncElemNodesNextFrame st = \n        Async.FromContinuations <| fun (ok, _, _) ->\n            JS.RequestAnimationFrame (fun _ ->\n                SyncElemNode st.Top\n                ok()\n            ) |> ignore\n\n    /// The main function: how to perform an animated top-level document update.\n    let PerformAnimatedUpdate st doc =\n        if Anim.UseAnimations then\n            async {\n                let cur = NodeSet.FindAll doc\n                let change = ComputeChangeAnim st cur\n                let enter = ComputeEnterAnim st cur\n                let exit = ComputeExitAnim st cur\n                do! Anim.Play (Anim.Append change exit)\n                do! SyncElemNodesNextFrame st\n                do! Anim.Play enter\n                return st.PreviousNodes <- cur\n            }\n        else\n            SyncElemNodesNextFrame st\n\n    /// EmbedNode constructor.\n    [<MethodImpl(MethodImplOptions.NoInlining)>]\n    let CreateEmbedNode () =\n        {\n            Current = EmptyDoc\n            Dirty = false\n        }\n\n    /// EmbedNode update (marks dirty).\n    [<MethodImpl(MethodImplOptions.NoInlining)>]\n    let UpdateEmbedNode node upd =\n        node.Current <- upd\n        node.Dirty <- true\n\n    /// Text node constructor.\n    [<MethodImpl(MethodImplOptions.NoInlining)>]\n    let CreateTextNode () =\n        {\n            Dirty = false\n            Text = DU.CreateText \"\"\n            Value = \"\"\n        }\n\n    /// Text node update (marks dirty).\n    [<MethodImpl(MethodImplOptions.NoInlining)>]\n    let UpdateTextNode n t =\n        n.Value <- t\n        n.Dirty <- true\n\n    let LoadedTemplates = Dictionary<string, Dom.Element>()\n\n    let TextHoleRE = \"\"\"\\${([^}]+)}\"\"\"\n\n// We implement the Doc interface, the Doc module proxy and the Client.Doc module proxy\n// all in this so that it all neatly looks like Doc.* in javascript.\n[<Name \"WebSharper.UI.Next.Doc\"; Proxy(typeof<Doc>)>]\n[<CompilationRepresentation(CompilationRepresentationFlags.ModuleSuffix)>]\ntype private Doc' [<JavaScript>] (docNode, updates) =\n\n    [<JavaScript; Inline>]\n    member this.DocNode = docNode\n    [<JavaScript; Inline>]\n    member this.Updates = updates\n\n    interface IControlBody with\n\n        [<JavaScript>]\n        member this.ReplaceInDom(elt) =\n            // Insert empty text nodes that will serve as delimiters for the Doc.\n            let rdelim = JS.Document.CreateTextNode \"\"\n            elt.ParentNode.ReplaceChild(rdelim, elt) |> ignore\n            Doc'.RunBefore rdelim this\n\n    [<JavaScript; MethodImpl(MethodImplOptions.NoInlining)>]\n    static member Mk node updates =\n        Doc'(node, updates)\n\n    [<JavaScript; Name \"Append\">]\n    static member Append' (a: Doc') (b: Doc') =\n        (a.Updates, b.Updates)\n        ||> View.Map2Unit\n        |> Doc'.Mk (AppendDoc (a.DocNode, b.DocNode))\n\n    [<JavaScript; Name \"Concat\">]\n    static member Concat' xs =\n        Array.ofSeqNonCopying xs\n        |> Array.TreeReduce Doc'.Empty' Doc'.Append'\n\n    [<JavaScript; Name \"Empty\">]\n    static member Empty'\n        with [<MethodImpl(MethodImplOptions.NoInlining)>] get () =\n            Doc'.Mk EmptyDoc (View.Const ())\n\n    [<JavaScript; Inline>]\n    static member Elem el attr (children: Doc') =\n        As<Elt> (Elt'.New(el, attr, children))\n\n    [<JavaScript; Name \"TextNode\">]\n    static member TextNode' v =\n        Doc'.Mk (TextNodeDoc (DU.CreateText v)) (View.Const ())\n\n    [<JavaScript>]\n    static member Static el : Elt =\n        Doc'.Elem el Attr.Empty Doc'.Empty'\n\n    [<JavaScript; Name \"Verbatim\">]\n    static member Verbatim' html =\n        let a =\n            match JQuery.JQuery.ParseHTML html with\n            | null -> [||]\n            | a -> a\n        let elem (n: Dom.Node) =\n            if n.NodeType = Dom.NodeType.Text then\n                TextNodeDoc (n :?> Dom.Text)\n            else\n                ElemDoc (Docs.CreateElemNode (n :?> Element) Attr.Empty EmptyDoc)\n        let append x y = AppendDoc (x, y)\n        let es = Array.MapTreeReduce elem EmptyDoc append a\n        Doc'.Mk es (View.Const ())\n\n    [<JavaScript>]\n    static member EmbedView (view: View<Doc'>) =\n        let node = Docs.CreateEmbedNode ()\n        view\n        |> View.Bind (fun doc ->\n            Docs.UpdateEmbedNode node doc.DocNode\n            doc.Updates)\n        |> View.Map ignore\n        |> Doc'.Mk (EmbedDoc node)\n\n    [<JavaScript>]\n    static member BindView (f: 'T -> Doc') (view: View<'T>) =\n        Doc'.EmbedView (View.Map f view)\n\n    [<JavaScript>]\n    static member Async (a: Async<Doc'>) : Doc' =\n        View.Const a\n        |> View.MapAsync id\n        |> Doc'.EmbedView\n\n    [<JavaScript>]\n    static member RunBetween ldelim rdelim (doc: Doc') =\n        Docs.LinkPrevElement rdelim doc.DocNode\n        let st = Docs.CreateDelimitedRunState ldelim rdelim doc.DocNode\n        let p = Mailbox.StartProcessor (Docs.PerformAnimatedUpdate st doc.DocNode)\n        View.Sink p doc.Updates\n\n    [<JavaScript>]\n    static member RunBefore (rdelim: Dom.Node) (doc: Doc') =\n        let ldelim = JS.Document.CreateTextNode(\"\")\n        rdelim.ParentNode.InsertBefore(ldelim, rdelim) |> ignore\n        Doc'.RunBetween ldelim rdelim doc\n\n    [<JavaScript>]\n    static member RunBeforeById id doc =\n        match DU.Doc.GetElementById(id) with\n        | null -> failwith (\"invalid id: \" + id)\n        | el -> Doc'.RunBefore el doc\n\n    [<JavaScript>]\n    static member RunAfter (ldelim : Dom.Node) (doc: Doc') =\n        let rdelim = JS.Document.CreateTextNode(\"\")\n        ldelim.ParentNode.InsertBefore(rdelim, ldelim.NextSibling) |> ignore\n        Doc'.RunBetween ldelim rdelim doc\n\n    [<JavaScript>]\n    static member RunAfterById id doc =\n        match DU.Doc.GetElementById(id) with\n        | null -> failwith (\"invalid id: \" + id)\n        | el -> Doc'.RunAfter el doc\n\n    [<JavaScript>]\n    static member RunAppend (parent: Dom.Element) (doc: Doc') =\n        let rdelim = JS.Document.CreateTextNode \"\"\n        parent.AppendChild(rdelim) |> ignore\n        Doc'.RunBefore rdelim doc\n\n    [<JavaScript>]\n    static member RunAppendById id doc =\n        match DU.Doc.GetElementById(id) with\n        | null -> failwith (\"invalid id: \" + id)\n        | el -> Doc'.RunAppend el doc\n\n    [<JavaScript>]\n    static member RunPrepend (parent: Dom.Element) (doc: Doc') =\n        let rdelim = JS.Document.CreateTextNode \"\"\n        parent.InsertBefore(rdelim, parent.FirstChild) |> ignore\n        Doc'.RunBefore rdelim doc\n\n    [<JavaScript>]\n    static member RunPrependById id doc =\n        match DU.Doc.GetElementById(id) with\n        | null -> failwith (\"invalid id: \" + id)\n        | el -> Doc'.RunPrepend el doc\n\n    [<JavaScript>]\n    static member Run parent (doc: Doc') =\n        let d = doc.DocNode\n        Docs.LinkElement parent d\n        let st = Docs.CreateRunState parent d\n        let p = Mailbox.StartProcessor (Docs.PerformAnimatedUpdate st d)\n        View.Sink p doc.Updates\n\n    [<JavaScript>]\n    static member RunById id tr =\n        match DU.Doc.GetElementById(id) with\n        | null -> failwith (\"invalid id: \" + id)\n        | el -> Doc'.Run el tr\n\n    [<JavaScript>]\n    static member RunReplaceById id (tr: Doc') =\n        match DU.Doc.GetElementById(id) with\n        | null -> failwith (\"invalid id: \" + id)\n        | el -> (tr :> IControlBody).ReplaceInDom(el)\n\n    [<JavaScript>]\n    static member TextView txt =\n        let node = Docs.CreateTextNode ()\n        txt\n        |> View.Map (Docs.UpdateTextNode node)\n        |> Doc'.Mk (TextDoc node)\n\n    [<JavaScript>]\n    static member Template (els: Node[]) (fillWith: seq<TemplateHole>) =\n        Doc'.ChildrenTemplate (Doc'.FakeRoot els) fillWith\n\n    [<JavaScript>]\n    static member ChildrenTemplate (el: Element) (fillWith: seq<TemplateHole>) =\n        let holes : DocElemNode[] = [||]\n        let updates : View<unit>[] = [||]\n        let attrs : (Element * Attrs.Dyn)[] = [||]\n        let afterRender : (Element -> unit)[] = [||]\n        let fw = Dictionary()\n        for x in fillWith do fw.[TemplateHole.Name x] <- x\n        let els = As<Union<Dom.Node, DocNode>[]> (DomUtility.ChildrenArray el)\n        let addAttr (el: Element) (attr: Attr) =\n            let attr = Attrs.Insert el attr\n            updates.JS.Push (Attrs.Updates attr) |> ignore\n            attrs.JS.Push ((el, attr)) |> ignore\n            Attrs.GetOnAfterRender attr |> Option.iter (fun f ->\n                afterRender.JS.Push(fun _ -> f el) |> ignore)\n        let tryGetAsDoc name =\n            match fw.TryGetValue(name) with\n            | true, TemplateHole.Elt (_, doc) -> Some (As<Doc'> doc)\n            | true, TemplateHole.Text (_, text) -> Some (Doc'.TextNode' text)\n            | true, TemplateHole.TextView (_, tv) -> Some (Doc'.TextView tv)\n            | true, TemplateHole.VarStr (_, v) -> Some (Doc'.TextView v.View)\n            | true, TemplateHole.VarBool (_, v) -> Some (Doc'.TextView (v.View.Map string))\n            | true, TemplateHole.VarInt (_, v) -> Some (Doc'.TextView (v.View.Map (fun i -> i.Input)))\n            | true, TemplateHole.VarIntUnchecked (_, v) -> Some (Doc'.TextView (v.View.Map string))\n            | true, TemplateHole.VarFloat (_, v) -> Some (Doc'.TextView (v.View.Map (fun i -> i.Input)))\n            | true, TemplateHole.VarFloatUnchecked (_, v) -> Some (Doc'.TextView (v.View.Map string))\n            | true, _ -> Console.Warn(\"Content hole filled with attribute data\", name); None\n            | false, _ -> None\n\n        DomUtility.IterSelector el \"[ws-hole]\" <| fun p ->\n            let name = p.GetAttribute(\"ws-hole\")\n            p.RemoveAttribute(\"ws-hole\")\n            while (p.HasChildNodes()) do\n                p.RemoveChild(p.LastChild) |> ignore\n            match tryGetAsDoc name with\n            | None -> ()\n            | Some doc ->\n                Docs.LinkElement p doc.DocNode\n                holes.JS.Push {\n                    Attr = Attrs.Empty p\n                    Children = doc.DocNode\n                    Delimiters = None\n                    El = p\n                    ElKey = Fresh.Int()\n                    Render = None\n                }\n                |> ignore\n                updates.JS.Push doc.Updates |> ignore\n\n        DomUtility.IterSelector el \"[ws-replace]\" <| fun e ->\n            let name = e.GetAttribute(\"ws-replace\")\n            match tryGetAsDoc name with\n            | None -> ()\n            | Some doc ->\n                let p = e.ParentNode :?> Dom.Element\n                let after = JS.Document.CreateTextNode(\"\") :> Dom.Node\n                p.ReplaceChild(after, e) |> ignore\n                let before = Docs.InsertBeforeDelim after doc.DocNode\n                els\n                |> Array.tryFindIndex ((===.) e)\n                |> Option.iter (fun i -> els.[i] <- Union2Of2 doc.DocNode)\n                holes.JS.Push {\n                    Attr = Attrs.Empty p\n                    Children = doc.DocNode\n                    Delimiters = Some (before, after)\n                    El = p\n                    ElKey = Fresh.Int()\n                    Render = None\n                }\n                |> ignore\n                updates.JS.Push doc.Updates |> ignore\n\n        DomUtility.IterSelector el \"[ws-attr]\" <| fun e ->\n            let name = e.GetAttribute(\"ws-attr\")\n            e.RemoveAttribute(\"ws-attr\")\n            match fw.TryGetValue(name) with\n            | true, TemplateHole.Attribute (_, attr) -> addAttr e attr\n            | true, _ -> Console.Warn(\"Attribute hole filled with non-attribute data\", name)\n            | false, _ -> ()\n\n        DomUtility.IterSelector el \"[ws-on]\" <| fun e ->\n            e.GetAttribute(\"ws-on\").Split([|' '|], StringSplitOptions.RemoveEmptyEntries)\n            |> Array.choose (fun x ->\n                let a = x.Split([|':'|], StringSplitOptions.RemoveEmptyEntries)\n                match fw.TryGetValue(a.[1]) with\n                | true, TemplateHole.Event (_, handler) -> Some (Attr.Handler a.[0] handler)\n                | true, _ ->\n                    Console.Warn(\"Event hole on\" + a.[0] + \" filled with non-event data\", a.[1])\n                    None\n                | false, _ -> None\n            )\n            |> Attr.Concat\n            |> addAttr e\n            e.RemoveAttribute(\"ws-on\")\n\n        DomUtility.IterSelector el \"[ws-onafterrender]\" <| fun e ->\n            let name = e.GetAttribute(\"ws-onafterrender\")\n            match fw.TryGetValue(name) with\n            | true, TemplateHole.AfterRender (_, handler) ->\n                e.RemoveAttribute(\"ws-onafterrender\")\n                addAttr e (Attr.OnAfterRender handler)\n            | true, _ -> Console.Warn(\"onafterrender hole filled with non-onafterrender data\", name)\n            | false, _ -> ()\n\n        DomUtility.IterSelector el \"[ws-var]\" <| fun e ->\n            let name = e.GetAttribute(\"ws-var\")\n            e.RemoveAttribute(\"ws-var\")\n            match fw.TryGetValue(name) with\n            | true, TemplateHole.VarStr (_, var) -> addAttr e (Attr.Value var)\n            | true, TemplateHole.VarBool (_, var) -> addAttr e (Attr.Checked var)\n            | true, TemplateHole.VarInt (_, var) -> addAttr e (Attr.IntValue var)\n            | true, TemplateHole.VarIntUnchecked (_, var) -> addAttr e (Attr.IntValueUnchecked var)\n            | true, TemplateHole.VarFloat (_, var) -> addAttr e (Attr.FloatValue var)\n            | true, TemplateHole.VarFloatUnchecked (_, var) -> addAttr e (Attr.FloatValueUnchecked var)\n            | true, _ -> Console.Warn(\"Var hole filled with non-Var data\", name)\n            | false, _ -> ()\n\n        DomUtility.IterSelector el \"[ws-attr-holes]\" <| fun e ->\n            let re = new RegExp(Docs.TextHoleRE, \"g\")\n            let holeAttrs = e.GetAttribute(\"ws-attr-holes\").Split([|' '|], StringSplitOptions.RemoveEmptyEntries)\n            e.RemoveAttribute(\"ws-attr-holes\")\n            for attrName in holeAttrs do\n                let s = e.GetAttribute(attrName)\n                let mutable m = null\n                let mutable lastIndex = 0\n                let res : (string * string)[] = [||]\n                while (m <- re.Exec s; m !==. null) do\n                    let textBefore = s.[lastIndex .. re.LastIndex-m.[0].Length-1]\n                    lastIndex <- re.LastIndex\n                    let holeName = m.[1]\n                    res.JS.Push((textBefore, holeName)) |> ignore\n                let finalText = s.[lastIndex..]\n                re.LastIndex <- 0\n                let value =\n                    Array.foldBack (fun (textBefore, holeName: string) (textAfter, views) ->\n                        let holeContent =\n                            match fw.TryGetValue(holeName) with\n                            | true, TemplateHole.Text (_, t) -> Choice1Of2 t\n                            | true, TemplateHole.TextView (_, v) -> Choice2Of2 v\n                            | true, TemplateHole.VarStr (_, v) -> Choice2Of2 v.View\n                            | true, TemplateHole.VarBool (_, v) -> Choice2Of2 (v.View.Map string)\n                            | true, TemplateHole.VarInt (_, v) -> Choice2Of2 (v.View.Map (fun i -> i.Input))\n                            | true, TemplateHole.VarIntUnchecked (_, v) -> Choice2Of2 (v.View.Map string)\n                            | true, TemplateHole.VarFloat (_, v) -> Choice2Of2 (v.View.Map (fun i -> i.Input))\n                            | true, TemplateHole.VarFloatUnchecked (_, v) -> Choice2Of2 (v.View.Map string)\n                            | true, _ ->\n                                Console.Warn(\"Attribute value hole filled with non-text data\", holeName)\n                                Choice1Of2 \"\"\n                            | false, _ -> Choice1Of2 \"\"\n                        match holeContent with\n                        | Choice1Of2 text -> textBefore + text + textAfter, views\n                        | Choice2Of2 v ->\n                            let v =\n                                if textAfter = \"\" then v else\n                                View.Map (fun s -> s + textAfter) v\n                            textBefore, v :: views\n                    ) res (finalText, [])\n                match value with\n                | s, [] -> Attr.Create attrName s\n                | \"\", [v] -> Attr.Dynamic attrName v\n                | s, [v] -> Attr.Dynamic attrName (View.Map (fun v -> s + v) v)\n                | s, [v1; v2] -> Attr.Dynamic attrName (View.Map2 (fun v1 v2 -> s + v1 + v2) v1 v2)\n                | s, [v1; v2; v3] -> Attr.Dynamic attrName (View.Map3 (fun v1 v2 v3 -> s + v1 + v2 + v3) v1 v2 v3)\n                | s, vs ->\n                    View.Sequence vs\n                    |> View.Map (fun vs -> s + String.concat \"\" vs)\n                    |> Attr.Dynamic attrName\n                |> addAttr e\n\n        let docTreeNode : DocTreeNode =\n            {\n                Els = els\n                Holes = holes\n                Attrs = attrs\n                Render =\n                    if Array.isEmpty afterRender\n                    then None\n                    else Some (fun el -> Array.iter (fun f -> f el) afterRender)\n                Dirty = true\n            }\n        let updates =\n            updates |> Array.TreeReduce (View.Const ()) View.Map2Unit\n\n        match els with\n        | [| Union1Of2 e |] when e.NodeType = Dom.NodeType.Element ->\n            Elt'.TreeNode(docTreeNode, updates) :> Doc'\n        | _ ->\n            Doc'.Mk (TreeDoc docTreeNode) updates\n\n    [<JavaScript>]\n    static member FakeRoot (els: Node[]) =\n        let fakeroot = JS.Document.CreateElement(\"div\")\n        for el in els do fakeroot.AppendChild el |> ignore\n        fakeroot\n\n    [<JavaScript>]\n    static member PrepareSingleTemplate (baseName: string) (name: option<string>) (el: Element) =\n        el.RemoveAttribute(\"ws-template\")\n        match el.GetAttribute(\"ws-replace\") with\n        | null -> ()\n        | replace ->\n            el.RemoveAttribute(\"ws-replace\")\n            match el.ParentNode with\n            | null -> ()\n            | p ->\n                let n = JS.Document.CreateElement(el.TagName)\n                n.SetAttribute(\"ws-replace\", replace)\n                p.ReplaceChild(n, el) |> ignore\n        Doc'.PrepareTemplateStrict baseName name [| el |]\n\n    [<JavaScript>]\n    static member ComposeName baseName name =\n        (baseName + \"/\" + defaultArg name \"\").ToLower()\n\n    [<JavaScript>]\n    static member PrepareTemplateStrict (baseName: string) (name: option<string>) (els: Node[]) =\n        let convertAttrs (el: Dom.Element) =\n            let attrs = el.Attributes\n            let toRemove = [||]\n            let events = [||]\n            let holedAttrs = [||]\n            for i = 0 to attrs.Length - 1 do\n                let a = attrs.[i]\n                if a.NodeName.StartsWith \"ws-on\" && a.NodeName <> \"ws-onafterrender\" && a.NodeName <> \"ws-on\" then\n                    toRemove.JS.Push(a.NodeName) |> ignore\n                    events.JS.Push(a.NodeName.[\"ws-on\".Length..] + \":\" + a.NodeValue.ToLower()) |> ignore\n                elif not (a.NodeName.StartsWith \"ws-\") && RegExp(Docs.TextHoleRE).Test(a.NodeValue) then\n                    a.NodeValue <-\n                        RegExp(Docs.TextHoleRE, \"g\")\n                            .Replace(a.NodeValue, FuncWithArgs (fun (_, h: string) ->\n                                \"${\" + h.ToLower() + \"}\"))\n                    holedAttrs.JS.Push(a.NodeName) |> ignore\n            if not (Array.isEmpty events) then\n                el.SetAttribute(\"ws-on\", String.concat \" \" events)\n            if not (Array.isEmpty holedAttrs) then\n                el.SetAttribute(\"ws-attr-holes\", String.concat \" \" holedAttrs)\n            let lowercaseAttr name =\n                match el.GetAttribute(name) with\n                | null -> ()\n                | x -> el.SetAttribute(name, x.ToLower())\n            lowercaseAttr \"ws-hole\"\n            lowercaseAttr \"ws-replace\"\n            lowercaseAttr \"ws-attr\"\n            lowercaseAttr \"ws-onafterrender\"\n            lowercaseAttr \"ws-var\"\n            Array.iter el.RemoveAttribute toRemove\n\n        let convertTextNode (n: Dom.Node) =\n            let mutable m = null\n            let mutable li = 0\n            let s = n.TextContent\n            let strRE = RegExp(Docs.TextHoleRE, \"g\")\n            while (m <- strRE.Exec s; m !==. null) do\n                n.ParentNode.InsertBefore(JS.Document.CreateTextNode(s.[li..strRE.LastIndex-m.[0].Length-1]), n) |> ignore\n                li <- strRE.LastIndex\n                let hole = JS.Document.CreateElement(\"span\")\n                hole.SetAttribute(\"ws-replace\", m.[1].ToLower())\n                n.ParentNode.InsertBefore(hole, n) |> ignore\n            strRE.LastIndex <- 0\n            n.TextContent <- s.[li..]\n\n        let mapHoles (t: Dom.Element) (mappings: Dictionary<string, string>) =\n            let run attrName =\n                DomUtility.IterSelector t (\"[\" + attrName + \"]\") <| fun e ->\n                    match mappings.TryGetValue(e.GetAttribute(attrName).ToLower()) with\n                    | true, m -> e.SetAttribute(attrName, m)\n                    | false, _ -> ()\n            run \"ws-hole\"\n            run \"ws-replace\"\n            run \"ws-attr\"\n            run \"ws-onafterrender\"\n            run \"ws-var\"\n            DomUtility.IterSelector t \"[ws-on]\" <| fun e ->\n                let a =\n                    e.GetAttribute(\"ws-on\").Split([|' '|], StringSplitOptions.RemoveEmptyEntries)\n                    |> Array.map (fun x ->\n                        let a = x.Split([|':'|], StringSplitOptions.RemoveEmptyEntries)\n                        match mappings.TryGetValue(a.[1]) with\n                        | true, x -> a.[0] + \":\" + x\n                        | false, _ -> x\n                    )\n                    |> String.concat \" \"\n                e.SetAttribute(\"ws-on\", a)\n            DomUtility.IterSelector t \"[ws-attr-holes]\" <| fun e ->\n                let holeAttrs = e.GetAttribute(\"ws-attr-holes\").Split([|' '|], StringSplitOptions.RemoveEmptyEntries)\n                for attrName in holeAttrs do\n                    let s =\n                        (e.GetAttribute(attrName), mappings)\n                        ||> Seq.fold (fun s (KeyValue(a, m)) ->\n                            RegExp(\"\\\\${\" + a + \"}\", \"ig\").Replace(s, \"${\" + m + \"}\")\n                        )\n                    e.SetAttribute(attrName, s)\n\n        let fillInstanceAttrs (instance: Dom.Element) (fillWith: Dom.Element) =\n            convertAttrs fillWith\n            let name = fillWith.NodeName.ToLower()\n            match instance.QuerySelector(\"[ws-attr=\" + name + \"]\") with\n            | null -> Console.Warn(\"Filling non-existent attr hole\", name)\n            | e ->\n                e.RemoveAttribute(\"ws-attr\")\n                for i = 0 to fillWith.Attributes.Length - 1 do\n                    let a = fillWith.Attributes.[i]\n                    if a.Name = \"class\" && e.HasAttribute(\"class\") then\n                        e.SetAttribute(\"class\", e.GetAttribute(\"class\") + \" \" + a.NodeValue)\n                    else\n                        e.SetAttribute(a.Name, a.NodeValue)\n\n        let removeHolesExcept (instance: Dom.Element) (dontRemove: HashSet<string>) =\n            let run attrName =\n                DomUtility.IterSelector instance (\"[\" + attrName + \"]\") <| fun e ->\n                    if not (dontRemove.Contains(e.GetAttribute attrName)) then\n                        e.RemoveAttribute(attrName)\n            run \"ws-attr\"\n            run \"ws-onafterrender\"\n            run \"ws-var\"\n            DomUtility.IterSelector instance \"[ws-hole]\" <| fun e ->\n                if not (dontRemove.Contains(e.GetAttribute \"ws-hole\")) then\n                    e.RemoveAttribute(\"ws-hole\")\n                    while e.HasChildNodes() do\n                        e.RemoveChild(e.LastChild) |> ignore\n            DomUtility.IterSelector instance \"[ws-replace]\" <| fun e ->\n                if not (dontRemove.Contains(e.GetAttribute \"ws-replace\")) then\n                    e.ParentNode.RemoveChild(e) |> ignore\n            DomUtility.IterSelector instance \"[ws-on]\" <| fun e ->\n                let a =\n                    e.GetAttribute(\"ws-on\").Split([|' '|], StringSplitOptions.RemoveEmptyEntries)\n                    |> Array.filter (fun x ->\n                        let a = x.Split([|':'|], StringSplitOptions.RemoveEmptyEntries)\n                        dontRemove.Contains a.[1]\n                    )\n                    |> String.concat \" \"\n                e.SetAttribute(\"ws-on\", a)\n            DomUtility.IterSelector instance \"[ws-attr-holes]\" <| fun e ->\n                let holeAttrs = e.GetAttribute(\"ws-attr-holes\").Split([|' '|], StringSplitOptions.RemoveEmptyEntries)\n                for attrName in holeAttrs do\n                    let s =\n                        RegExp(Docs.TextHoleRE, \"g\")\n                            .Replace(e.GetAttribute(attrName), FuncWithArgs(fun (full: string, h: string) ->\n                                if dontRemove.Contains h then full else \"\"\n                            ))\n                    e.SetAttribute(attrName, s)\n\n        let fillTextHole (instance: Dom.Element) (fillWith: string) =\n            match instance.QuerySelector \"[ws-replace]\" with\n            | null ->\n                Console.Warn(\"Filling non-existent text hole\", name)\n                None\n            | n ->\n                n.ParentNode.ReplaceChild(Dom.Text fillWith, n) |> ignore\n                Some <| n.GetAttribute(\"ws-replace\")\n\n        let rec fill (fillWith: Dom.Element) (p: Dom.Node) n =\n            if fillWith.HasChildNodes() then\n                fill fillWith p (p.InsertBefore(fillWith.LastChild, n))\n\n        let rec fillDocHole (instance: Dom.Element) (fillWith: Dom.Element) =\n            let name = fillWith.NodeName.ToLower()\n            let fillHole (p: Dom.Node) (n: Dom.Node) =\n                // The \"title\" node is treated specially by HTML, its content is considered pure text,\n                // so we need to re-parse it.\n                if name = \"title\" && fillWith.HasChildNodes() then\n                    let parsed = JQuery.JQuery.ParseHTML fillWith.TextContent\n                    fillWith.RemoveChild(fillWith.FirstChild) |> ignore\n                    for i in parsed do\n                        fillWith.AppendChild(i) |> ignore\n                convertElement fillWith\n                fill fillWith p n\n            DomUtility.IterSelector instance \"[ws-attr-holes]\" <| fun e ->\n                let holeAttrs = e.GetAttribute(\"ws-attr-holes\").Split([|' '|], StringSplitOptions.RemoveEmptyEntries)\n                for attrName in holeAttrs do\n                    e.SetAttribute(attrName,\n                        RegExp(\"\\\\${\" + name + \"}\", \"ig\").\n                            Replace(e.GetAttribute(attrName), fillWith.TextContent)\n                    )\n            match instance.QuerySelector(\"[ws-hole=\" + name + \"]\") with\n            | null ->\n                match instance.QuerySelector(\"[ws-replace=\" + name + \"]\") with\n                | null -> ()\n                | e ->\n                    fillHole e.ParentNode e\n                    e.ParentNode.RemoveChild(e) |> ignore\n            | e ->\n                while e.HasChildNodes() do\n                    e.RemoveChild(e.LastChild) |> ignore\n                e.RemoveAttribute(\"ws-hole\")\n                fillHole e null\n\n        and convertInstantiation (el: Dom.Element) =\n            let name = el.NodeName.[3..].ToLower()\n            let name =\n                match name.IndexOf('.') with\n                | -1 -> baseName + \"/\" + name\n                | _ -> name.Replace(\".\", \"/\")\n            if not (Docs.LoadedTemplates.ContainsKey name) then\n                Console.Warn(\"Instantiating non-loaded template\", name)\n            else\n                let t = Docs.LoadedTemplates.[name]\n//            match Docs.LoadedTemplates.TryGetValue name with\n//            | false, _ -> Console.Warn(\"Instantiating non-loaded template\", name)\n//            | true, (t: Dom.Element) ->\n                let instance = t.CloneNode(true) :?> Dom.Element\n                let usedHoles = HashSet()\n                let mappings = Dictionary()\n                // 1. gather mapped and filled holes.\n                let attrs = el.Attributes\n                for i = 0 to attrs.Length - 1 do\n                    let name = attrs.[i].Name.ToLower()\n                    let mappedName = match attrs.[i].NodeValue with \"\" -> name | s -> s.ToLower()\n                    mappings.[name] <- mappedName\n                    if not (usedHoles.Add(name)) then\n                        Console.Warn(\"Hole mapped twice\", name)\n                for i = 0 to el.ChildNodes.Length - 1 do\n                    let n = el.ChildNodes.[i]\n                    if n.NodeType = Dom.NodeType.Element then\n                        let n = n :?> Dom.Element\n                        if not (usedHoles.Add(n.NodeName.ToLower())) then\n                            Console.Warn(\"Hole filled twice\", name)\n                // 2. If single text hole, apply it.\n                let singleTextFill = el.ChildNodes.Length = 1 && el.FirstChild.NodeType = Dom.NodeType.Text\n                if singleTextFill then\n                    fillTextHole instance el.FirstChild.TextContent\n                    |> Option.iter (usedHoles.Add >> ignore)\n                // 3. eliminate non-mapped/filled holes.\n                removeHolesExcept instance usedHoles\n                // 4. apply mappings/fillings.\n                if not singleTextFill then\n                    for i = 0 to el.ChildNodes.Length - 1 do\n                        let n = el.ChildNodes.[i]\n                        if n.NodeType = Dom.NodeType.Element then\n                            let n = n :?> Dom.Element\n                            if n.HasAttributes() then\n                                fillInstanceAttrs instance n\n                            else\n                                fillDocHole instance n\n                mapHoles instance mappings\n                // 5. insert result.\n                fill instance el.ParentNode el\n                el.ParentNode.RemoveChild(el) |> ignore\n\n        and convertElement (el: Dom.Element) =\n            if el.NodeName.ToLower().StartsWith \"ws-\" && not (el.HasAttribute \"ws-template\") then\n                convertInstantiation el\n            else\n                convertAttrs el\n                match el.GetAttribute(\"ws-template\") with\n                | null ->\n                    match el.GetAttribute(\"ws-children-template\") with\n                    | null -> convert el el.FirstChild\n                    | name ->\n                        el.RemoveAttribute(\"ws-children-template\")\n                        Doc'.PrepareTemplate baseName (Some name) (fun () -> DomUtility.ChildrenArray el)\n                        // if it was already prepared, the above does nothing, so always clean anyway!\n                        while el.HasChildNodes() do el.RemoveChild(el.LastChild) |> ignore\n                | name -> Doc'.PrepareSingleTemplate baseName (Some name) el\n\n        and convert (p: Element) (n: Node) =\n            if n !==. null then\n                let next = n.NextSibling\n                if n.NodeType = Dom.NodeType.Text then\n                    convertTextNode n\n                elif n.NodeType = Dom.NodeType.Element then\n                    convertElement (n :?> Dom.Element)\n                convert p next\n\n        let fakeroot = Doc'.FakeRoot els\n        Docs.LoadedTemplates.[Doc'.ComposeName baseName name] <- fakeroot\n        if els.Length > 0 then convert fakeroot els.[0]\n\n    [<JavaScript>]\n    static member PrepareTemplate (baseName: string) (name: option<string>) (els: unit -> Node[]) =\n        if not (Docs.LoadedTemplates.ContainsKey(Doc'.ComposeName baseName name)) then\n            let els = els()\n            for el in els do\n                match el.ParentNode :?> Element with\n                | null -> ()\n                | p -> p.RemoveChild(el) |> ignore\n            Doc'.PrepareTemplateStrict baseName name els\n\n    [<JavaScript>]\n    static member LoadLocalTemplates baseName =\n        let rec run () =\n            match JS.Document.QuerySelector \"[ws-template]\" with\n            | null ->\n                match JS.Document.QuerySelector \"[ws-children-template]\" with\n                | null -> ()\n                | n ->\n                    let name = n.GetAttribute \"ws-children-template\"\n                    n.RemoveAttribute \"ws-children-template\"\n                    Doc'.PrepareTemplate baseName (Some name) (fun () -> DomUtility.ChildrenArray n)\n                    run ()\n            | n ->\n                let name = n.GetAttribute \"ws-template\"\n                Doc'.PrepareSingleTemplate baseName (Some name) n\n                run ()\n        run ()\n\n    [<JavaScript>]\n    static member NamedTemplate (baseName: string) (name: option<string>) (fillWith: seq<TemplateHole>) =\n        let name = Doc'.ComposeName baseName name\n        match Docs.LoadedTemplates.TryGetValue name with\n        | true, t -> Doc'.ChildrenTemplate (t.CloneNode(true) :?> Dom.Element) fillWith\n        | false, _ -> Console.Warn(\"Local template doesn't exist\", name); Doc'.Empty'\n\n    [<JavaScript>]\n    static member GetOrLoadTemplate (baseName: string) (name: option<string>) (els: unit -> Node[]) (fillWith: seq<TemplateHole>) =\n        Doc'.PrepareTemplate baseName name els\n        Doc'.NamedTemplate baseName name fillWith\n\n    [<JavaScript>]\n    static member Flatten view =\n        view\n        |> View.Map Doc'.Concat'\n        |> Doc'.EmbedView\n\n    [<JavaScript>]\n    static member Convert render view =\n        View.MapSeqCached render view |> Doc'.Flatten\n\n    [<JavaScript>]\n    static member ConvertBy key render view =\n        View.MapSeqCachedBy key render view |> Doc'.Flatten\n\n    [<JavaScript>]\n    static member ConvertSeq render view =\n        View.MapSeqCachedView render view |> Doc'.Flatten\n\n    [<JavaScript>]\n    static member ConvertSeqBy key render view =\n        View.MapSeqCachedViewBy key (As render) view |> Doc'.Flatten\n\n    [<JavaScript>]\n    static member InputInternal elemTy attr =\n        let el = DU.CreateElement elemTy\n        Doc'.Elem el (Attr.Concat (attr el)) Doc'.Empty'\n\n    [<JavaScript>]\n    static member Input attr (var: IRef<string>) =\n        Doc'.InputInternal \"input\" (fun _ ->\n            Seq.append attr [| Attr.Value var |])\n\n    [<JavaScript>]\n    static member PasswordBox attr (var: IRef<string>) =\n        Doc'.InputInternal \"input\" (fun _ ->\n            Seq.append attr [|\n                Attr.Value var\n                Attr.Create \"type\" \"password\"\n            |])\n\n    [<JavaScript>]\n    static member IntInputUnchecked attr (var: IRef<int>) =\n        Doc'.InputInternal \"input\" (fun _ ->\n            Seq.append attr [|\n                (if var.Get() = 0 then Attr.Create \"value\" \"0\" else Attr.Empty)\n                Attr.IntValueUnchecked var\n                Attr.Create \"type\" \"number\"\n            |])\n\n    [<JavaScript>]\n    static member IntInput attr (var: IRef<CheckedInput<int>>) =\n        Doc'.InputInternal \"input\" (fun el ->\n            Seq.append attr [|\n                Attr.IntValue var\n                Attr.Create \"type\" \"number\"\n            |])\n\n    [<JavaScript>]\n    static member FloatInputUnchecked attr (var: IRef<float>) =\n        Doc'.InputInternal \"input\" (fun _ ->\n            Seq.append attr [|\n                (if var.Get() = 0. then Attr.Create \"value\" \"0\" else Attr.Empty)\n                Attr.FloatValueUnchecked var\n                Attr.Create \"type\" \"number\"\n            |])\n\n    [<JavaScript>]\n    static member FloatInput attr (var: IRef<CheckedInput<float>>) =\n        Doc'.InputInternal \"input\" (fun el ->\n            Seq.append attr [|\n                Attr.FloatValue var\n                Attr.Create \"type\" \"number\"\n            |])\n\n    [<JavaScript>]\n    static member InputArea attr (var: IRef<string>) =\n        Doc'.InputInternal \"textarea\" (fun _ ->\n            Seq.append attr [| Attr.Value var |])\n\n    [<JavaScript>]\n    static member SelectImpl attrs (show: 'T -> string) (optionElements) (current: IRef<'T>) =\n        let options = ref []\n        let getIndex (el: Element) =\n            el?selectedIndex : int\n        let setIndex (el: Element) (i: int) =\n            el?selectedIndex <- i\n        let getSelectedItem el =\n            let i = getIndex el\n            (!options).[i]\n        let itemIndex x =\n            List.findIndex ((=) x) !options\n        let setSelectedItem (el: Element) item =\n            setIndex el (itemIndex item)\n        let el = DU.CreateElement \"select\"\n        let selectedItemAttr =\n            current.View\n            |> Attr.DynamicCustom setSelectedItem\n        let onChange (x: DomEvent) =\n            current.UpdateMaybe(fun x ->\n                let y = getSelectedItem el\n                if x = y then None else Some y\n            )\n        el.AddEventListener(\"change\", onChange, false)\n        let attrs =\n            Attr.Concat attrs\n            |> Attr.Append selectedItemAttr\n            |> Attr.Append (Attr.OnAfterRender (fun el -> \n                setSelectedItem el <| current.Get()))\n        Doc'.Elem el attrs (optionElements options)\n\n    [<JavaScript>]\n    static member SelectDyn attrs (show: 'T -> string) (vOptions: View<list<'T>>) (current: IRef<'T>) =\n        let optionElements options =\n            vOptions\n            |> View.Map (fun l ->\n                options := l\n                l |> Seq.mapi (fun i x -> i, x)\n            )\n            |> Doc'.Convert (fun (i, o) ->\n                As<Doc'> (\n                    Doc'.Element \"option\" [\n                        Attr.Create \"value\" (string i)\n                    ] [Doc'.TextNode (show o)]\n                )\n            )\n        Doc'.SelectImpl attrs show optionElements current\n\n    [<JavaScript>]\n    static member Select attrs show options current =\n        let optionElements rOptions =\n            rOptions := options\n            options\n            |> List.mapi (fun i o ->\n                As<Doc> (\n                    Doc'.Element \"option\" [\n                        Attr.Create \"value\" (string i)\n                    ] [Doc'.TextNode (show o)]\n                )\n            )\n            |> Doc'.Concat\n        Doc'.SelectImpl attrs show (As optionElements) current\n\n    [<JavaScript>]\n    static member SelectOptional attrs noneText show options current =\n        Doc'.Select attrs\n            (function None -> noneText | Some x -> show x)\n            (None :: List.map Some options)\n            current\n\n    [<JavaScript>]\n    static member SelectDynOptional attrs noneText show vOptions current =\n        Doc'.SelectDyn attrs\n            (function None -> noneText | Some x -> show x)\n            (vOptions |> View.Map (fun options -> None :: List.map Some options))\n            current\n\n    [<JavaScript>]\n    static member CheckBox attrs (chk: IRef<bool>) =\n        Doc'.InputInternal \"input\" (fun _ ->\n            Seq.append attrs [\n                Attr.Create \"type\" \"checkbox\"\n                Attr.Checked chk\n            ])\n\n    [<JavaScript>]\n    static member CheckBoxGroup attrs (item: 'T) (chk: IRef<list<'T>>) =\n        let rv =\n            chk.Lens\n                (List.exists ((=) item))\n                (fun l b ->\n                    if b then\n                        if List.exists ((=) item) l then l else item :: l\n                    else\n                        List.filter ((<>) item) l\n                )\n        Doc'.CheckBox attrs rv\n\n    [<JavaScript>]\n    static member Clickable elem action =\n        let el = DU.CreateElement elem\n        el.AddEventListener(\"click\", (fun (ev: DomEvent) ->\n            ev.PreventDefault()\n            action ()), false)\n        el\n\n    [<JavaScript>]\n    static member Button caption attrs action =\n        let attrs = Attr.Concat attrs\n        let el = Doc'.Clickable \"button\" action\n        Doc'.Elem el attrs (Doc'.TextNode' caption)\n\n    [<JavaScript>]\n    static member ButtonView caption attrs view action =\n        let evAttr = Attr.HandlerView \"click\" view (fun _ _ -> action)\n        let attrs = Attr.Concat (Seq.append [|evAttr|] attrs)\n        Doc'.Elem (DU.CreateElement \"button\") attrs (Doc'.TextNode' caption)\n\n    [<JavaScript>]\n    static member Link caption attrs action =\n        let attrs = Attr.Concat attrs |> Attr.Append (Attr.Create \"href\" \"#\")\n        let el = Doc'.Clickable \"a\" action\n        Doc'.Elem el attrs (Doc'.TextNode' caption)\n\n    [<JavaScript>]\n    static member LinkView caption attrs view action =\n        let evAttr = Attr.HandlerView \"click\" view (fun _ _ -> action)\n        let attrs = Attr.Concat (Seq.append [|evAttr; Attr.Create \"href\" \"#\"|] attrs)\n        Doc'.Elem (DU.CreateElement \"a\") attrs (As (Doc.TextNode caption))\n\n    [<JavaScript>]\n    static member Radio attrs value (var: IRef<_>) =\n        // Radio buttons work by taking a common var, which is given a unique ID.\n        // This ID is serialised and used as the name, giving us the \"grouping\"\n        // behaviour.\n        let el = DU.CreateElement \"input\"\n        el.AddEventListener(\"click\", (fun (x : DomEvent) -> var.Set value), false)\n        let predView = View.Map (fun x -> x = value) var.View\n        let valAttr = Attr.DynamicProp \"checked\" predView\n        let (==>) k v = Attr.Create k v\n        let attr =\n            [\n                \"type\" ==> \"radio\"\n                \"name\" ==> var.Id\n                valAttr\n            ] @ (List.ofSeq attrs) |> Attr.Concat\n        Doc'.Elem el attr Doc'.Empty'\n\n    // Actual proxy members\n\n    [<JavaScript>]\n    static member Element (name: string) (attr: seq<Attr>) (children: seq<Doc>) : Elt =\n        let attr = Attr.Concat attr\n        let children = Doc'.Concat' (As children)\n        As (Doc'.Elem (DU.CreateElement name) attr children)\n\n    static member ToMixedDoc (o: obj) =\n        match o with\n        | :? Doc as d -> d\n        | :? string as t -> Doc.TextNode t\n        | :? Element as e -> Doc'.Static e |> As<Doc>        \n        | :? Function as v ->\n            Doc'.EmbedView (\n                (As<View<_>>v).Map (As Doc'.ToMixedDoc)\n            ) |> As<Doc>\n        | :? Var<obj> as v ->\n            Doc'.EmbedView (\n                v.View.Map (As Doc'.ToMixedDoc)\n            ) |> As<Doc>\n        | null -> Doc.Empty\n        | o -> Doc.TextNode (string o)\n\n    static member MixedNodes (nodes: seq<obj>) =\n        let attrs = ResizeArray()\n        let children = ResizeArray()\n        for n in nodes do\n            match n with\n            | :? Attr as a -> attrs.Add a\n            | _ -> children.Add (Doc'.ToMixedDoc n)\n        attrs :> _ seq, children :> _ seq \n\n    static member ConcatMixed (elts: obj[]) =\n        Doc.Concat (Seq.map Doc'.ToMixedDoc elts)\n\n    [<JavaScript>]\n    static member ElementMixed (tagname: string) (nodes: seq<obj>) =\n        let attrs, children = Doc'.MixedNodes nodes\n        Doc.Element tagname attrs children \n\n    [<JavaScript>]\n    static member SvgElement (name: string) (attr: seq<Attr>) (children: seq<Doc>) : Elt =\n        let attr = Attr.Concat attr\n        let children = Doc'.Concat' (As children)\n        As (Doc'.Elem (DU.CreateSvgElement name) attr children)\n\n    [<JavaScript>]\n    static member SvgElementMixed (tagname: string) (nodes: seq<obj>) =\n        let attrs, children = Doc'.MixedNodes nodes\n        Doc.SvgElement tagname attrs children \n\n    [<JavaScript; Name \"EmptyProxy\">]\n    static member Empty\n        with [<Inline; MethodImpl(MethodImplOptions.NoInlining)>] get () : Doc =\n            As Doc'.Empty'\n\n    [<JavaScript; Inline; Name \"AppendProxy\">]\n    static member Append (a: Doc) (b: Doc) : Doc =\n        As (Doc'.Append' (As a) (As b))\n\n    [<JavaScript; Inline; Name \"ConcatProxy1\">]\n    static member Concat (xs: seq<Doc>) : Doc =\n        As (Doc'.Concat' (As xs))\n\n    [<JavaScript; Inline; Name \"TextNodeProxy\">]\n    static member TextNode (s: string) : Doc =\n        As (Doc'.TextNode' s)\n\n    // TODO: what if it's not a Doc but (eg) an Html.Client.Element ?\n    [<JavaScript; Inline>]\n    static member ClientSide (expr: Microsoft.FSharp.Quotations.Expr<#IControlBody>) : Doc =\n        As expr\n\n    [<JavaScript; Inline; Name \"VerbatimProxy\">]\n    static member Verbatim (s: string) : Doc =\n        As (Doc'.Verbatim' s)\n\nand [<JavaScript; Proxy(typeof<Elt>); Name \"WebSharper.UI.Next.Elt\">]\n    private Elt'(docNode, updates, elt: Dom.Element, rvUpdates: Updates) =\n    inherit Doc'(docNode, updates)\n\n    static member internal New(el: Dom.Element, attr: Attr, children: Doc') =\n        let node = Docs.CreateElemNode el attr children.DocNode\n        let rvUpdates = Updates.Create children.Updates\n        let attrUpdates = Attrs.Updates node.Attr\n        let updates = View.Map2Unit attrUpdates rvUpdates.View\n        new Elt'(ElemDoc node, updates, el, rvUpdates)\n\n    /// Assumes tree.Els = [| Union1Of2 someDomElement |]\n    static member internal TreeNode(tree: DocTreeNode, updates) =\n        let rvUpdates = Updates.Create updates\n        let attrUpdates =\n            tree.Attrs\n            |> Array.map (snd >> Attrs.Updates)\n            |> Array.TreeReduce (View.Const ()) View.Map2Unit\n        let updates = View.Map2Unit attrUpdates rvUpdates.View\n        new Elt'(TreeDoc tree, updates, As<Dom.Element> tree.Els.[0], rvUpdates)\n\n    [<Inline \"$0.elt\">]\n    member this.Element = elt\n\n    member this.on (ev: string, cb: Dom.Element -> #Dom.Event -> unit) =\n        elt.AddEventListener(ev, As<Dom.Event -> unit>(fun ev -> cb (As<Dom.Element>((ev :> Dom.Event).Target)) ev), false)\n        this\n\n    member this.onView (ev: string, view: View<'T>, cb: Dom.Element -> #Dom.Event -> 'T -> unit) =\n        let cb = cb elt\n        elt.AddEventListener(ev, (fun (ev: Dom.Event) -> View.Get (cb (As ev)) view), false)\n        this\n\n    [<Name \"On\"; Inline>]\n    member this.onExpr (ev: string, cb: Microsoft.FSharp.Quotations.Expr<Dom.Element -> #Dom.Event -> unit>) =\n        this.on (ev, As<_ -> _ -> _> cb)\n\n    member this.OnAfterRender (cb: Dom.Element -> unit) =\n        match docNode with\n        | ElemDoc e ->\n            e.Render <-\n                match e.Render with\n                | None -> Some cb\n                | Some f -> Some (fun el -> f el; cb el)\n        | TreeDoc e ->\n            e.Render <-\n                match e.Render with\n                | None -> Some cb\n                | Some f -> Some (fun el -> f el; cb el)\n        | _ -> failwith \"Invalid docNode in Elt\"\n        this\n\n    member this.OnAfterRenderView (view: View<'T>, cb: Dom.Element -> 'T -> unit) =\n        let id = Fresh.Id()\n        this.AppendDoc(Doc'.BindView (fun x -> this.Element?(id) <- x; Doc'.Empty') view)\n        this.OnAfterRender(fun e -> cb e e?(id))\n\n    abstract AddHole : DocElemNode -> unit \n    default this.AddHole h = \n        match docNode with\n        | TreeDoc e ->\n            e.Holes.JS.Push h |> ignore\n        | _ -> ()\n\n    abstract ClearHoles : unit -> unit \n    default this.ClearHoles() = \n        match docNode with\n        | TreeDoc e ->\n            e.Holes <- [||]\n        | _ -> ()\n\n    [<Name \"Append\">]\n    member this.AppendDoc(doc: Doc') =\n        match docNode with\n        | ElemDoc e ->\n            e.Children <- AppendDoc(e.Children, doc.DocNode)\n            Docs.InsertDoc elt doc.DocNode DU.AtEnd |> ignore\n        | TreeDoc e ->\n            let after = elt.AppendChild(JS.Document.CreateTextNode \"\")\n            let before = Docs.InsertBeforeDelim after doc.DocNode\n            this.AddHole {\n                El = elt\n                Attr = Attrs.Empty elt\n                Children = doc.DocNode\n                Delimiters = Some (before, after)\n                ElKey = Fresh.Int()\n                Render = None\n            } \n        | _ -> failwith \"Invalid docNode in Elt\"\n        rvUpdates.Value <- View.Map2Unit rvUpdates.Value doc.Updates\n\n    [<Name \"Prepend\">]\n    member this.PrependDoc(doc: Doc') =\n        match docNode with\n        | ElemDoc e ->\n            e.Children <- AppendDoc(doc.DocNode, e.Children)\n            let pos =\n                match elt.FirstChild with\n                | null -> DU.AtEnd\n                | n -> DU.BeforeNode n\n            Docs.InsertDoc elt doc.DocNode pos |> ignore\n        | TreeDoc e ->\n            let after = elt.InsertBefore(JS.Document.CreateTextNode \"\", elt.FirstChild)\n            let before = Docs.InsertBeforeDelim after doc.DocNode\n            this.AddHole {\n                El = elt\n                Attr = Attrs.Empty elt\n                Children = doc.DocNode\n                Delimiters = Some (before, after)\n                ElKey = Fresh.Int()\n                Render = None\n            }\n        | _ -> failwith \"Invalid docNode in Elt\"\n        rvUpdates.Value <- View.Map2Unit rvUpdates.Value doc.Updates\n\n    [<Name \"Clear\">]\n    member this.Clear'() =\n        match docNode with\n        | ElemDoc e ->\n            e.Children <- EmptyDoc\n        | TreeDoc e ->\n            e.Els <- [||]\n            this.ClearHoles()\n        | _ -> failwith \"Invalid docNode in Elt\"\n        rvUpdates.Value <- View.Const()\n        while (elt.HasChildNodes()) do elt.RemoveChild(elt.FirstChild) |> ignore\n\n    [<JavaScript>]\n    member this.ToUpdater() =\n        let docTreeNode : DocTreeNode =\n            match docNode with\n            | ElemDoc e ->\n                {\n                    Els = [| Union1Of2 (upcast elt) |]\n                    Holes = [||]\n                    Attrs = [| elt, e.Attr |]\n                    Render = None\n                    Dirty = true\n                }\n            | TreeDoc e -> e\n            | _ -> failwith \"Invalid docNode in Elt\"\n\n        EltUpdater'(docTreeNode, updates, elt, rvUpdates, Var.Create [||])\n\n    [<Name \"Html\">]\n    member this.Html'() : string =\n        elt?outerHTML\n\n    [<Name \"Id\">]\n    member this.Id'() : string =\n        elt?id\n\n    [<Name \"GetValue\">]\n    member this.GetValue() : string =\n        elt?value\n\n    [<Name \"SetValue\">]\n    member this.SetValue(v: string) : unit =\n        elt?value <- v\n\n    [<Name \"GetText\">]\n    member this.GetText() : string =\n        elt.TextContent\n\n    [<Name \"SetText\">]\n    member this.SetText(v: string) : unit =\n        match docNode with\n        | ElemDoc e ->\n            e.Children <- EmptyDoc\n        | TreeDoc e ->\n            e.Els <- [||]\n            this.ClearHoles()\n        | _ -> failwith \"Invalid docNode in Elt\"\n        rvUpdates.Value <- View.Const()\n        elt.TextContent <- v\n\n    [<Name \"SetAttribute\">]\n    member this.SetAttribute'(name: string, value: string) =\n        elt.SetAttribute(name, value)\n\n    [<Name \"GetAttribute\">]\n    member this.GetAttribute'(name) =\n        elt.GetAttribute(name)\n\n    [<Name \"HasAttribute\">]\n    member this.HasAttribute'(name) =\n        elt.HasAttribute(name)\n\n    [<Name \"RemoveAttribute\">]\n    member this.RemoveAttribute'(name) =\n        elt.RemoveAttribute(name)\n\n    [<Name \"SetProperty\">]\n    member this.SetProperty'(name: string, value: 'T) =\n        elt?(name) <- value\n\n    [<Name \"GetProperty\">]\n    member this.GetProperty'(name: string) : 'T =\n        elt?(name)\n\n    [<Name \"AddClass\"; Direct \"$this.elt.className += ' ' + $cls\">]\n    member this.AddClass'(cls: string) = X<unit>\n\n    [<Name \"RemoveClass\">]\n    member this.RemoveClass'(cls: string) =\n        elt?className <-\n            (elt?className: String).Replace(\n                new RegExp(@\"(?:(\\s|^)\" + cls + @\")+(\\s|$)\", \"g\"),\n                \"$1\")\n\n    [<Name \"HasClass\">]\n    member this.HasClass'(cls: string) =\n        (new RegExp(@\"(\\s|^)\" + cls + @\"(\\s|$)\")).Test(elt?className)\n\n    [<Name \"SetStyle\">]\n    member this.SetStyle'(style: string, value: string) =\n        elt?style?(style) <- value\n\nand [<JavaScript; Proxy(typeof<EltUpdater>)>] \n    private EltUpdater'(treeNode : DocTreeNode, updates, elt, rvUpdates: Updates, holeUpdates: Var<(int * View<unit>)[]>) =\n    inherit Elt'(\n        TreeDoc treeNode, \n        View.Map2Unit updates (holeUpdates.View |> View.BindInner (Array.map snd >> Array.TreeReduce (View.Const ()) View.Map2Unit)),\n        elt, rvUpdates)\n\n    let mutable origHoles = treeNode.Holes\n\n    override this.AddHole h =\n        origHoles.JS.Push h |> ignore\n        treeNode.Holes <- Array.append treeNode.Holes [| h |]\n\n    override this.ClearHoles() =\n        origHoles <- [||]\n        treeNode.Holes <- [||]\n        holeUpdates.Value <- [||]\n\n    member this.AddUpdated(doc: Elt) =\n        let d = As<Elt'> doc\n        match d.DocNode with\n        | ElemDoc e ->\n            treeNode.Holes <- Array.append treeNode.Holes [| e |]\n            let hu = holeUpdates.Value\n            hu.JS.Push ((e.ElKey, d.Updates)) |> ignore\n            holeUpdates.Value <- hu\n        | _ -> failwith \"DocUpdater.AddUpdated expects a single element node\"\n\n    member this.RemoveUpdated(doc: Elt) =\n        let d = As<Elt'> doc\n        match d.DocNode with\n        | ElemDoc e ->\n            let k = e.ElKey\n            treeNode.Holes <-\n                treeNode.Holes |> Array.filter (fun h -> h.ElKey <> k)\n            holeUpdates.Value <-\n                holeUpdates.Value |> Array.filter (function\n                    | uk, _ when uk = k -> false\n                    | _ -> true\n                )  \n        | _ -> failwith \"DocUpdater.RemoveUpdated expects a single element node\"\n\n    member this.RemoveAllUpdated() =\n        treeNode.Holes <- origHoles\n        holeUpdates.Value <- [||]\n\n[<AutoOpen; JavaScript>]\nmodule EltExtensions =\n\n    type Elt with\n\n        [<Inline \"$0.elt\">]\n        member this.Dom =\n            (As<Elt'> this).Element\n\n        [<Inline>]\n        member this.Html =\n            (As<Elt'> this).Html'()\n\n        [<Inline>]\n        member this.Id =\n            (As<Elt'> this).Id'()\n\n        member this.Value\n            with [<Inline>] get() = (As<Elt'> this).GetValue()\n            and [<Inline>] set v = (As<Elt'> this).SetValue(v)\n\n        member this.Text\n            with [<Inline>] get() = (As<Elt'> this).GetText()\n            and [<Inline>] set v = (As<Elt'> this).SetText(v)\n\n[<JavaScript; CompiledName \"DocModule\">]\nmodule Doc =\n\n    [<Inline>]\n    let Static el : Elt =\n        Doc'.Static el\n\n    [<Inline>]\n    let EmbedView (view: View<#Doc>) : Doc =\n        As (Doc'.EmbedView (As view))\n\n    [<Inline>]\n    let BindView (f: 'T -> #Doc) (view: View<'T>) : Doc =\n        As (Doc'.BindView (As f) view)\n\n    [<Inline>]\n    let Async (a: Async<#Doc>) : Doc =\n        As (Doc'.Async (As a))\n\n    [<Inline>]\n    let Template (el: Node[]) (fillWith: seq<TemplateHole>) : Doc =\n        As (Doc'.Template el fillWith)\n\n    [<Inline>]\n    let LoadLocalTemplates baseName =\n        Doc'.LoadLocalTemplates baseName\n\n    [<Inline>]\n    let LoadTemplate (baseName: string) (name: option<string>) (el: unit -> Node[]) =\n        Doc'.PrepareTemplate baseName name el\n\n    [<Inline>]\n    let NamedTemplate (baseName: string) (name: option<string>) (fillWith: seq<TemplateHole>) : Doc =\n        As (Doc'.NamedTemplate baseName name fillWith)\n\n    [<Inline>]\n    let GetOrLoadTemplate (baseName: string) (name: option<string>) (el: unit -> Node[]) (fillWith: seq<TemplateHole>) : Doc =\n        As (Doc'.GetOrLoadTemplate baseName name el fillWith)\n\n    [<Inline>]\n    let Run parent (doc: Doc) =\n        Doc'.Run parent (As doc)\n\n    [<Inline>]\n    let RunById id (tr: Doc) =\n        Doc'.RunById id (As tr)\n\n    [<Inline>]\n    let RunBefore parent (doc: Doc) =\n        Doc'.RunBefore parent (As doc)\n\n    [<Inline>]\n    let RunBeforeById id (tr: Doc) =\n        Doc'.RunBeforeById id (As tr)\n\n    [<Inline>]\n    let RunAfter parent (doc: Doc) =\n        Doc'.RunAfter parent (As doc)\n\n    [<Inline>]\n    let RunAfterById id (tr: Doc) =\n        Doc'.RunAfterById id (As tr)\n\n    [<Inline>]\n    let RunAppend parent (doc: Doc) =\n        Doc'.RunAppend parent (As doc)\n\n    [<Inline>]\n    let RunAppendById id (tr: Doc) =\n        Doc'.RunAppendById id (As tr)\n\n    [<Inline>]\n    let RunPrepend parent (doc: Doc) =\n        Doc'.RunPrepend parent (As doc)\n\n    [<Inline>]\n    let RunPrependById id (tr: Doc) =\n        Doc'.RunPrependById id (As tr)\n\n    [<Inline>]\n    let RunReplace (elt: Node) (doc: Doc) =\n        (doc :> IControlBody).ReplaceInDom(elt)\n\n    [<Inline>]\n    let RunReplaceById id (tr: Doc) =\n        Doc'.RunReplaceById id (As tr)\n\n    [<Inline>]\n    let TextView txt : Doc =\n        As (Doc'.TextView txt)\n\n  // Collections ----------------------------------------------------------------\n\n    [<Inline>]\n    let BindSeqCached (render: 'T -> #Doc) (view: View<#seq<'T>>) : Doc =\n        As (Doc'.Convert (As render) view)\n\n    [<Inline>]\n    let Convert f (v: View<seq<_>>) = BindSeqCached f v\n\n    [<Inline>]\n    let BindSeqCachedBy (key: 'T -> 'K) (render: 'T -> #Doc) (view: View<#seq<'T>>) : Doc =\n        As (Doc'.ConvertBy key (As render) view)\n\n    [<Inline>]\n    let ConvertBy k f (v: View<seq<_>>) = BindSeqCachedBy k f v\n\n    [<Inline>]\n    let BindSeqCachedView (render: View<'T> -> #Doc) (view: View<#seq<'T>>) : Doc =\n        As (Doc'.ConvertSeq (As render) view)\n\n    [<Inline>]\n    let ConvertSeq f (v: View<seq<_>>) = BindSeqCachedView f v\n\n    [<Inline>]\n    let BindSeqCachedViewBy (key: 'T -> 'K) (render: 'K -> View<'T> -> #Doc) (view: View<#seq<'T>>) : Doc =\n        As (Doc'.ConvertSeqBy key render view)\n\n    [<Inline>]\n    let ConvertSeqBy k f (v: View<seq<_>>) = BindSeqCachedViewBy k f v\n\n    [<Inline>]\n    let ToUpdater (e: Elt) = As<EltUpdater>((As<Elt'> e).ToUpdater() )\n\n  // Form helpers ---------------------------------------------------------------\n\n    [<Inline>]\n    let Input attr var =\n        Doc'.Input attr var\n\n    [<Inline>]\n    let PasswordBox attr var =\n        Doc'.PasswordBox attr var\n\n    [<Inline>]\n    let IntInput attr var =\n        Doc'.IntInput attr var\n\n    [<Inline>]\n    let IntInputUnchecked attr var =\n        Doc'.IntInputUnchecked attr var\n\n    [<Inline>]\n    let FloatInput attr var =\n        Doc'.FloatInput attr var\n\n    [<Inline>]\n    let FloatInputUnchecked attr var =\n        Doc'.FloatInputUnchecked attr var\n\n    [<Inline>]\n    let InputArea attr var =\n        Doc'.InputArea attr var\n\n    [<Inline>]\n    let Select attrs show options current =\n        Doc'.Select attrs show options current\n\n    [<Inline>]\n    let SelectDyn attrs show options current =\n        Doc'.SelectDyn attrs show options current\n\n    [<Inline>]\n    let SelectOptional attrs noneText show options current =\n        Doc'.SelectOptional attrs noneText show options current\n\n    [<Inline>]\n    let SelectDynOptional attrs noneText show options current =\n        Doc'.SelectDynOptional attrs noneText show options current\n\n    [<Inline>]\n    let CheckBox attrs chk =\n        Doc'.CheckBox attrs chk\n\n    [<Inline>]\n    let CheckBoxGroup attrs item chk =\n        Doc'.CheckBoxGroup attrs item chk\n\n    [<Inline>]\n    let Button caption attrs action =\n        Doc'.Button caption attrs action\n\n    [<Inline>]\n    let ButtonView caption attrs view action =\n        Doc'.ButtonView caption attrs view action\n\n    [<Inline>]\n    let Link caption attrs action =\n        Doc'.Link caption attrs action\n\n    [<Inline>]\n    let LinkView caption attrs view action =\n        Doc'.LinkView caption attrs view action\n\n    [<Inline>]\n    let Radio attrs value var =\n        Doc'.Radio attrs value var\n\n[<Extension; Sealed; JavaScript>]\ntype DocExtensions =\n\n    [<Extension; Inline>]\n    static member GetDom(this: Elt) = this.Dom\n\n    [<Extension; Inline>]\n    static member GetHtml(this: Elt) = this.Html\n\n    [<Extension; Inline>]\n    static member GetId(this: Elt) = this.Id\n\n    [<Extension; Inline>]\n    static member GetValue(this: Elt) = this.Value\n\n    [<Extension; Inline>]\n    static member SetValue(this: Elt, v) = this.Value <- v\n\n    [<Extension; Inline>]\n    static member GetText(this: Elt) = this.Text\n\n    [<Extension; Inline>]\n    static member SetText(this: Elt, v) = this.Text <- v\n\n    [<Extension; Inline>]\n    static member Doc(v, f) = Doc.BindView f v\n\n    [<Extension; Inline>]\n    static member DocSeqCached(v: View<seq<_>>, f) = Doc.BindSeqCached f v\n\n    [<Extension; Inline>]\n    static member DocSeqCached(v: View<seq<_>>, k, f) = Doc.BindSeqCachedBy k f v\n\n    [<Extension; Inline>]\n    static member DocSeqCached(v: View<seq<_>>, f) = Doc.BindSeqCachedView f v\n\n    [<Extension; Inline>]\n    static member DocSeqCached(v: View<seq<_>>, k, f) = Doc.BindSeqCachedViewBy k f v\n\n    [<Extension; Inline>]\n    static member DocSeqCached(v: View<list<_>>, f) = Doc.BindSeqCached f v\n\n    [<Extension; Inline>]\n    static member DocSeqCached(v: View<list<_>>, k, f) = Doc.BindSeqCachedBy k f v\n\n    [<Extension; Inline>]\n    static member DocSeqCached(v: View<list<_>>, f) = Doc.BindSeqCachedView f v\n\n    [<Extension; Inline>]\n    static member DocSeqCached(v: View<list<_>>, k, f) = Doc.BindSeqCachedViewBy k f v\n\n    [<Extension; Inline>]\n    static member DocSeqCached(v: View<array<_>>, f) = Doc.BindSeqCached f v\n\n    [<Extension; Inline>]\n    static member DocSeqCached(v: View<array<_>>, k, f) = Doc.BindSeqCachedBy k f v\n\n    [<Extension; Inline>]\n    static member DocSeqCached(v: View<array<_>>, f) = Doc.BindSeqCachedView f v\n\n    [<Extension; Inline>]\n    static member DocSeqCached(v: View<array<_>>, k, f) = Doc.BindSeqCachedViewBy k f v\n\n    [<Extension; Inline>]\n    static member DocSeqCached(v: View<ListModelState<_>>, f) = Doc.BindSeqCached f v\n\n    [<Extension; Inline>]\n    static member DocSeqCached(v: View<ListModelState<_>>, k, f) = Doc.BindSeqCachedBy k f v\n\n    [<Extension; Inline>]\n    static member DocSeqCached(v: View<ListModelState<_>>, f) = Doc.BindSeqCachedView f v\n\n    [<Extension; Inline>]\n    static member DocSeqCached(v: View<ListModelState<_>>, k, f) = Doc.BindSeqCachedViewBy k f v\n\n    [<Extension; Inline>]\n    static member RunById(doc: Doc, id: string) =\n        Doc'.RunById id (As<Doc'> doc)\n\n    [<Extension; Inline>]\n    static member Run(doc: Doc, elt: Dom.Element) =\n        Doc'.Run elt (As<Doc'> doc)\n\n    [<Extension; Inline>]\n    static member ToUpdater(elt:Elt) =\n        As<EltUpdater> ((As<Elt'> elt).ToUpdater())\n\n    [<Extension; Inline>]\n    static member Append(this: Elt, doc: Doc) =\n        (As<Elt'> this).AppendDoc(As<Doc'> doc)\n\n    [<Extension; Inline>]\n    static member Prepend(this: Elt, doc: Doc) =\n        (As<Elt'> this).PrependDoc(As<Doc'> doc)\n\n    [<Extension; Inline>]\n    static member AppendChild(this: Elt, doc: Doc) =\n        (As<Elt'> this).AppendDoc(As<Doc'> doc)\n\n    [<Extension; Inline>]\n    static member PrependChild(this: Elt, doc: Doc) =\n        (As<Elt'> this).PrependDoc(As<Doc'> doc)\n\n    [<Extension; Inline>]\n    static member Clear(this: Elt) =\n        (As<Elt'> this).Clear'()\n\n    [<Extension; Inline>]\n    static member On(this: Elt, event, cb: Dom.Element -> Dom.Event -> unit) =\n        As<Elt> ((As<Elt'> this).on(event, cb))\n\n    [<Extension; Inline>]\n    static member OnAfterRender(this: Elt, cb: Dom.Element -> unit) =\n        As<Elt> ((As<Elt'> this).OnAfterRender(cb))\n\n    [<Extension; Inline>]\n    static member OnAfterRenderView(this: Elt, view: View<'T>, cb: Dom.Element -> 'T -> unit) =\n        As<Elt> ((As<Elt'> this).OnAfterRenderView(view, cb))\n\n    [<Extension; Inline>]\n    static member SetAttribute(this: Elt, name, value) =\n        (As<Elt'> this).SetAttribute'(name, value)\n\n    [<Extension; Inline>]\n    static member GetAttribute(this: Elt, name) =\n        (As<Elt'> this).GetAttribute'(name)\n\n    [<Extension; Inline>]\n    static member HasAttribute(this: Elt, name) =\n        (As<Elt'> this).HasAttribute'(name)\n\n    [<Extension; Inline>]\n    static member RemoveAttribute(this: Elt, name) =\n        (As<Elt'> this).RemoveAttribute'(name)\n\n    [<Extension; Inline>]\n    static member SetProperty(this: Elt, name, value) =\n        (As<Elt'> this).SetProperty'(name, value)\n\n    [<Extension; Inline>]\n    static member GetProperty(this: Elt, name) =\n        (As<Elt'> this).GetProperty'(name)\n\n    [<Extension; Inline>]\n    static member AddClass(this: Elt, cls) =\n        (As<Elt'> this).AddClass'(cls)\n\n    [<Extension; Inline>]\n    static member RemoveClass(this: Elt, cls) =\n        (As<Elt'> this).RemoveClass'(cls)\n\n    [<Extension; Inline>]\n    static member HasClass(this: Elt, cls) =\n        (As<Elt'> this).HasClass'(cls)\n\n    [<Extension; Inline>]\n    static member SetStyle(this: Elt, name, value) =\n        (As<Elt'> this).SetStyle'(name, value)\n\n    // {{ event\n    [<Extension; Inline>]\n    static member OnAbort(this: Elt, cb: Dom.Element -> Dom.UIEvent -> unit) = As<Elt> ((As<Elt'> this).on(\"abort\", cb))\n    [<Extension; Inline>]\n    static member OnAbortView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.UIEvent -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"abort\", view, cb))\n    [<Extension; Inline>]\n    static member OnAfterPrint(this: Elt, cb: Dom.Element -> Dom.Event -> unit) = As<Elt> ((As<Elt'> this).on(\"afterprint\", cb))\n    [<Extension; Inline>]\n    static member OnAfterPrintView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.Event -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"afterprint\", view, cb))\n    [<Extension; Inline>]\n    static member OnAnimationEnd(this: Elt, cb: Dom.Element -> Dom.Event -> unit) = As<Elt> ((As<Elt'> this).on(\"animationend\", cb))\n    [<Extension; Inline>]\n    static member OnAnimationEndView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.Event -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"animationend\", view, cb))\n    [<Extension; Inline>]\n    static member OnAnimationIteration(this: Elt, cb: Dom.Element -> Dom.Event -> unit) = As<Elt> ((As<Elt'> this).on(\"animationiteration\", cb))\n    [<Extension; Inline>]\n    static member OnAnimationIterationView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.Event -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"animationiteration\", view, cb))\n    [<Extension; Inline>]\n    static member OnAnimationStart(this: Elt, cb: Dom.Element -> Dom.Event -> unit) = As<Elt> ((As<Elt'> this).on(\"animationstart\", cb))\n    [<Extension; Inline>]\n    static member OnAnimationStartView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.Event -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"animationstart\", view, cb))\n    [<Extension; Inline>]\n    static member OnAudioProcess(this: Elt, cb: Dom.Element -> Dom.Event -> unit) = As<Elt> ((As<Elt'> this).on(\"audioprocess\", cb))\n    [<Extension; Inline>]\n    static member OnAudioProcessView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.Event -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"audioprocess\", view, cb))\n    [<Extension; Inline>]\n    static member OnBeforePrint(this: Elt, cb: Dom.Element -> Dom.Event -> unit) = As<Elt> ((As<Elt'> this).on(\"beforeprint\", cb))\n    [<Extension; Inline>]\n    static member OnBeforePrintView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.Event -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"beforeprint\", view, cb))\n    [<Extension; Inline>]\n    static member OnBeforeUnload(this: Elt, cb: Dom.Element -> Dom.Event -> unit) = As<Elt> ((As<Elt'> this).on(\"beforeunload\", cb))\n    [<Extension; Inline>]\n    static member OnBeforeUnloadView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.Event -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"beforeunload\", view, cb))\n    [<Extension; Inline>]\n    static member OnBeginEvent(this: Elt, cb: Dom.Element -> Dom.Event -> unit) = As<Elt> ((As<Elt'> this).on(\"beginEvent\", cb))\n    [<Extension; Inline>]\n    static member OnBeginEventView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.Event -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"beginEvent\", view, cb))\n    [<Extension; Inline>]\n    static member OnBlocked(this: Elt, cb: Dom.Element -> Dom.Event -> unit) = As<Elt> ((As<Elt'> this).on(\"blocked\", cb))\n    [<Extension; Inline>]\n    static member OnBlockedView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.Event -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"blocked\", view, cb))\n    [<Extension; Inline>]\n    static member OnBlur(this: Elt, cb: Dom.Element -> Dom.FocusEvent -> unit) = As<Elt> ((As<Elt'> this).on(\"blur\", cb))\n    [<Extension; Inline>]\n    static member OnBlurView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.FocusEvent -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"blur\", view, cb))\n    [<Extension; Inline>]\n    static member OnCached(this: Elt, cb: Dom.Element -> Dom.Event -> unit) = As<Elt> ((As<Elt'> this).on(\"cached\", cb))\n    [<Extension; Inline>]\n    static member OnCachedView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.Event -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"cached\", view, cb))\n    [<Extension; Inline>]\n    static member OnCanPlay(this: Elt, cb: Dom.Element -> Dom.Event -> unit) = As<Elt> ((As<Elt'> this).on(\"canplay\", cb))\n    [<Extension; Inline>]\n    static member OnCanPlayView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.Event -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"canplay\", view, cb))\n    [<Extension; Inline>]\n    static member OnCanPlayThrough(this: Elt, cb: Dom.Element -> Dom.Event -> unit) = As<Elt> ((As<Elt'> this).on(\"canplaythrough\", cb))\n    [<Extension; Inline>]\n    static member OnCanPlayThroughView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.Event -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"canplaythrough\", view, cb))\n    [<Extension; Inline>]\n    static member OnChange(this: Elt, cb: Dom.Element -> Dom.Event -> unit) = As<Elt> ((As<Elt'> this).on(\"change\", cb))\n    [<Extension; Inline>]\n    static member OnChangeView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.Event -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"change\", view, cb))\n    [<Extension; Inline>]\n    static member OnChargingChange(this: Elt, cb: Dom.Element -> Dom.Event -> unit) = As<Elt> ((As<Elt'> this).on(\"chargingchange\", cb))\n    [<Extension; Inline>]\n    static member OnChargingChangeView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.Event -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"chargingchange\", view, cb))\n    [<Extension; Inline>]\n    static member OnChargingTimeChange(this: Elt, cb: Dom.Element -> Dom.Event -> unit) = As<Elt> ((As<Elt'> this).on(\"chargingtimechange\", cb))\n    [<Extension; Inline>]\n    static member OnChargingTimeChangeView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.Event -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"chargingtimechange\", view, cb))\n    [<Extension; Inline>]\n    static member OnChecking(this: Elt, cb: Dom.Element -> Dom.Event -> unit) = As<Elt> ((As<Elt'> this).on(\"checking\", cb))\n    [<Extension; Inline>]\n    static member OnCheckingView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.Event -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"checking\", view, cb))\n    [<Extension; Inline>]\n    static member OnClick(this: Elt, cb: Dom.Element -> Dom.MouseEvent -> unit) = As<Elt> ((As<Elt'> this).on(\"click\", cb))\n    [<Extension; Inline>]\n    static member OnClickView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.MouseEvent -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"click\", view, cb))\n    [<Extension; Inline>]\n    static member OnClose(this: Elt, cb: Dom.Element -> Dom.Event -> unit) = As<Elt> ((As<Elt'> this).on(\"close\", cb))\n    [<Extension; Inline>]\n    static member OnCloseView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.Event -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"close\", view, cb))\n    [<Extension; Inline>]\n    static member OnComplete(this: Elt, cb: Dom.Element -> Dom.Event -> unit) = As<Elt> ((As<Elt'> this).on(\"complete\", cb))\n    [<Extension; Inline>]\n    static member OnCompleteView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.Event -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"complete\", view, cb))\n    [<Extension; Inline>]\n    static member OnCompositionEnd(this: Elt, cb: Dom.Element -> Dom.CompositionEvent -> unit) = As<Elt> ((As<Elt'> this).on(\"compositionend\", cb))\n    [<Extension; Inline>]\n    static member OnCompositionEndView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.CompositionEvent -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"compositionend\", view, cb))\n    [<Extension; Inline>]\n    static member OnCompositionStart(this: Elt, cb: Dom.Element -> Dom.CompositionEvent -> unit) = As<Elt> ((As<Elt'> this).on(\"compositionstart\", cb))\n    [<Extension; Inline>]\n    static member OnCompositionStartView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.CompositionEvent -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"compositionstart\", view, cb))\n    [<Extension; Inline>]\n    static member OnCompositionUpdate(this: Elt, cb: Dom.Element -> Dom.CompositionEvent -> unit) = As<Elt> ((As<Elt'> this).on(\"compositionupdate\", cb))\n    [<Extension; Inline>]\n    static member OnCompositionUpdateView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.CompositionEvent -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"compositionupdate\", view, cb))\n    [<Extension; Inline>]\n    static member OnContextMenu(this: Elt, cb: Dom.Element -> Dom.MouseEvent -> unit) = As<Elt> ((As<Elt'> this).on(\"contextmenu\", cb))\n    [<Extension; Inline>]\n    static member OnContextMenuView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.MouseEvent -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"contextmenu\", view, cb))\n    [<Extension; Inline>]\n    static member OnCopy(this: Elt, cb: Dom.Element -> Dom.Event -> unit) = As<Elt> ((As<Elt'> this).on(\"copy\", cb))\n    [<Extension; Inline>]\n    static member OnCopyView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.Event -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"copy\", view, cb))\n    [<Extension; Inline>]\n    static member OnCut(this: Elt, cb: Dom.Element -> Dom.Event -> unit) = As<Elt> ((As<Elt'> this).on(\"cut\", cb))\n    [<Extension; Inline>]\n    static member OnCutView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.Event -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"cut\", view, cb))\n    [<Extension; Inline>]\n    static member OnDblClick(this: Elt, cb: Dom.Element -> Dom.MouseEvent -> unit) = As<Elt> ((As<Elt'> this).on(\"dblclick\", cb))\n    [<Extension; Inline>]\n    static member OnDblClickView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.MouseEvent -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"dblclick\", view, cb))\n    [<Extension; Inline>]\n    static member OnDeviceLight(this: Elt, cb: Dom.Element -> Dom.Event -> unit) = As<Elt> ((As<Elt'> this).on(\"devicelight\", cb))\n    [<Extension; Inline>]\n    static member OnDeviceLightView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.Event -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"devicelight\", view, cb))\n    [<Extension; Inline>]\n    static member OnDeviceMotion(this: Elt, cb: Dom.Element -> Dom.Event -> unit) = As<Elt> ((As<Elt'> this).on(\"devicemotion\", cb))\n    [<Extension; Inline>]\n    static member OnDeviceMotionView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.Event -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"devicemotion\", view, cb))\n    [<Extension; Inline>]\n    static member OnDeviceOrientation(this: Elt, cb: Dom.Element -> Dom.Event -> unit) = As<Elt> ((As<Elt'> this).on(\"deviceorientation\", cb))\n    [<Extension; Inline>]\n    static member OnDeviceOrientationView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.Event -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"deviceorientation\", view, cb))\n    [<Extension; Inline>]\n    static member OnDeviceProximity(this: Elt, cb: Dom.Element -> Dom.Event -> unit) = As<Elt> ((As<Elt'> this).on(\"deviceproximity\", cb))\n    [<Extension; Inline>]\n    static member OnDeviceProximityView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.Event -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"deviceproximity\", view, cb))\n    [<Extension; Inline>]\n    static member OnDischargingTimeChange(this: Elt, cb: Dom.Element -> Dom.Event -> unit) = As<Elt> ((As<Elt'> this).on(\"dischargingtimechange\", cb))\n    [<Extension; Inline>]\n    static member OnDischargingTimeChangeView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.Event -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"dischargingtimechange\", view, cb))\n    [<Extension; Inline>]\n    static member OnDOMActivate(this: Elt, cb: Dom.Element -> Dom.UIEvent -> unit) = As<Elt> ((As<Elt'> this).on(\"DOMActivate\", cb))\n    [<Extension; Inline>]\n    static member OnDOMActivateView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.UIEvent -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"DOMActivate\", view, cb))\n    [<Extension; Inline>]\n    static member OnDOMAttributeNameChanged(this: Elt, cb: Dom.Element -> Dom.Event -> unit) = As<Elt> ((As<Elt'> this).on(\"DOMAttributeNameChanged\", cb))\n    [<Extension; Inline>]\n    static member OnDOMAttributeNameChangedView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.Event -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"DOMAttributeNameChanged\", view, cb))\n    [<Extension; Inline>]\n    static member OnDOMAttrModified(this: Elt, cb: Dom.Element -> Dom.MutationEvent -> unit) = As<Elt> ((As<Elt'> this).on(\"DOMAttrModified\", cb))\n    [<Extension; Inline>]\n    static member OnDOMAttrModifiedView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.MutationEvent -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"DOMAttrModified\", view, cb))\n    [<Extension; Inline>]\n    static member OnDOMCharacterDataModified(this: Elt, cb: Dom.Element -> Dom.MutationEvent -> unit) = As<Elt> ((As<Elt'> this).on(\"DOMCharacterDataModified\", cb))\n    [<Extension; Inline>]\n    static member OnDOMCharacterDataModifiedView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.MutationEvent -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"DOMCharacterDataModified\", view, cb))\n    [<Extension; Inline>]\n    static member OnDOMContentLoaded(this: Elt, cb: Dom.Element -> Dom.Event -> unit) = As<Elt> ((As<Elt'> this).on(\"DOMContentLoaded\", cb))\n    [<Extension; Inline>]\n    static member OnDOMContentLoadedView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.Event -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"DOMContentLoaded\", view, cb))\n    [<Extension; Inline>]\n    static member OnDOMElementNameChanged(this: Elt, cb: Dom.Element -> Dom.Event -> unit) = As<Elt> ((As<Elt'> this).on(\"DOMElementNameChanged\", cb))\n    [<Extension; Inline>]\n    static member OnDOMElementNameChangedView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.Event -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"DOMElementNameChanged\", view, cb))\n    [<Extension; Inline>]\n    static member OnDOMNodeInserted(this: Elt, cb: Dom.Element -> Dom.MutationEvent -> unit) = As<Elt> ((As<Elt'> this).on(\"DOMNodeInserted\", cb))\n    [<Extension; Inline>]\n    static member OnDOMNodeInsertedView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.MutationEvent -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"DOMNodeInserted\", view, cb))\n    [<Extension; Inline>]\n    static member OnDOMNodeInsertedIntoDocument(this: Elt, cb: Dom.Element -> Dom.MutationEvent -> unit) = As<Elt> ((As<Elt'> this).on(\"DOMNodeInsertedIntoDocument\", cb))\n    [<Extension; Inline>]\n    static member OnDOMNodeInsertedIntoDocumentView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.MutationEvent -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"DOMNodeInsertedIntoDocument\", view, cb))\n    [<Extension; Inline>]\n    static member OnDOMNodeRemoved(this: Elt, cb: Dom.Element -> Dom.MutationEvent -> unit) = As<Elt> ((As<Elt'> this).on(\"DOMNodeRemoved\", cb))\n    [<Extension; Inline>]\n    static member OnDOMNodeRemovedView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.MutationEvent -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"DOMNodeRemoved\", view, cb))\n    [<Extension; Inline>]\n    static member OnDOMNodeRemovedFromDocument(this: Elt, cb: Dom.Element -> Dom.MutationEvent -> unit) = As<Elt> ((As<Elt'> this).on(\"DOMNodeRemovedFromDocument\", cb))\n    [<Extension; Inline>]\n    static member OnDOMNodeRemovedFromDocumentView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.MutationEvent -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"DOMNodeRemovedFromDocument\", view, cb))\n    [<Extension; Inline>]\n    static member OnDOMSubtreeModified(this: Elt, cb: Dom.Element -> Dom.MutationEvent -> unit) = As<Elt> ((As<Elt'> this).on(\"DOMSubtreeModified\", cb))\n    [<Extension; Inline>]\n    static member OnDOMSubtreeModifiedView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.MutationEvent -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"DOMSubtreeModified\", view, cb))\n    [<Extension; Inline>]\n    static member OnDownloading(this: Elt, cb: Dom.Element -> Dom.Event -> unit) = As<Elt> ((As<Elt'> this).on(\"downloading\", cb))\n    [<Extension; Inline>]\n    static member OnDownloadingView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.Event -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"downloading\", view, cb))\n    [<Extension; Inline>]\n    static member OnDrag(this: Elt, cb: Dom.Element -> Dom.Event -> unit) = As<Elt> ((As<Elt'> this).on(\"drag\", cb))\n    [<Extension; Inline>]\n    static member OnDragView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.Event -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"drag\", view, cb))\n    [<Extension; Inline>]\n    static member OnDragEnd(this: Elt, cb: Dom.Element -> Dom.Event -> unit) = As<Elt> ((As<Elt'> this).on(\"dragend\", cb))\n    [<Extension; Inline>]\n    static member OnDragEndView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.Event -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"dragend\", view, cb))\n    [<Extension; Inline>]\n    static member OnDragEnter(this: Elt, cb: Dom.Element -> Dom.Event -> unit) = As<Elt> ((As<Elt'> this).on(\"dragenter\", cb))\n    [<Extension; Inline>]\n    static member OnDragEnterView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.Event -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"dragenter\", view, cb))\n    [<Extension; Inline>]\n    static member OnDragLeave(this: Elt, cb: Dom.Element -> Dom.Event -> unit) = As<Elt> ((As<Elt'> this).on(\"dragleave\", cb))\n    [<Extension; Inline>]\n    static member OnDragLeaveView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.Event -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"dragleave\", view, cb))\n    [<Extension; Inline>]\n    static member OnDragOver(this: Elt, cb: Dom.Element -> Dom.Event -> unit) = As<Elt> ((As<Elt'> this).on(\"dragover\", cb))\n    [<Extension; Inline>]\n    static member OnDragOverView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.Event -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"dragover\", view, cb))\n    [<Extension; Inline>]\n    static member OnDragStart(this: Elt, cb: Dom.Element -> Dom.Event -> unit) = As<Elt> ((As<Elt'> this).on(\"dragstart\", cb))\n    [<Extension; Inline>]\n    static member OnDragStartView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.Event -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"dragstart\", view, cb))\n    [<Extension; Inline>]\n    static member OnDrop(this: Elt, cb: Dom.Element -> Dom.Event -> unit) = As<Elt> ((As<Elt'> this).on(\"drop\", cb))\n    [<Extension; Inline>]\n    static member OnDropView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.Event -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"drop\", view, cb))\n    [<Extension; Inline>]\n    static member OnDurationChange(this: Elt, cb: Dom.Element -> Dom.Event -> unit) = As<Elt> ((As<Elt'> this).on(\"durationchange\", cb))\n    [<Extension; Inline>]\n    static member OnDurationChangeView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.Event -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"durationchange\", view, cb))\n    [<Extension; Inline>]\n    static member OnEmptied(this: Elt, cb: Dom.Element -> Dom.Event -> unit) = As<Elt> ((As<Elt'> this).on(\"emptied\", cb))\n    [<Extension; Inline>]\n    static member OnEmptiedView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.Event -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"emptied\", view, cb))\n    [<Extension; Inline>]\n    static member OnEnded(this: Elt, cb: Dom.Element -> Dom.Event -> unit) = As<Elt> ((As<Elt'> this).on(\"ended\", cb))\n    [<Extension; Inline>]\n    static member OnEndedView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.Event -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"ended\", view, cb))\n    [<Extension; Inline>]\n    static member OnEndEvent(this: Elt, cb: Dom.Element -> Dom.Event -> unit) = As<Elt> ((As<Elt'> this).on(\"endEvent\", cb))\n    [<Extension; Inline>]\n    static member OnEndEventView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.Event -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"endEvent\", view, cb))\n    [<Extension; Inline>]\n    static member OnError(this: Elt, cb: Dom.Element -> Dom.Event -> unit) = As<Elt> ((As<Elt'> this).on(\"error\", cb))\n    [<Extension; Inline>]\n    static member OnErrorView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.Event -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"error\", view, cb))\n    [<Extension; Inline>]\n    static member OnFocus(this: Elt, cb: Dom.Element -> Dom.FocusEvent -> unit) = As<Elt> ((As<Elt'> this).on(\"focus\", cb))\n    [<Extension; Inline>]\n    static member OnFocusView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.FocusEvent -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"focus\", view, cb))\n    [<Extension; Inline>]\n    static member OnFullScreenChange(this: Elt, cb: Dom.Element -> Dom.Event -> unit) = As<Elt> ((As<Elt'> this).on(\"fullscreenchange\", cb))\n    [<Extension; Inline>]\n    static member OnFullScreenChangeView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.Event -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"fullscreenchange\", view, cb))\n    [<Extension; Inline>]\n    static member OnFullScreenError(this: Elt, cb: Dom.Element -> Dom.Event -> unit) = As<Elt> ((As<Elt'> this).on(\"fullscreenerror\", cb))\n    [<Extension; Inline>]\n    static member OnFullScreenErrorView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.Event -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"fullscreenerror\", view, cb))\n    [<Extension; Inline>]\n    static member OnGamepadConnected(this: Elt, cb: Dom.Element -> Dom.Event -> unit) = As<Elt> ((As<Elt'> this).on(\"gamepadconnected\", cb))\n    [<Extension; Inline>]\n    static member OnGamepadConnectedView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.Event -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"gamepadconnected\", view, cb))\n    [<Extension; Inline>]\n    static member OnGamepadDisconnected(this: Elt, cb: Dom.Element -> Dom.Event -> unit) = As<Elt> ((As<Elt'> this).on(\"gamepaddisconnected\", cb))\n    [<Extension; Inline>]\n    static member OnGamepadDisconnectedView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.Event -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"gamepaddisconnected\", view, cb))\n    [<Extension; Inline>]\n    static member OnHashChange(this: Elt, cb: Dom.Element -> Dom.Event -> unit) = As<Elt> ((As<Elt'> this).on(\"hashchange\", cb))\n    [<Extension; Inline>]\n    static member OnHashChangeView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.Event -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"hashchange\", view, cb))\n    [<Extension; Inline>]\n    static member OnInput(this: Elt, cb: Dom.Element -> Dom.Event -> unit) = As<Elt> ((As<Elt'> this).on(\"input\", cb))\n    [<Extension; Inline>]\n    static member OnInputView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.Event -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"input\", view, cb))\n    [<Extension; Inline>]\n    static member OnInvalid(this: Elt, cb: Dom.Element -> Dom.Event -> unit) = As<Elt> ((As<Elt'> this).on(\"invalid\", cb))\n    [<Extension; Inline>]\n    static member OnInvalidView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.Event -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"invalid\", view, cb))\n    [<Extension; Inline>]\n    static member OnKeyDown(this: Elt, cb: Dom.Element -> Dom.KeyboardEvent -> unit) = As<Elt> ((As<Elt'> this).on(\"keydown\", cb))\n    [<Extension; Inline>]\n    static member OnKeyDownView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.KeyboardEvent -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"keydown\", view, cb))\n    [<Extension; Inline>]\n    static member OnKeyPress(this: Elt, cb: Dom.Element -> Dom.KeyboardEvent -> unit) = As<Elt> ((As<Elt'> this).on(\"keypress\", cb))\n    [<Extension; Inline>]\n    static member OnKeyPressView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.KeyboardEvent -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"keypress\", view, cb))\n    [<Extension; Inline>]\n    static member OnKeyUp(this: Elt, cb: Dom.Element -> Dom.KeyboardEvent -> unit) = As<Elt> ((As<Elt'> this).on(\"keyup\", cb))\n    [<Extension; Inline>]\n    static member OnKeyUpView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.KeyboardEvent -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"keyup\", view, cb))\n    [<Extension; Inline>]\n    static member OnLanguageChange(this: Elt, cb: Dom.Element -> Dom.Event -> unit) = As<Elt> ((As<Elt'> this).on(\"languagechange\", cb))\n    [<Extension; Inline>]\n    static member OnLanguageChangeView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.Event -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"languagechange\", view, cb))\n    [<Extension; Inline>]\n    static member OnLevelChange(this: Elt, cb: Dom.Element -> Dom.Event -> unit) = As<Elt> ((As<Elt'> this).on(\"levelchange\", cb))\n    [<Extension; Inline>]\n    static member OnLevelChangeView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.Event -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"levelchange\", view, cb))\n    [<Extension; Inline>]\n    static member OnLoad(this: Elt, cb: Dom.Element -> Dom.UIEvent -> unit) = As<Elt> ((As<Elt'> this).on(\"load\", cb))\n    [<Extension; Inline>]\n    static member OnLoadView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.UIEvent -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"load\", view, cb))\n    [<Extension; Inline>]\n    static member OnLoadedData(this: Elt, cb: Dom.Element -> Dom.Event -> unit) = As<Elt> ((As<Elt'> this).on(\"loadeddata\", cb))\n    [<Extension; Inline>]\n    static member OnLoadedDataView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.Event -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"loadeddata\", view, cb))\n    [<Extension; Inline>]\n    static member OnLoadedMetadata(this: Elt, cb: Dom.Element -> Dom.Event -> unit) = As<Elt> ((As<Elt'> this).on(\"loadedmetadata\", cb))\n    [<Extension; Inline>]\n    static member OnLoadedMetadataView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.Event -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"loadedmetadata\", view, cb))\n    [<Extension; Inline>]\n    static member OnLoadEnd(this: Elt, cb: Dom.Element -> Dom.Event -> unit) = As<Elt> ((As<Elt'> this).on(\"loadend\", cb))\n    [<Extension; Inline>]\n    static member OnLoadEndView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.Event -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"loadend\", view, cb))\n    [<Extension; Inline>]\n    static member OnLoadStart(this: Elt, cb: Dom.Element -> Dom.Event -> unit) = As<Elt> ((As<Elt'> this).on(\"loadstart\", cb))\n    [<Extension; Inline>]\n    static member OnLoadStartView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.Event -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"loadstart\", view, cb))\n    [<Extension; Inline>]\n    static member OnMessage(this: Elt, cb: Dom.Element -> Dom.Event -> unit) = As<Elt> ((As<Elt'> this).on(\"message\", cb))\n    [<Extension; Inline>]\n    static member OnMessageView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.Event -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"message\", view, cb))\n    [<Extension; Inline>]\n    static member OnMouseDown(this: Elt, cb: Dom.Element -> Dom.MouseEvent -> unit) = As<Elt> ((As<Elt'> this).on(\"mousedown\", cb))\n    [<Extension; Inline>]\n    static member OnMouseDownView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.MouseEvent -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"mousedown\", view, cb))\n    [<Extension; Inline>]\n    static member OnMouseEnter(this: Elt, cb: Dom.Element -> Dom.MouseEvent -> unit) = As<Elt> ((As<Elt'> this).on(\"mouseenter\", cb))\n    [<Extension; Inline>]\n    static member OnMouseEnterView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.MouseEvent -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"mouseenter\", view, cb))\n    [<Extension; Inline>]\n    static member OnMouseLeave(this: Elt, cb: Dom.Element -> Dom.MouseEvent -> unit) = As<Elt> ((As<Elt'> this).on(\"mouseleave\", cb))\n    [<Extension; Inline>]\n    static member OnMouseLeaveView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.MouseEvent -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"mouseleave\", view, cb))\n    [<Extension; Inline>]\n    static member OnMouseMove(this: Elt, cb: Dom.Element -> Dom.MouseEvent -> unit) = As<Elt> ((As<Elt'> this).on(\"mousemove\", cb))\n    [<Extension; Inline>]\n    static member OnMouseMoveView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.MouseEvent -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"mousemove\", view, cb))\n    [<Extension; Inline>]\n    static member OnMouseOut(this: Elt, cb: Dom.Element -> Dom.MouseEvent -> unit) = As<Elt> ((As<Elt'> this).on(\"mouseout\", cb))\n    [<Extension; Inline>]\n    static member OnMouseOutView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.MouseEvent -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"mouseout\", view, cb))\n    [<Extension; Inline>]\n    static member OnMouseOver(this: Elt, cb: Dom.Element -> Dom.MouseEvent -> unit) = As<Elt> ((As<Elt'> this).on(\"mouseover\", cb))\n    [<Extension; Inline>]\n    static member OnMouseOverView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.MouseEvent -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"mouseover\", view, cb))\n    [<Extension; Inline>]\n    static member OnMouseUp(this: Elt, cb: Dom.Element -> Dom.MouseEvent -> unit) = As<Elt> ((As<Elt'> this).on(\"mouseup\", cb))\n    [<Extension; Inline>]\n    static member OnMouseUpView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.MouseEvent -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"mouseup\", view, cb))\n    [<Extension; Inline>]\n    static member OnNoUpdate(this: Elt, cb: Dom.Element -> Dom.Event -> unit) = As<Elt> ((As<Elt'> this).on(\"noupdate\", cb))\n    [<Extension; Inline>]\n    static member OnNoUpdateView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.Event -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"noupdate\", view, cb))\n    [<Extension; Inline>]\n    static member OnObsolete(this: Elt, cb: Dom.Element -> Dom.Event -> unit) = As<Elt> ((As<Elt'> this).on(\"obsolete\", cb))\n    [<Extension; Inline>]\n    static member OnObsoleteView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.Event -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"obsolete\", view, cb))\n    [<Extension; Inline>]\n    static member OnOffline(this: Elt, cb: Dom.Element -> Dom.Event -> unit) = As<Elt> ((As<Elt'> this).on(\"offline\", cb))\n    [<Extension; Inline>]\n    static member OnOfflineView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.Event -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"offline\", view, cb))\n    [<Extension; Inline>]\n    static member OnOnline(this: Elt, cb: Dom.Element -> Dom.Event -> unit) = As<Elt> ((As<Elt'> this).on(\"online\", cb))\n    [<Extension; Inline>]\n    static member OnOnlineView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.Event -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"online\", view, cb))\n    [<Extension; Inline>]\n    static member OnOpen(this: Elt, cb: Dom.Element -> Dom.Event -> unit) = As<Elt> ((As<Elt'> this).on(\"open\", cb))\n    [<Extension; Inline>]\n    static member OnOpenView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.Event -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"open\", view, cb))\n    [<Extension; Inline>]\n    static member OnOrientationChange(this: Elt, cb: Dom.Element -> Dom.Event -> unit) = As<Elt> ((As<Elt'> this).on(\"orientationchange\", cb))\n    [<Extension; Inline>]\n    static member OnOrientationChangeView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.Event -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"orientationchange\", view, cb))\n    [<Extension; Inline>]\n    static member OnPageHide(this: Elt, cb: Dom.Element -> Dom.Event -> unit) = As<Elt> ((As<Elt'> this).on(\"pagehide\", cb))\n    [<Extension; Inline>]\n    static member OnPageHideView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.Event -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"pagehide\", view, cb))\n    [<Extension; Inline>]\n    static member OnPageShow(this: Elt, cb: Dom.Element -> Dom.Event -> unit) = As<Elt> ((As<Elt'> this).on(\"pageshow\", cb))\n    [<Extension; Inline>]\n    static member OnPageShowView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.Event -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"pageshow\", view, cb))\n    [<Extension; Inline>]\n    static member OnPaste(this: Elt, cb: Dom.Element -> Dom.Event -> unit) = As<Elt> ((As<Elt'> this).on(\"paste\", cb))\n    [<Extension; Inline>]\n    static member OnPasteView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.Event -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"paste\", view, cb))\n    [<Extension; Inline>]\n    static member OnPause(this: Elt, cb: Dom.Element -> Dom.Event -> unit) = As<Elt> ((As<Elt'> this).on(\"pause\", cb))\n    [<Extension; Inline>]\n    static member OnPauseView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.Event -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"pause\", view, cb))\n    [<Extension; Inline>]\n    static member OnPlay(this: Elt, cb: Dom.Element -> Dom.Event -> unit) = As<Elt> ((As<Elt'> this).on(\"play\", cb))\n    [<Extension; Inline>]\n    static member OnPlayView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.Event -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"play\", view, cb))\n    [<Extension; Inline>]\n    static member OnPlaying(this: Elt, cb: Dom.Element -> Dom.Event -> unit) = As<Elt> ((As<Elt'> this).on(\"playing\", cb))\n    [<Extension; Inline>]\n    static member OnPlayingView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.Event -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"playing\", view, cb))\n    [<Extension; Inline>]\n    static member OnPointerLockChange(this: Elt, cb: Dom.Element -> Dom.Event -> unit) = As<Elt> ((As<Elt'> this).on(\"pointerlockchange\", cb))\n    [<Extension; Inline>]\n    static member OnPointerLockChangeView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.Event -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"pointerlockchange\", view, cb))\n    [<Extension; Inline>]\n    static member OnPointerLockError(this: Elt, cb: Dom.Element -> Dom.Event -> unit) = As<Elt> ((As<Elt'> this).on(\"pointerlockerror\", cb))\n    [<Extension; Inline>]\n    static member OnPointerLockErrorView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.Event -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"pointerlockerror\", view, cb))\n    [<Extension; Inline>]\n    static member OnPopState(this: Elt, cb: Dom.Element -> Dom.Event -> unit) = As<Elt> ((As<Elt'> this).on(\"popstate\", cb))\n    [<Extension; Inline>]\n    static member OnPopStateView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.Event -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"popstate\", view, cb))\n    [<Extension; Inline>]\n    static member OnProgress(this: Elt, cb: Dom.Element -> Dom.Event -> unit) = As<Elt> ((As<Elt'> this).on(\"progress\", cb))\n    [<Extension; Inline>]\n    static member OnProgressView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.Event -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"progress\", view, cb))\n    [<Extension; Inline>]\n    static member OnRateChange(this: Elt, cb: Dom.Element -> Dom.Event -> unit) = As<Elt> ((As<Elt'> this).on(\"ratechange\", cb))\n    [<Extension; Inline>]\n    static member OnRateChangeView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.Event -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"ratechange\", view, cb))\n    [<Extension; Inline>]\n    static member OnReadyStateChange(this: Elt, cb: Dom.Element -> Dom.Event -> unit) = As<Elt> ((As<Elt'> this).on(\"readystatechange\", cb))\n    [<Extension; Inline>]\n    static member OnReadyStateChangeView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.Event -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"readystatechange\", view, cb))\n    [<Extension; Inline>]\n    static member OnRepeatEvent(this: Elt, cb: Dom.Element -> Dom.Event -> unit) = As<Elt> ((As<Elt'> this).on(\"repeatEvent\", cb))\n    [<Extension; Inline>]\n    static member OnRepeatEventView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.Event -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"repeatEvent\", view, cb))\n    [<Extension; Inline>]\n    static member OnReset(this: Elt, cb: Dom.Element -> Dom.Event -> unit) = As<Elt> ((As<Elt'> this).on(\"reset\", cb))\n    [<Extension; Inline>]\n    static member OnResetView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.Event -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"reset\", view, cb))\n    [<Extension; Inline>]\n    static member OnResize(this: Elt, cb: Dom.Element -> Dom.UIEvent -> unit) = As<Elt> ((As<Elt'> this).on(\"resize\", cb))\n    [<Extension; Inline>]\n    static member OnResizeView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.UIEvent -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"resize\", view, cb))\n    [<Extension; Inline>]\n    static member OnScroll(this: Elt, cb: Dom.Element -> Dom.UIEvent -> unit) = As<Elt> ((As<Elt'> this).on(\"scroll\", cb))\n    [<Extension; Inline>]\n    static member OnScrollView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.UIEvent -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"scroll\", view, cb))\n    [<Extension; Inline>]\n    static member OnSeeked(this: Elt, cb: Dom.Element -> Dom.Event -> unit) = As<Elt> ((As<Elt'> this).on(\"seeked\", cb))\n    [<Extension; Inline>]\n    static member OnSeekedView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.Event -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"seeked\", view, cb))\n    [<Extension; Inline>]\n    static member OnSeeking(this: Elt, cb: Dom.Element -> Dom.Event -> unit) = As<Elt> ((As<Elt'> this).on(\"seeking\", cb))\n    [<Extension; Inline>]\n    static member OnSeekingView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.Event -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"seeking\", view, cb))\n    [<Extension; Inline>]\n    static member OnSelect(this: Elt, cb: Dom.Element -> Dom.UIEvent -> unit) = As<Elt> ((As<Elt'> this).on(\"select\", cb))\n    [<Extension; Inline>]\n    static member OnSelectView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.UIEvent -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"select\", view, cb))\n    [<Extension; Inline>]\n    static member OnShow(this: Elt, cb: Dom.Element -> Dom.MouseEvent -> unit) = As<Elt> ((As<Elt'> this).on(\"show\", cb))\n    [<Extension; Inline>]\n    static member OnShowView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.MouseEvent -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"show\", view, cb))\n    [<Extension; Inline>]\n    static member OnStalled(this: Elt, cb: Dom.Element -> Dom.Event -> unit) = As<Elt> ((As<Elt'> this).on(\"stalled\", cb))\n    [<Extension; Inline>]\n    static member OnStalledView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.Event -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"stalled\", view, cb))\n    [<Extension; Inline>]\n    static member OnStorage(this: Elt, cb: Dom.Element -> Dom.Event -> unit) = As<Elt> ((As<Elt'> this).on(\"storage\", cb))\n    [<Extension; Inline>]\n    static member OnStorageView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.Event -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"storage\", view, cb))\n    [<Extension; Inline>]\n    static member OnSubmit(this: Elt, cb: Dom.Element -> Dom.Event -> unit) = As<Elt> ((As<Elt'> this).on(\"submit\", cb))\n    [<Extension; Inline>]\n    static member OnSubmitView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.Event -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"submit\", view, cb))\n    [<Extension; Inline>]\n    static member OnSuccess(this: Elt, cb: Dom.Element -> Dom.Event -> unit) = As<Elt> ((As<Elt'> this).on(\"success\", cb))\n    [<Extension; Inline>]\n    static member OnSuccessView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.Event -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"success\", view, cb))\n    [<Extension; Inline>]\n    static member OnSuspend(this: Elt, cb: Dom.Element -> Dom.Event -> unit) = As<Elt> ((As<Elt'> this).on(\"suspend\", cb))\n    [<Extension; Inline>]\n    static member OnSuspendView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.Event -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"suspend\", view, cb))\n    [<Extension; Inline>]\n    static member OnSVGAbort(this: Elt, cb: Dom.Element -> Dom.Event -> unit) = As<Elt> ((As<Elt'> this).on(\"SVGAbort\", cb))\n    [<Extension; Inline>]\n    static member OnSVGAbortView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.Event -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"SVGAbort\", view, cb))\n    [<Extension; Inline>]\n    static member OnSVGError(this: Elt, cb: Dom.Element -> Dom.Event -> unit) = As<Elt> ((As<Elt'> this).on(\"SVGError\", cb))\n    [<Extension; Inline>]\n    static member OnSVGErrorView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.Event -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"SVGError\", view, cb))\n    [<Extension; Inline>]\n    static member OnSVGLoad(this: Elt, cb: Dom.Element -> Dom.Event -> unit) = As<Elt> ((As<Elt'> this).on(\"SVGLoad\", cb))\n    [<Extension; Inline>]\n    static member OnSVGLoadView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.Event -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"SVGLoad\", view, cb))\n    [<Extension; Inline>]\n    static member OnSVGResize(this: Elt, cb: Dom.Element -> Dom.Event -> unit) = As<Elt> ((As<Elt'> this).on(\"SVGResize\", cb))\n    [<Extension; Inline>]\n    static member OnSVGResizeView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.Event -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"SVGResize\", view, cb))\n    [<Extension; Inline>]\n    static member OnSVGScroll(this: Elt, cb: Dom.Element -> Dom.Event -> unit) = As<Elt> ((As<Elt'> this).on(\"SVGScroll\", cb))\n    [<Extension; Inline>]\n    static member OnSVGScrollView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.Event -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"SVGScroll\", view, cb))\n    [<Extension; Inline>]\n    static member OnSVGUnload(this: Elt, cb: Dom.Element -> Dom.Event -> unit) = As<Elt> ((As<Elt'> this).on(\"SVGUnload\", cb))\n    [<Extension; Inline>]\n    static member OnSVGUnloadView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.Event -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"SVGUnload\", view, cb))\n    [<Extension; Inline>]\n    static member OnSVGZoom(this: Elt, cb: Dom.Element -> Dom.Event -> unit) = As<Elt> ((As<Elt'> this).on(\"SVGZoom\", cb))\n    [<Extension; Inline>]\n    static member OnSVGZoomView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.Event -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"SVGZoom\", view, cb))\n    [<Extension; Inline>]\n    static member OnTimeOut(this: Elt, cb: Dom.Element -> Dom.Event -> unit) = As<Elt> ((As<Elt'> this).on(\"timeout\", cb))\n    [<Extension; Inline>]\n    static member OnTimeOutView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.Event -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"timeout\", view, cb))\n    [<Extension; Inline>]\n    static member OnTimeUpdate(this: Elt, cb: Dom.Element -> Dom.Event -> unit) = As<Elt> ((As<Elt'> this).on(\"timeupdate\", cb))\n    [<Extension; Inline>]\n    static member OnTimeUpdateView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.Event -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"timeupdate\", view, cb))\n    [<Extension; Inline>]\n    static member OnTouchCancel(this: Elt, cb: Dom.Element -> Dom.Event -> unit) = As<Elt> ((As<Elt'> this).on(\"touchcancel\", cb))\n    [<Extension; Inline>]\n    static member OnTouchCancelView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.Event -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"touchcancel\", view, cb))\n    [<Extension; Inline>]\n    static member OnTouchEnd(this: Elt, cb: Dom.Element -> Dom.Event -> unit) = As<Elt> ((As<Elt'> this).on(\"touchend\", cb))\n    [<Extension; Inline>]\n    static member OnTouchEndView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.Event -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"touchend\", view, cb))\n    [<Extension; Inline>]\n    static member OnTouchEnter(this: Elt, cb: Dom.Element -> Dom.Event -> unit) = As<Elt> ((As<Elt'> this).on(\"touchenter\", cb))\n    [<Extension; Inline>]\n    static member OnTouchEnterView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.Event -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"touchenter\", view, cb))\n    [<Extension; Inline>]\n    static member OnTouchLeave(this: Elt, cb: Dom.Element -> Dom.Event -> unit) = As<Elt> ((As<Elt'> this).on(\"touchleave\", cb))\n    [<Extension; Inline>]\n    static member OnTouchLeaveView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.Event -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"touchleave\", view, cb))\n    [<Extension; Inline>]\n    static member OnTouchMove(this: Elt, cb: Dom.Element -> Dom.Event -> unit) = As<Elt> ((As<Elt'> this).on(\"touchmove\", cb))\n    [<Extension; Inline>]\n    static member OnTouchMoveView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.Event -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"touchmove\", view, cb))\n    [<Extension; Inline>]\n    static member OnTouchStart(this: Elt, cb: Dom.Element -> Dom.Event -> unit) = As<Elt> ((As<Elt'> this).on(\"touchstart\", cb))\n    [<Extension; Inline>]\n    static member OnTouchStartView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.Event -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"touchstart\", view, cb))\n    [<Extension; Inline>]\n    static member OnTransitionEnd(this: Elt, cb: Dom.Element -> Dom.Event -> unit) = As<Elt> ((As<Elt'> this).on(\"transitionend\", cb))\n    [<Extension; Inline>]\n    static member OnTransitionEndView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.Event -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"transitionend\", view, cb))\n    [<Extension; Inline>]\n    static member OnUnload(this: Elt, cb: Dom.Element -> Dom.UIEvent -> unit) = As<Elt> ((As<Elt'> this).on(\"unload\", cb))\n    [<Extension; Inline>]\n    static member OnUnloadView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.UIEvent -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"unload\", view, cb))\n    [<Extension; Inline>]\n    static member OnUpdateReady(this: Elt, cb: Dom.Element -> Dom.Event -> unit) = As<Elt> ((As<Elt'> this).on(\"updateready\", cb))\n    [<Extension; Inline>]\n    static member OnUpdateReadyView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.Event -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"updateready\", view, cb))\n    [<Extension; Inline>]\n    static member OnUpgradeNeeded(this: Elt, cb: Dom.Element -> Dom.Event -> unit) = As<Elt> ((As<Elt'> this).on(\"upgradeneeded\", cb))\n    [<Extension; Inline>]\n    static member OnUpgradeNeededView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.Event -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"upgradeneeded\", view, cb))\n    [<Extension; Inline>]\n    static member OnUserProximity(this: Elt, cb: Dom.Element -> Dom.Event -> unit) = As<Elt> ((As<Elt'> this).on(\"userproximity\", cb))\n    [<Extension; Inline>]\n    static member OnUserProximityView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.Event -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"userproximity\", view, cb))\n    [<Extension; Inline>]\n    static member OnVersionChange(this: Elt, cb: Dom.Element -> Dom.Event -> unit) = As<Elt> ((As<Elt'> this).on(\"versionchange\", cb))\n    [<Extension; Inline>]\n    static member OnVersionChangeView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.Event -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"versionchange\", view, cb))\n    [<Extension; Inline>]\n    static member OnVisibilityChange(this: Elt, cb: Dom.Element -> Dom.Event -> unit) = As<Elt> ((As<Elt'> this).on(\"visibilitychange\", cb))\n    [<Extension; Inline>]\n    static member OnVisibilityChangeView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.Event -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"visibilitychange\", view, cb))\n    [<Extension; Inline>]\n    static member OnVolumeChange(this: Elt, cb: Dom.Element -> Dom.Event -> unit) = As<Elt> ((As<Elt'> this).on(\"volumechange\", cb))\n    [<Extension; Inline>]\n    static member OnVolumeChangeView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.Event -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"volumechange\", view, cb))\n    [<Extension; Inline>]\n    static member OnWaiting(this: Elt, cb: Dom.Element -> Dom.Event -> unit) = As<Elt> ((As<Elt'> this).on(\"waiting\", cb))\n    [<Extension; Inline>]\n    static member OnWaitingView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.Event -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"waiting\", view, cb))\n    [<Extension; Inline>]\n    static member OnWheel(this: Elt, cb: Dom.Element -> Dom.WheelEvent -> unit) = As<Elt> ((As<Elt'> this).on(\"wheel\", cb))\n    [<Extension; Inline>]\n    static member OnWheelView(this: Elt, view: View<'T>, cb: Dom.Element -> Dom.WheelEvent -> 'T -> unit) = As<Elt> ((As<Elt'> this).onView(\"wheel\", view, cb))\n    // }}\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2014 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\nnamespace WebSharper.UI.Next\nopen WebSharper\n\nopen System\nopen WebSharper.UI.Next.Client\n\n[<JavaScript>]\ntype Flow<'T>(render: Var<Doc> -> ('T -> unit) -> unit) =\n\n    new (define: Func<Func<'T, unit>, Doc>) =\n        Flow(fun var cont -> Var.Set var (define.Invoke (Func<_,_>(cont))))\n\n    member this.Render = render\n\n[<JavaScript>]\n[<Sealed>]\ntype Flow =\n\n    static member Map f (x: Flow<'A>) =\n        Flow(fun var cont -> x.Render var (fun r -> (f r) |> cont))\n\n    // \"Unwrap\" the value from the flowlet, use it as an argument to the\n    // continuation k, and return the value of the applied continuation.\n\n    // Semantically, what we're doing here is running the form (or other\n    // input mechanism, but let's stick with thinking about forms), getting\n    // the result, and then using this as an input to the continuation.\n    static member Bind (m: Flow<'A>) (k: 'A -> Flow<'B>) =\n        Flow(fun var cont -> m.Render var (fun r -> (k r).Render var cont))\n\n    static member Return x =\n        Flow(fun var cont -> cont x)\n\n    static member Embed (fl: Flow<'A>) =\n        let var = Var.Create Doc.Empty\n        fl.Render var ignore\n        Doc.EmbedView var.View\n\n    static member Define (f: ('A -> unit) -> Doc) =\n        Flow(Func<_,_>(fun (x: Func<'A, unit>) -> f x.Invoke))\n\n    static member Static doc =\n        Flow(fun var cont -> Var.Set var doc; cont ())\n\n[<JavaScript>]\n[<Sealed>]\ntype FlowBuilder() =\n    member x.Bind(comp, func) = Flow.Bind comp func\n    member x.Return(value) = Flow.Return value\n    member x.ReturnFrom(inner: Flow<'A>) = inner\n\ntype Flow with\n\n    static member Do =\n        FlowBuilder()\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2014 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\nnamespace WebSharper.UI.Next\n\n// NOTES: need better facilities for the user to construct routers. In particular,\n// should be possible to encode numbers, semi-automatically provide bijections,\n// and so on.\n\nopen WebSharper\nopen WebSharper.JavaScript\nmodule A = AppendList\nmodule T = Trie\n\ntype RouteMap<'T> =\n    {\n        Des : (list<string> * Map<string, string>) -> 'T\n        Ser : 'T -> (list<string> * Map<string, string>)\n    }\n\n[<JavaScript>]\nmodule Route =\n\n    let private NoHash (s: string) =\n        if s.StartsWith(\"#\") then s.Substring(1) else s\n\n    [<Inline \"decodeURIComponent($x)\">]\n    [<MethodImpl(MethodImplOptions.NoInlining)>]\n    let private Decode (x: string) : string = U\n\n    [<Inline \"encodeURIComponent($x)\">]\n    [<MethodImpl(MethodImplOptions.NoInlining)>]\n    let private Encode (x: string) : string = U\n\n    type T =\n        private\n        | Route of AppendList<string> * Map<string, string>\n\n    let ParseHash (hash: string) =\n        let hash = NoHash hash\n        let path, query =\n            match hash.IndexOf '?' with\n            | -1 -> hash, \"\"\n            | i -> hash.[..i-1], hash.[i+1..]\n        let path =\n            if path = \"\" then [||] \n            else path.Split('/') |> Array.map Decode\n            |> A.FromArray\n        let query =\n            query.Split('&')\n            |> Array.map (fun s ->\n                match s.IndexOf '=' with\n                | -1 -> Decode s, \"\"\n                | i -> Decode (s.[..i-1]), Decode (s.[i+1..]))\n            |> Map.ofArray\n        Route (path, query)\n\n    let MakeHash (Route (path, query)) =\n        let path =\n            A.ToArray path\n            |> Array.map Encode\n            |> String.concat \"/\"\n        if Map.isEmpty query then\n            path\n        else\n            path + \"?\" +\n            (query\n            |> Seq.map (fun (KeyValue(k, v)) -> Encode k + \"=\" + Encode v)\n            |> String.concat \"&\")\n\n    [<MethodImpl(MethodImplOptions.NoInlining)>]\n    let SameHash a b =\n        NoHash a = NoHash b\n\n    let ToList (Route (rt, q)) =\n        let path =\n            A.ToArray rt\n            |> Array.toList\n        path, q\n\n    let FromList (xs, q) =\n        let a =\n            List.toArray xs\n            |> A.FromArray\n        Route(a, q)\n\n    let Append (Route (pa, qa)) (Route (pb, qb)) =\n        Route (A.Append pa pb, Map.foldBack Map.add qa qb)\n\ntype RouteContext<'T> =\n    {\n        /// Local site changes call for changing the route.\n        UpdateRoute : Route.T -> unit\n    }\n\ntype RouteBody<'T> =\n    {\n        /// Local route has changed by user via History API or similar.\n        OnRouteChanged : Route.T -> unit\n        /// This site has been selected.\n        OnSelect : unit -> unit\n        /// Identifier.\n        RouteId : int\n        /// Value characterizing the site.\n        RouteValue : 'T\n    }\n\ntype RouteId =\n    | RouteId of int\n\ntype RoutePart<'T> =\n    | Part of int * (RouteContext<'T> -> RouteBody<'T>)\n\ntype Router<'T> =\n    | R of option<'T> * Trie<string,RoutePart<'T>>\n\n[<JavaScript>]\nmodule Routing =\n\n    let InstallMap (rt: RouteMap<'T>) : Var<'T> =\n        let win = JS.Window\n        let same a b = rt.Ser a = rt.Ser b\n        let cur () =\n            Route.ParseHash win.Location.Hash\n            |> Route.ToList\n            |> rt.Des\n        let var = Var.Create (cur ())\n        let set value =\n            if not (same var.Value value) then\n                var.Value <- value\n        let onUpdate = System.Action<_>(fun (evt: Dom.Event) -> set (cur ()))\n        win.Onpopstate <- onUpdate\n        win.Onhashchange <- onUpdate\n        var.View\n        |> View.Sink (fun loc ->\n            let ha = Route.MakeHash (Route.FromList (rt.Ser loc))\n            if not (Route.SameHash win.Location.Hash ha) then\n                win.Location.Replace (\"#\" + ha))\n        var\n\n    // Given some sub-sites in a Trie, the code tries to preserve an equality:\n    //\n    //    globalRoute = currentSite.Prefix ++ currentSite.Route currentSite.State\n\n    [<MethodImpl(MethodImplOptions.NoInlining)>]\n    let DoRoute map route =\n        map.Des (Route.ToList route)\n\n    [<MethodImpl(MethodImplOptions.NoInlining)>]\n    let DoLink map va =\n        Route.FromList (map.Ser va)\n\n    let DefineRoute r init render =\n        let state = Var.Create init\n        let id = Fresh.Int ()\n        let site = render (RouteId id) state\n        let t =\n            T.Leaf (Part (id, fun ctx ->\n                state.View\n                |> View.Sink (fun va ->\n                    ctx.UpdateRoute (DoLink r va))\n                {\n                    OnRouteChanged = fun route ->\n                        state.Value <- DoRoute r route\n                    OnSelect = fun () ->\n                        ctx.UpdateRoute (DoLink r state.Value)\n                    RouteId = id\n                    RouteValue = site\n                }))\n        R (Some site, t)\n\n    let MergeRouters sites =\n        let sites = Array.ofSeqNonCopying sites\n        let merged =\n            sites\n            |> Seq.map (fun (R (_, t)) -> t)\n            |> T.Merge\n        let value =\n            sites\n            |> Seq.tryPick (fun (R (x, _)) -> x)\n        match merged with\n        | None -> failwith \"Invalid Site.Merge: need more prefix disambiguation\"\n        | Some t -> R (value, t)\n\n    type State<'T> =\n        {\n            mutable Bodies : Dictionary<int,RouteBody<'T>>\n            CurrentRoute : Var<Route.T>\n            mutable CurrentSite : int\n            mutable Selection : Var<'T>\n        }\n\n    let ComputeBodies trie =\n        let d = Dictionary()\n        trie\n        |> T.ToArray\n        |> Array.iter (fun body ->\n            d.[body.RouteId] <- body)\n        d\n\n    /// Set current route if needed.\n    let SetCurrentRoute state route =\n        if state.CurrentRoute.Value <> route then\n            state.CurrentRoute.Value <- route\n\n    /// User updates URL manually or via history API.\n    let OnGlobalRouteChange state site rest =\n        if state.CurrentSite <> site.RouteId then\n            state.CurrentSite <- site.RouteId\n            state.Selection.Value <- site.RouteValue\n        site.OnRouteChanged rest\n\n    /// A given site updates its internal state.\n    let OnInternalSiteUpdate state ix prefix rest =\n        if state.CurrentSite = ix then\n            let route = Route.Append (Route.FromList (prefix, Map.empty)) rest\n            SetCurrentRoute state route\n\n    /// User selects an different current site, which may update the global route.\n    let OnSelectSite state (RouteId id) =\n        if state.CurrentSite <> id then\n            state.CurrentSite <- id\n            state.Bodies.[id].OnSelect ()\n\n    let Install key (R (va, site)) =\n        let currentRoute = InstallMap { Ser = Route.ToList; Des = Route.FromList }\n        let state =\n            {\n                Bodies = U\n                CurrentRoute = currentRoute\n                CurrentSite = 0\n                Selection = U\n            }\n        // Initialize all sub-sites\n        let siteTrie =\n            site\n            |> T.Map (fun prefix (Part (id, init)) ->\n                init { UpdateRoute = OnInternalSiteUpdate state id prefix })\n        state.Bodies <- ComputeBodies siteTrie\n        // Setup handling changes to the currently selected site\n        let parseRoute route =\n            let path, query = Route.ToList route\n            T.Lookup siteTrie path\n            // TODO check query\n        let glob =\n            match parseRoute currentRoute.Value with\n            | T.NotFound ->\n                match va with\n                | None -> failwith \"Site.Install fails on empty site\"\n                | Some v -> v\n                |> Var.Create\n            | T.Found (site, rest) ->\n                state.CurrentSite <- site.RouteId\n                Var.Create site.RouteValue\n        state.Selection <- glob\n        glob.View\n        |> View.Sink (fun site ->\n            OnSelectSite state (key site))\n        // Setup handling currentRoute changes\n        let updateRoute route =\n            match parseRoute route with\n            | T.Found (site, rest) ->\n                Route.FromList (rest, Map.empty)\n                |> OnGlobalRouteChange state site\n            | T.NotFound -> ()\n        updateRoute currentRoute.Value\n        currentRoute.View\n        |> View.Sink updateRoute\n        glob\n\n[<JavaScript>]\n[<Sealed>]\ntype RouteMap =\n\n    static member CreateWithQuery ser des =\n        { Ser = ser; Des = des }\n\n    static member Create ser des =\n        { Ser = (fun x -> ser x, Map.empty); Des = fst >> des }\n\n    static member Install map =\n        Routing.InstallMap map\n\n[<JavaScript>]\n[<Sealed>]\ntype Router =\n\n    static member Dir prefix sites =\n        Router.Prefix prefix (Router.Merge sites)\n\n    static member Install key site =\n        Routing.Install key site\n\n    static member Merge sites =\n        Routing.MergeRouters sites\n\n    static member Prefix prefix (R (va, tree)) =\n        R (va, T.Prefix prefix tree)\n\n    static member Route r init render =\n        Routing.DefineRoute r init render\n", "namespace WebSharper.UI.Next\n\nopen WebSharper\nopen WebSharper.JavaScript\nopen WebSharper.UI.Next\nopen WebSharper.UI.Next.Notation\nopen WebSharper.JQuery\n\n[<JavaScript>]\nmodule Input =\n\n    type MousePosSt =\n        {\n            mutable Active : bool\n            PosV : Var<int * int>\n        }\n\n    type MouseBtnSt =\n        {\n            mutable Active : bool\n            Left : Var<bool>\n            Middle : Var<bool>\n            Right : Var<bool>\n        }\n\n    let MousePosSt = { Active = false; PosV = Var.Create (0, 0) }\n    let MouseBtnSt =\n        {\n            Active = false;\n            Left = Var.Create false\n            Middle = Var.Create false\n            Right = Var.Create false\n        }\n\n    // Add the button listener if it hasn't been added already.\n    // Button listener adds mousedown and mouseup events, which modify\n    // MouseBtnSt vars.\n    let ActivateButtonListener =\n        let buttonListener (evt: Dom.MouseEvent) down =\n            match evt.Button with\n            | 0 -> Var.Set MouseBtnSt.Left down\n            | 1 -> Var.Set MouseBtnSt.Middle down\n            | 2 -> Var.Set MouseBtnSt.Right down\n            | _ -> ()\n\n        if not MouseBtnSt.Active then\n            MouseBtnSt.Active <- true\n            JS.Document.AddEventListener(\"mousedown\",\n                (fun (evt: DomEvent) -> buttonListener (evt :?> Dom.MouseEvent) true), false)\n            JS.Document.AddEventListener(\"mouseup\",\n                (fun (evt: DomEvent) -> buttonListener (evt :?> Dom.MouseEvent) false), false)\n\n    [<Sealed>]\n    type Mouse =\n\n        static member Position =\n\n            let onMouseMove (evt: Dom.Event) =\n                // We know this is a mouse event, so safe to downcast\n                let mEvt = evt :?> Dom.MouseEvent\n                Var.Set MousePosSt.PosV (mEvt.ClientX, mEvt.ClientY)\n\n            // Add the mouse movement event if it's not there already.\n            if not MousePosSt.Active then\n                JS.Document.AddEventListener(\"mousemove\", onMouseMove, false)\n                MousePosSt.Active <- true\n\n            View.FromVar MousePosSt.PosV\n\n        static member LeftPressed =\n            ActivateButtonListener\n            MouseBtnSt.Left.View\n\n        static member MiddlePressed =\n            ActivateButtonListener\n            MouseBtnSt.Middle.View\n\n        static member RightPressed =\n            ActivateButtonListener\n            MouseBtnSt.Right.View\n\n        static member MousePressed =\n            ActivateButtonListener\n            // True if any button is pressed\n            View.Const (fun l m r -> l || m || r)\n            <*> MouseBtnSt.Left.View\n            <*> MouseBtnSt.Middle.View\n            <*> MouseBtnSt.Right.View\n\n    type Key = int\n\n    // State for keyboard listener: which keys are pressed, whether the listener\n    // is active, and the last key that has been presed\n    type KeyListenerSt =\n        {\n            KeysPressed : Var<Key list>\n            mutable KeyListenerActive : bool\n            LastPressed : Var<Key>\n        }\n\n    let KeyListenerState =\n        {\n            KeysPressed = Var.Create []\n            KeyListenerActive = false\n            LastPressed = Var.Create (-1)\n        }\n\n    let ActivateKeyListener =\n        if not KeyListenerState.KeyListenerActive then\n            // Using JQuery for cross-compatibility.\n            JQuery.Of(JS.Document).Keydown(fun el evt ->\n                let keyCode = evt.Which\n                Var.Set KeyListenerState.LastPressed keyCode\n                let xs = Var.Get KeyListenerState.KeysPressed\n                if not (List.exists (fun x -> x = keyCode) xs) then\n                    KeyListenerState.KeysPressed.Value <- xs @ [keyCode]\n            ) |> ignore\n\n            JQuery.Of(JS.Document).Keyup(fun el evt ->\n                let keyCode = evt.Which\n                Var.Update KeyListenerState.KeysPressed\n                    (List.filter (fun x -> x <> keyCode))\n            ) |> ignore\n\n    [<Sealed>]\n    type Keyboard =\n\n        static member KeysPressed =\n            ActivateKeyListener\n            KeyListenerState.KeysPressed.View\n\n        static member LastPressed =\n            ActivateKeyListener\n            KeyListenerState.LastPressed.View\n\n        static member IsPressed key =\n            ActivateKeyListener\n            View.Map (List.exists (fun x -> x = key))\n                KeyListenerState.KeysPressed.View\n"],
"names": [],
"mappings": "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"
}
